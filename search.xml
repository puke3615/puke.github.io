<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件组]]></title>
    <url>%2F2016%2F10%2F16%2FAndroid%20Studio%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%96%87%E4%BB%B6%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Android Studio模板系列文章 Android Studio模板之代码片段 Android Studio模板之文件 Android Studio模板之文件组 效果图展示说再多，不如图来的实在，先上图 已有工程中使用模板效果图 创建工程时使用模板 示例场景在进行Android开发时，我们经常会创建一个Demo工程，目的可能有很多种，可能是为了验证一个问题，可能是为了学习一个框架的使用，可能为了测试自己写的一个lib库等等。这个时候我们可能会创建一个Activity，然后再在xml写一些按钮，再在Activity里写该按钮的事件监听逻辑，也就是说为了执行一段代码我们要做这么多操作。为了简化这段重复操作，我这边写了一个DebugActivity类，然后支持我们只需要写个子类来继承它，然后像下面这样写几个方法即可，运行的时候会根据方法动态创建按钮，并在点击按钮时执行该方法的代码逻辑。 123public void _test() &#123; T("弹出Toast");&#125; 由于本文主要介绍模板相关的，所以该场景相关的具体代码技术细节就不多说了，有兴趣的可以看下，DebugActivity的代码，这里提出来只是为模板开发简单的做个铺垫。 模板位置Android Studio Template中有系统预设的一些模板，我们可以直接修改，也可以另行添加新的模板。打开Android Studio安装目录/Contents/plugins/android/lib/templates这个文件夹我们能看到下面的目录结构，这里便是AS中模板存放的位置。 我们接下来的工作也就在这里，保险起见我们在这里新建一个目录，我们自己写的模板都放在自己新建的目录里，例如我这里就创建了一个叫pk的目录。 模板规范在上面的基础上，我们可以直接打开/activies/EmptyActivity目录，如下图 我们可以看到上面红色区域便是Template的文件结构，大致说下各个文件（夹）的含义 globals.xml.ftl 模板中参数配置的地方（可选） recipe.xml.ftl 模板行为执行处，引入这个模板之后，接下来要做什么事情，就是它说的算（可选，但是不选就没有意义了，因为模板引入是要要行为驱动的） root 存放模板文件及引入资源的目录，模板文件可以是.xml、.java、.gradle等任何一个文本格式的文件，资源一般是我们引入的.png资源文件（可选，不选同上） template_blank_activity.png 引入模板时的引导图（可选） template.xml 面向模板引擎的配置文件（必选） 我们可以看到，真正核心的部分就是root、recipe.xml.ftl和template.xml，接下来这重点说明这三部分。 我们可以打开root目录，能够看到里面的文件除了图片资源文件都是以.ftl结尾的，而.ftl是标准的FreeMarker的文件。FreeMarker是类似于Velocity的一种模板框架，据说对于多文件处理时它具有更好的性能，大概也是Android Studio选择Velocity作为单文件模板，选择FreeMarker作为文件组模板的原因吧。有兴趣的可以去FreeMarker官网学习一下，它的自定义标签功能还是很强大的，个人感觉比Velocity的更加接地气。 接下来我们看一下recipe.xml.ftl 的内容，打开如下 1234567891011121314&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;#include "../common/recipe_manifest.xml.ftl" /&gt;&lt;#if generateLayout&gt; &lt;#include "../common/recipe_simple.xml.ftl" /&gt; &lt;open file="$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml" /&gt;&lt;/#if&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt;&lt;/recipe&gt; 这里以&lt;#开头的都是FreeMarker的语法，基本上比葫芦画瓢就能看明白，就不多说了。其实对于这个文件最重要的部分是下面四个标签 copy 就是简单的copy，把模板root目录下的某个文件copy到目标工程的某个目录下 instantiate 跟copy很类似，唯一多的一点功能就是并不只简单的走IO流进行copy，而是通过FreeMarker框架按照模板中的FreeMarker能识别的逻辑判断和数据引入来生成最终的目标文件 merge 目标项目中有了某文件，而我们还要想该文件合并一些我们的模板的部分时，就选用merge，例如我们添加一个Activity时需要mergeAndroidManifest.xml的配置。目前支持的merge格式有.xml和.gradle，但是对.gradle支持的不怎么好，不过不影响该模板的开发，对于这套模板引擎的开发者来说，这可能是最麻烦的部分了，但是对于我们使用者就不用考那么多了，直接使用吧 open 这个很简单，就是指定模板引入之后要IDE打开的文件 然后看下template.xml内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Empty Activity" minApi="7" minBuildApi="14" description="Creates a new empty activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity Name" type="string" constraints="class|unique|nonempty" suggest="$&#123;layoutToActivity(layoutName)&#125;" default="MainActivity" help="The name of the activity class to create" /&gt; &lt;parameter id="generateLayout" name="Generate Layout File" type="boolean" default="true" help="If true, a layout file will be generated" /&gt; &lt;parameter id="layoutName" name="Layout Name" type="string" constraints="layout|unique|nonempty" suggest="$&#123;activityToLayout(activityClass)&#125;" default="activity_main" visibility="generateLayout" help="The name of the layout to create for the activity" /&gt; &lt;parameter id="isLauncher" name="Launcher Activity" type="boolean" default="false" help="If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher" /&gt; &lt;parameter id="packageName" name="Package name" type="string" constraints="package" default="com.mycompany.myapp" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; 当我们进行模板引入时，AS会弹出一个如下图的UI界面，要我们来填入或选择一些数据，例如输入Activity的的名称，选择SDK的版本之类的。而这个界面就是根据由该文件而来的。 内容比较多，为减少篇幅我挑些重要的说 template标签 name 引入模板时的模板名称，就死根据他选择哪个模板的 description 弹出Dialog的标题，对应上去的区域1 category 表示该模板属于哪种分类，在引入的时候会有个分类的选择 parameter 每个该标签就对应Dialog界面的一个输入项 id 该参数的唯一标识符，也是我们在.ftl中引入的值，例如定义的id为username，引用时就是$username name 对应Dialog上面该输入项的名称 type 对应该参数的类型，Dialog就是根据这个来决定对应输入是选择框、输入框还是下拉框等等 constraints 对应该参数的约束，如果有多个要用|分割开 suggest 建议值，这个输入部分是由级联效应的，可能你改了A参数，B参数也会跟着改变，就是根据这个参数决定的 default 参数的默认值 visibility 可见性，要配置一个boolean类型的参数，一般指向另一个输入源 help 当焦点在某个输入源上面时，上图的区域3的就限制这儿的内容 操刀实战了解了模板规范之后，我们编写模板时就不会那么被动了，下面我们来自己动手编写文章开始部分展示的模板。 首先在刚才提到的自定义的模板下创建如下图所示的目录结构 DebugActivity root src app_package DebugActivity.java.ftl JumpActivity.java.ftl SimpleActivity.java.ftl AndroidManifest.xml.ftl globals.xml.ftl recipe.xml.ftl template.xml template_debug_activity.png 然后将下面的代码对应贴进去（图片部分随便找一张代替好了…） globals.xml.ftl 123456&lt;?xml version="1.0"?&gt;&lt;globals&gt; &lt;global id="resOut" value="$&#123;resDir&#125;" /&gt; &lt;global id="srcOut" value="$&#123;srcDir&#125;/$&#123;slashedPackageName(packageName)&#125;" /&gt; &lt;global id="relativePackage" value="&lt;#if relativePackage?has_content&gt;$&#123;relativePackage&#125;&lt;#else&gt;$&#123;packageName&#125;&lt;/#if&gt;" /&gt;&lt;/globals&gt; recipe.xml.ftl 123456789101112131415161718192021&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;instantiate from="root/src/app_package/DebugActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;#if addJumpActivity&gt; &lt;instantiate from="root/src/app_package/JumpActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/JumpActivity.java" /&gt; &lt;/#if&gt; &lt;merge from="root/AndroidManifest.xml.ftl" to="$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt;&lt;/recipe&gt; template.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Debug Activity" minApi="7" minBuildApi="14" description="创建一个Debug的Activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity名称" type="string" constraints="class|unique|nonempty" default="SetupActivity" help="创建Activity的名称" /&gt; &lt;parameter id="addExample" name="是否添加按钮使用示例" type="boolean" default="false" help="选择时会自动生成测试按钮；否则不生成" /&gt; &lt;parameter id="addJumpActivity" name="是否添加跳转Activity示例" type="boolean" default="false" help="选择时会自动生成跳转Activity相关逻辑；否则不生成" /&gt; &lt;parameter id="isLauncher" name="设为启动页面" type="boolean" default="true" help="选择时设置该页面为启动页面；否则不设" /&gt; &lt;parameter id="packageName" name="包名" type="string" constraints="package" default="com.mycompany.myapp" help="输入Application包名" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_debug_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; AndroidManifest.xml.ftl 123456789101112131415161718&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;application&gt; &lt;#if addJumpActivity&gt; &lt;activity android:name="$&#123;relativePackage&#125;.JumpActivity"/&gt; &lt;/#if&gt; &lt;activity android:name="$&#123;relativePackage&#125;.SetupActivity"&gt; &lt;#if !(isLibraryProject!false) &amp;&amp; isLauncher&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/#if&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; DebugActivity.java.ftl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package $&#123;packageName&#125;;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * Debug测试类,快速调试Demo工程&lt;hr /&gt; * 使用姿势:&lt;br /&gt; * 1. 新建一个子类继承该类&lt;br /&gt; * 2. 跳转Activity: 在子类配置&#123;@link Jump&#125;注解, 然后在注解中配置跳转Activity的类型&lt;br /&gt; * 3. 点击按钮触发方法: 在子类声明一个名称以"_"开头的方法(支持任意修饰符),最终生成按钮的文字便是改方法截去"_"&lt;br /&gt; * 4. 方法参数支持缺省参数和单个参数&lt;br /&gt; * 5. 如果是单个参数,参数类型必须是Button或Button的父类类型,当方法执行时,该参数会被赋值为该Buttom对象&lt;br /&gt; * https://github.com/puke3615/DebugActivity&lt;br /&gt; * &lt;p&gt; * * @author zijiao * @version 16/10/16 */public abstract class DebugActivity extends Activity &#123; protected static final String FIXED_PREFIX = "_"; private final String TAG = getClass().getName(); private final List&lt;ButtonItem&gt; buttonItems = new ArrayList&lt;&gt;(); protected LinearLayout linearLayout; protected Context context; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Jump &#123; Class&lt;? extends Activity&gt;[] value() default &#123;&#125;; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.context = this; ScrollView scrollView = new ScrollView(this); setContentView(scrollView); this.linearLayout = new LinearLayout(this); this.linearLayout.setOrientation(LinearLayout.VERTICAL); scrollView.addView(linearLayout); try &#123; resolveConfig(); createButton(); &#125; catch (Throwable e) &#123; error(e.getMessage()); &#125; &#125; private void createButton() &#123; for (ButtonItem buttonItem : buttonItems) &#123; linearLayout.addView(buildButton(buttonItem)); &#125; &#125; protected View buildButton(final ButtonItem buttonItem) &#123; final Button button = new Button(this); button.setText(buttonItem.name); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (buttonItem.target != null) &#123; to(buttonItem.target); &#125; else &#123; Method method = buttonItem.method; method.setAccessible(true); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); int paramSize = parameterTypes.length; switch (paramSize) &#123; case 0: try &#123; method.invoke(DebugActivity.this); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; case 1: if (parameterTypes[0].isAssignableFrom(Button.class)) &#123; try &#123; method.invoke(DebugActivity.this, button); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; &#125; default: error(method.getName() + "方法参数配置错误."); break; &#125; &#125; &#125; &#125;); return button; &#125; private void resolveConfig() &#123; Class&lt;?&gt; cls = getClass(); //读取跳转配置 if (cls.isAnnotationPresent(Jump.class)) &#123; Jump annotation = cls.getAnnotation(Jump.class); for (Class&lt;? extends Activity&gt; activityClass : annotation.value()) &#123; buttonItems.add(buildJumpActivityItem(activityClass)); &#125; &#125; //读取方法 for (Method method : cls.getDeclaredMethods()) &#123; handleMethod(method); &#125; &#125; protected void handleMethod(Method method) &#123; String methodName = method.getName(); if (methodName.startsWith(FIXED_PREFIX)) &#123; methodName = methodName.replaceFirst(FIXED_PREFIX, ""); ButtonItem buttonItem = new ButtonItem(); buttonItem.method = method; buttonItem.name = methodName; buttonItems.add(buttonItem); &#125; &#125; protected ButtonItem buildJumpActivityItem(Class&lt;? extends Activity&gt; activityClass) &#123; ButtonItem buttonItem = new ButtonItem(); buttonItem.name = "跳转到" + activityClass.getSimpleName(); buttonItem.target = activityClass; return buttonItem; &#125; public void L(Object s) &#123; Log.i(TAG, s + ""); &#125; public void error(String errorMessage) &#123; T("[错误信息]\n" + errorMessage); &#125; public void T(Object message) &#123; Toast.makeText(context, String.valueOf(message), Toast.LENGTH_SHORT).show(); &#125; public void to(Class&lt;? extends Activity&gt; target) &#123; try &#123; startActivity(new Intent(this, target)); &#125; catch (Exception e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; &#125; public void T(String format, Object... values) &#123; T(String.format(format, values)); &#125; protected static class ButtonItem &#123; public String name; public Method method; public Class&lt;? extends Activity&gt; target; &#125;&#125; JumpActivity.java.ftl 1234567891011121314151617181920package $&#123;packageName&#125;;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;/** * @author zijiao * @version 16/10/16 */public class JumpActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView text = new TextView(this); text.setText("跳转Activity成功"); setContentView(text); &#125;&#125; SimpleActivity.java.ftl 12345678910111213141516171819202122232425262728293031323334353637383940package $&#123;packageName&#125;;@DebugActivity.Jump(&#123;&lt;#if addJumpActivity&gt; JumpActivity.class,&lt;#else&gt;&lt;/#if&gt;&#125;)public class $&#123;activityClass&#125; extends DebugActivity &#123;&lt;#if addExample&gt; private int number = 0; public void _无参方法调用() &#123; T("无参方法调用"); &#125; public void _有参方法调用(Button button) &#123; button.setText("number is " + number++); &#125; //代码执行不到,直接弹出toast提示报错 public void _错误参数调用(String msg) &#123; T("test"); &#125; //方法名没有以"_"开头,按钮无法创建成功 public void 无效调用() &#123; T("test"); &#125; //crash会被会被catch住,以toast方式弹出 public void _Crash测试() &#123; int a = 1 / 0; &#125;&lt;/#if&gt;&#125; ok，到此对于该模板的编写过程就结束了，接下来重启下Android Studio，然后New Project一路next下去，直到这个界面，这里就是我们自定义的DebugActivity模板了 下面是该模板的Github源码 https://github.com/puke3615/DebugActivity.git]]></content>
      <tags>
        <tag>高效开发</tag>
        <tag>Template</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件]]></title>
    <url>%2F2016%2F10%2F15%2FAndroid%20Studio%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android Studio模板系列文章 Android Studio模板之代码片段 Android Studio模板之文件 Android Studio模板之文件组 我们开发的过程中可能会遇到有些类在不同的工程下都需要使用，单独抽成jar包可能又有点小题大做了，而且还得在下次使用的时候去依赖它，这个时候我们AS中的FileTemplate便派上用场了。 FileTemplate使用 我们开发中可能经常去写一个继承BaseAdapter的子Adapter，而且里面有一大串无脑代码，于是我写了这个DataAdapter的模板。 Android Studio给我提供了创建模板的快捷方式，我们可以打开任意一个类，然后选择顶部的Tools—Save File As Template便可以快速创建一个当前类的模板文件 或者直接通过Preferences — Editor — File and Code Templates右边的加号创建 然后IDE会自动打开这个界面 大致说下这几个区域 区域1：模板的名称，唯一标识一个文件模板 区域2：模板的后缀名，填写当前属于哪种文件的模板 区域3：模板编辑区 区域4：一些可选配置 区域5：官方对FileTemplate的简单描述，往下滑我们可以看到系统的预设变量（类似于上一章中的预设变量），这里的内容不是很多但营养价值很高，建议看一下 接下来我们编辑模板，把这段模板内容直接粘贴到编辑区，然后给模板命名为User即保存关闭该弹窗 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] name = &#123;&#125;;&#125; 现在我们来引入刚写的模板，右键选择待添加模板的包 — New — User 也可以New一个Java Class然后在弹窗中通过上下方向键或者下拉列表来选择找到创建的User模板 还可以直接在New下面选择 创建模板之后的引入方式有很多，我们可以使用自己比较喜欢的方式去引入。最终输入文件名点确定，代码直接生成出来。 上面说的是最基本的文件模板需求，当我们的文件需要多个参数时，例如User这个模板的name属性名可能是多边的，只有引入模板时才能确定下来，这时我们可以用自定义变量来表示，如下 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] $&#123;fieldName&#125; = &#123;&#125;;&#125; 这个时候我们再引入模板时，IDE会扫描有没有自定义变量，如果有的并且没有被初始化赋值的话就在弹出的对话框中多一个可编辑的区域，如下图 这便支持自定义参数的场景，到这一步为止，一般的文件模板需求我们都可以自己满足了。下面介绍一些相对深一点的使用方式，有兴趣的可以看看。 VTL语法总结Android Studio的FileTemplate使用Velocity Template Language（简称VTL）进行逻辑判断和流程控制，有兴趣的可以直接看下Velocity的官方文档 我们看下面的一个模板片段 123456789101112131415161718192021## 宏定义#macro( tablerows $color $somelist )#foreach( $something in $somelist ) &lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end ## 初始化names列表#set ($names = ["dog", "cat", "^&amp;*("]) ## 遍历names列表#foreach ($name in $names) &#123;#if ($name = "dog") This is a dog;#elseif ($name = "cat") This is a cat.#else This is a nothing.#end #end&#125; VTL语法规则还是蛮多的，这里就不一一介绍了，我总结一下我们在写AS的FileTemplate时最常用的一些点 “##”是行注释，类似Java的“//” “#* *#”是区域注释，类似Java的“/* */” 所有的逻辑控制符都是以“#”开头 没有使用“{}”来限定区域，所以使用“#if”和“#foreach”时要加“#end”结束标识符 变量名是以“$”开头 支持宏定义（这点很实用） 集合都是List数据结构，写法为{“a”, b”}，Map的写法为[“key1” : “value1”, “key2” : “value2”] ……]]></content>
      <tags>
        <tag>高效开发</tag>
        <tag>Template</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之代码片段]]></title>
    <url>%2F2016%2F10%2F14%2FAndroid%20Studio%E6%A8%A1%E6%9D%BF%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[Android Studio模板系列文章 Android Studio模板之代码片段 Android Studio模板之文件 Android Studio模板之文件组 下面先直接上几张演示效果图 创建一个单例类 写一个将InputStream转化为String的方法 生成main方法并打印数字 用try catch来包装代码块 上面的这些有的是IDE自带的，有的是自定义的。具体位置我们可以进入IDE，Preserences，Editor，Live Templates，我们可以在右边栏看到一些列IDE预设的template，如下图 这里我们展开Android，可以看到下图 这里面所有的我们都可以使用，括号后面的内容是为了描述该模板的，你也可以取消前面的勾选来取消该模板。 其实系统预设的有很多都是很实用的，有兴趣的可以去试一试，不多说。这里主要看一下如何自定义模板，把一些常用的代码片段DIY到自己的模板库中，当下次再需要同样代码的时候只需要一个标识符就能迅速自动生成。 我们点击右上角的加号，我们可以看到两个选项一个是Live Template，这个表示一个模板，另一个是Template Group，这个表示一个模板所属的分组，就像上面看到的Android，它就属于一个分组。 接下来我们先创建一个自己的Template Group，名称随便取，不要与已有的分组重名就行，这里就取为Custom。然后我们选中新建的这个Custom分组再创建Live Template，会看到如下界面 我对这个界面做了数字标志，大致说下每个区域代表的含义 区域1：表示模板的缩写，也是我们最终使用时在编辑区输入的指令 区域2：表示模板的提示，当输入对应缩写时，就会弹出这个提示 区域3：这里就是最关键的模板区了，模板区包含两部分，一个是模板内容，它可以是任意字符串，另一个是模板变量，它有自己特殊的含义并且格式固定，首尾都是”$”符。模板变量又包含预设变量和自定义变量，比如”$END$”就是一个预设变量，它指定了模板导入结束后鼠标光标最终要停留的位置，而自定义变量则表示模板中一些动态性的部分，比如类名，它在不同的类中引入的结果是不同的。在多个自定义变量的情况下引入模板时，默认按TAB键切换至下个自定义变量位置。 区域4：自定义变量的配置入口，可以给我们的自定义变量添加一些约束条件 区域5：指定该模板的作用域，例如指定用于Java还是groovy等等 区域6：提供一些引入模板的可选操作 这里我们来写一个生成单例的模板，我们按照下图定义好缩写，描述与模板内容 模板内容的代码如下 12345678910111213141516private static final byte[] sInstanceLock = new byte[0];private static $className$ sInstance;private $className$() &#123;&#125;public static $className$ instance() &#123; if (sInstance == null) &#123; synchronized (sInstanceLock) &#123; if (sInstance == null) &#123; sInstance = new $className$(); &#125; &#125; &#125; return sInstance;&#125; 然后我们选择区域4来编辑我们的自定义变量，我们进去后可以看到如下弹窗 Name为自定义的变量名称 Expression表示系统提供的一些方法 Default value为改变量的默认值 Skip if define勾选后，如果该变量被赋值则跳过，相当于引入过程中一次手动的TAB 接着我们在Expression中选择className()，并勾选Skip if define，并点击确定 最后我们点击区域5来选择模板的作用域，我们选择Java—Declaration 然后保存，我们的单例模板便生成成功了。测试下，在IDE中新建个Java类，在类的内部输入single便出现最上面的那个UserManager的效果。 当然除此之外还有使用”$SELECTION$”来包装代码块的模板，这个使用场景相对较少这里就不举例了，主要使用的就是这种直接的模板模式。感觉一些常用的，特别是工具类中静态方法相关的，我们都可以抽取成模板，提高开发效率。]]></content>
      <tags>
        <tag>高效开发</tag>
        <tag>Template</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CallbackProxy模式]]></title>
    <url>%2F2016%2F09%2F04%2FCallbackProxy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、 Callback问题1. 背景1234567891011121314151617181920212223242526public class Manager &#123; public void operate() &#123; a(); b(); c(); d(); e(); &#125; private void a() &#123; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 这是一个简单的Manager类，模拟的是一个底层框架向上层提供的管理类，这里先假设我们这个类的使用方有10个(在这里我们就编号C1~C10)，而他们最终的运行环境都是一致的，只是开发期的环境不一致。我想过直接把一些真实场景中的代码拿出来举例，但是偏向业务的代码往往比较复杂且冗余，所以这里我们就简单粗暴地写了几个空方法模拟。其中operate()方法是提供给外部调用的方法，operate()方法中会调用到内部的a~e的一系列方法。 2. 需求叠加本来是一个简单的业务逻辑，但是突然有个业务方C1说他们需要在Manager的operate()方法的a()方法中添加一个回调，给业务方去处理。于是便有了我们的Callback接口： 123public interface Callback &#123; void callA();&#125; 并且我们还要改造我们的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private Callback mCallback; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们在Manger类中添加一个Callback变量，并向业务方提供了setCakkback(CallbackA callback)方法为了方便外部把自己想在a()方法中做的操作set进来，这样处理既能让我们的业务方C1能够在a()方法中做他们定制化的处理，也不会影响到其他业务方的正常使用。 下面便是业务方C1的代码实现部分： 1234567891011121314public class ClientA &#123; public static void main(String[] args) &#123; Manager manager = new Manager(); manager.setCallbackA(new Callback() &#123; @Override public void callA() &#123; //do something &#125; &#125;); manager.operate(); &#125; &#125; 3. 需求再叠加由于业务是多变的，业务会随着许多主观以及客观的情况不断发生改变，某一天我们的业务方C2突然跟我们说，他们需要在b()方法中添加一个回调以处理他们内部的业务逻辑。于是我们开始考虑，上次C1提到要在a()方法中添加回调的时候，我们有创建了一个Callback的接口，并且有在Manager类中提供了setCallback()方法，那我们能不能为了代码的复用性而直接在Callback接口中添加一个回调方法callB()呢。但答案是否认的，因为如果你这样做了，业务方C1会莫名躺枪的…… 既然我们不能添加Callback中的方法，又不想想我们对业务方C2支持的同时又去影响到C1，那我们只能新建一个接口CallbackB了： 123public interface CallbackB &#123; void callB(); &#125; 于是，我们的Manager又得这样改变： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Manager &#123; private Callback mCallback; private CallbackB mCallbackB; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB; &#125; private void b() &#123; if (mCallbackB != null) &#123; mCallbackB.callB(); &#125; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们开始看一下我们对Manager类的改动，我们这次的代码增量是： 123456789101112//1. 新增的CallbackB属性private CallbackB mCallbackB;//2. 新增的CallbackB的set方法public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB;&#125;//3. 新增的回调逻辑的调用时机if (mCallbackB != null) &#123; mCallbackB.callB();&#125; 我这里将增量部分切分为1、2、3三个部分。我们来仔细分析一下这三个部分，其中1和2其实是一种“无脑操作”，就是新增加一个回调接口，并提供回调接口的set方法而已，更甚至来说，3中的非空判断也都是冗余的。 仅仅为了满足C2的回调处理其实是简单的，只是既然今天C2会过来说是需要b()方法的回调，那接下来谁也不敢保证C3、C4、C5会不会再过来提出要在c()方法，d()方法，e()方法中添加对应的回调，甚至C3要abc的回调，C4要ace的回调。业务简单的时候，代码不一定是简单的，但是业务复杂的时候，代码一定是复杂的。 而且，站在职责单一的角度来看，对于我们的Manager类是不应该去维护这样一系列繁琐的Callback，并且还要在每个回调时机时进行非空判断的。 二、 CallbackProxy模式1. CallbackProxy的引入这里我们引入CallbackProxy模式，我们先定义一个空接口： 12public interface Callback &#123;&#125; 这个接口就是对于Manager类的一个统一协定，协定所有Manager向外的回调都必须继承该接口。 接下来便有我们的一系列Callback： 123public interface CallbackA &#123; void callA();&#125; 123public interface CallbackB &#123; void callB();&#125; 123public interface CallbackC &#123; void callC();&#125; 然后有一个类来实现所有的Manager需要向外回调的Callback，然后都是一些空实现。 12345678910111213141516public class SimpleCallback implements CallbackA, CallbackB, CallbackC &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125;&#125; 然后便有我们的重头戏CallbackProxy，它继承于SimpleCallback，然后内部存储一个真实的Callback，并向外提供一个setCallback()方法: 1234567891011121314151617181920212223242526272829public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125;&#125; 接下来我们来看一下我们的引入CallbackProxy之后的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们可以看到，现在的Manager类不需要再声明一系列的Callback，再提供一系列的setCallback方法，再来一堆的非空判断，这些都让我们的CallbackProxy来做了。而我们的Manger类只需要专注于他自己的业务逻辑处理和选择合适的时机进行回调即可。 2. 拓展性上面的引入Callback的例子中我们写了a~c的回调，现在假如某个业务方还需要我们提供d()方法的回调，接下来我们只需要在新建一个CallbackD类，并在SimpleCallback和CallbackProxy做出对应的改变，然后在我们的真正做回调处理的Manager类中直接在d()方法中调用mCallback的callD()方法即可，代码如下： 123public interface CallbackD &#123; void callD();&#125; 123456789101112131415161718192021public class SimpleCallback implements CallbackA, CallbackB, CallbackC, CallbackD &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125; @Override public void callD() &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125; @Override public void callD() &#123; if (mCallback instanceof CallbackD) &#123; ((CallbackD) mCallback).callD(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; mCallbackProxy.callD(); &#125; private void e() &#123; &#125;&#125; 我们会发现我们的逻辑变得很清晰，类虽然多点，但是各司其职、有条不紊。 3. 更高效开发其实到了上面，CallbackProxy的介绍已经是完成了，但有一点需要说明，就是关于对Callback拓展的时候。我们发现其实我们真正做的回调操作仅仅是定义CallbackD和在Manager的d()方法中添加callB()的回调这两个地方。其他的在SimpleCallback和CallbackProxy的处理都是绝对无脑的，于是我们应用APT技术来简化我们的SimpleCallback和CallbackkProxy的处理(由于该篇不是为了介绍APT的，这里只把简单的使用效果贴出来)。 12345678@ProxyGenerator( rootClass = Callback.class)public interface Api extends Base, CallbackHolder.Callback1, CallbackHolder.Callback2, CallbackHolder.Callback3, CallbackHolder.Callback4 &#123; String login(String username);&#125; 这里我们只需要写一个接口继承我们所有需要添加的Callback，然后加上一些注解配置，即可自动生成对应的SimpleCallback和CallbackProxy类： 123456789101112131415161718192021222324252627282930313233public abstract class SimpleApi implements Api &#123; @Override public String login(String username) &#123; return null; &#125; @Override public void base() &#123; &#125; @Override public int commonOperation() &#123; return 0; &#125; @Override public void call1() &#123; &#125; @Override public void call2(String name, int age) &#123; &#125; @Override public int call3(String name) &#123; return 0; &#125; @Override public String call4(int age) &#123; return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public final class ApiProxy implements Api &#123; private Callback mCallback; @Override public String login(String username) &#123; if (mCallback instanceof Api) &#123; return ((Api) mCallback).login(username); &#125; return null; &#125; @Override public void base() &#123; if (mCallback instanceof Base) &#123; ((Base) mCallback).base(); &#125; &#125; @Override public int commonOperation() &#123; if (mCallback instanceof Base) &#123; return ((Base) mCallback).commonOperation(); &#125; return 0; &#125; @Override public void call1() &#123; if (mCallback instanceof CallbackHolder.Callback1) &#123; ((CallbackHolder.Callback1) mCallback).call1(); &#125; &#125; @Override public void call2(String name, int age) &#123; if (mCallback instanceof CallbackHolder.Callback2) &#123; ((CallbackHolder.Callback2) mCallback).call2(name, age); &#125; &#125; @Override public int call3(String name) &#123; if (mCallback instanceof CallbackHolder.Callback3) &#123; return ((CallbackHolder.Callback3) mCallback).call3(name); &#125; return 0; &#125; @Override public String call4(int age) &#123; if (mCallback instanceof CallbackHolder.Callback4) &#123; return ((CallbackHolder.Callback4) mCallback).call4(age); &#125; return null; &#125; public final void setCallback(Callback mCallback) &#123; this.mCallback = mCallback; &#125;&#125; 也就是说当我们需要拓展一个新的Callback时，只需要让Api这个接口多继承一个新的Callback并generate，然后 就可以在Manager类中添加对应的回调就ok了。]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>APT</tag>
        <tag>CallbackProxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FCodeGenerator%2F</url>
    <content type="text"><![CDATA[1. 单例生成 2. Copy生成 3. FindView生成 4. MainMethod生成 5. Activity添加到AndroidManifest.xml]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>Android Studio Plugin</tag>
        <tag>Generaotr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BuilderGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FBuilderGenerator%2F</url>
    <content type="text"><![CDATA[日常开发中，我们经常会使用到Builder模式，我们一般都是直接手动地去写一个Builder类来使用。这里我们采用APT的方式进行配置生成Builder类 一、 快速接入1. 配置apt依赖外层gradle添加 1classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' 内层build.gradle添加 1apply plugin: 'com.neenbedankt.android-apt' 2. 配置该框架依赖内层build.gradle添加 12compile 'com.puke:buildergenerator-api:1.0.0'apt 'com.puke:buildergenerator-compiler:1.0.0' 到这里，配置部分就结束了，接下来就是使用过程。 3. 使用姿势这里我们模拟一个需要使用Builder模式的类Dog 123456789101112131415public class Dog &#123; private String name; private int age; private String sex; private Color color; @Builder("configure") Dog(@Item("customName") String name, @Item int age, @Item String sex, Color color) &#123; this.name = name; this.age = age; this.sex = sex; this.color = color; &#125;&#125; 然后只需要build一下Project就ok了 我们可以在该Module的“build/generated/source/apt”目录下找到对应的DogBuilder类，如下 1234567891011121314151617181920212223242526272829// this is a generated file.package com.puke.buildergeneator;public final class DogBuilder &#123; private String customName; private int age; private String sex; public final DogBuilder configureCustomName(String customName) &#123; this.customName = customName; return this; &#125; public final DogBuilder configureAge(int age) &#123; this.age = age; return this; &#125; public final DogBuilder configureSex(String sex) &#123; this.sex = sex; return this; &#125; public final Dog build() &#123; return new Dog(customName, age, sex, null); &#125;&#125; 4. 几点说明整体比较轻巧，使用起来也比较简单，我们可以重点看一下该类的构造方法，接下来几点说明： 构造方法上面加了@Builder注解 表示该类是要生成Builder类 @Builder中注入了“configure” 表示生成注解类的组装子Item的方法前面全部都要加上”configure“关键字，当然这个是可选的，如果不加的话就会直接就直接取方法名 构造方法中加入了@Item注解 加入了@Item注解的参数表示Builder类中可以加入的参数，未加则不能通过Builder加入 @Item中注入“customName” 表示在Builder类中给对应的属性设置的别名，不设时默认去参数名 二、 项目源码https://github.com/puke3615/BuilderGeneator.git]]></content>
      <categories>
        <category>APT</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>APT</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android注解]]></title>
    <url>%2F2016%2F08%2F29%2FAndroid%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在Java中经常会用到注解，通过注解的方式可以实现很多灵活性的东西。很多优秀的框架都支持注解的方式，如Spring的中对Bean的注解，Hibernate中对POJO类的注解，Mybatis中对Mapper的注解，ButterKnife中对View的注解，Dagger中对各个Component的注解， Retrofit对Api的注解。一言以蔽之，使用注解可以让整个代码风格看起来清爽明了。 一、 传统的代码风格activity_main.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/username" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入用户名.." /&gt; &lt;Button android:id="@+id/submit" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="提交" /&gt;&lt;/LinearLayout&gt; 很简单的一个界面，只有一个EditText和一个Button，就不过多解释了。 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends Activity &#123; private EditText mUsername; private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initListener(); &#125; private void findView() &#123; mUsername = (EditText) findViewById(R.id.username); mSubmit = (Button) findViewById(R.id.submit); &#125; private void initListener() &#123; mSubmit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 我们这里要做到是用户点击提交的时候，Toast弹出EditText输入的内容，比较简单，略过~ 传统的风格是这样的，这样看来也许觉得没什么问题，但是实际的开发当中我们一个页面当中包含的View，以及对应的View的一些事件回调要远远比这个繁琐。我相信一个Activity中要处理十几二十几个View也不算是什么稀奇的事情，那这样会造成什么结果呢。。。 你的属性声明会是这样的 12345678private Button mButton1;private Button mButton2;private Button mButton3;private Button mButton4;private Button mButton5;private Button mButton6;private Button mButton7;private Button mButton8; 你的findView会是这样的 12345678mButton1 = (Button) findViewById(R.id.button1);mButton2 = (Button) findViewById(R.id.button2);mButton3 = (Button) findViewById(R.id.button3);mButton4 = (Button) findViewById(R.id.button4);mButton5 = (Button) findViewById(R.id.button5);mButton6 = (Button) findViewById(R.id.button6);mButton7 = (Button) findViewById(R.id.button7);mButton8 = (Button) findViewById(R.id.button8); 你的事件监听会是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mButton1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 例子举得不怎么恰当，但是足以说明随着业务代码的不断扩大，这些看上去的”无脑操作“也会让我们广大coder变得愈加的不耐烦，而且会使得我们的类变得庞大而臃肿。 那么，接下来我们就通过注解的方式来搞一发~ 二、 注解的编码风格我们打算使用注解的方式实现 xml的配置 View的注入 点击事件的绑定 接下来就是具体实现逻辑 首先我们先定义一个Bind注解 12345678910111213141516package com.puke.annotationdemo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/18 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)public @interface Bind &#123; int value() default 0;&#125; 然后写Bind注解对应的注解处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.puke.annotationdemo;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author zijiao * @version 16/8/18 */public class BindHandler &#123; /** * 处理对Activity的注解 * * @param activity 目标Activity */ public static void handleBind(Activity activity) &#123; Class cls = activity.getClass(); handleSetContentView(activity); handleFindView(cls.getDeclaredFields(), activity); handleClickEvent(cls.getDeclaredMethods(), activity); &#125; //绑定xml布局 private static void handleSetContentView(Activity activity) &#123; Class&lt;?&gt; cls = activity.getClass(); if (cls.isAnnotationPresent(Bind.class)) &#123; //Activity中加入Bind注解时取出注解配置 Bind bind = cls.getAnnotation(Bind.class); int layout = bind.value(); if (layout != 0) &#123; activity.setContentView(layout); &#125; &#125; &#125; //View的注入 private static void handleFindView(Field[] declaredFields, Activity activity) &#123; if (declaredFields == null || declaredFields.length == 0) &#123; return; &#125; for (Field field : declaredFields) &#123; //找到被Bind注解且是View的所有属性 if (field.isAnnotationPresent(Bind.class) &amp;&amp; View.class.isAssignableFrom(field.getType())) &#123; Bind bind = field.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; View view = activity.findViewById(id); field.setAccessible(true); try &#123; //直接通过反射set进去 field.set(activity, view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //点击事件的绑定 private static void handleClickEvent(Method[] declaredMethods, final Activity activity) &#123; if (declaredMethods == null || declaredMethods.length == 0) &#123; return; &#125; for (final Method method : declaredMethods) &#123; //找到被Bind注解且无参的所有方法（注意这里限制无参是为了与下面调用method.invoke(activity)的无参保持一致） if (method.isAnnotationPresent(Bind.class) &amp;&amp; method.getParameterTypes().length == 0) &#123; Bind bind = method.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; activity.findViewById(id).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; method.invoke(activity); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125;&#125; 好了，到了这一步，我们的注解工作算是结束了，代码相对有点多，但这个是一劳永逸的。 接下来就是对注解的使用了 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bind(R.layout.activity_main)public class MainActivity extends Activity &#123; @Bind(R.id.username) private EditText mUsername; @Bind(R.id.submit) private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind(R.id.submit) public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; Run一下，完美运行~ 我们这里可以看到，使用注解之后 setContentView方法没了 findViewById方法没了 setOnClickListener方法没了 MainActivity整个类减肥了 所有的所有，都让注解处理器一手承包了。而我们要做的是什么，要做的是真正应该由coder做的事情，在对应的地方加上对应的注解配置就ok了。 然后我们可以回过头看一下Bind这个注解，细心的同学可能发现注解声明value()的时候理论上来讲不应该有一个default为0的默认值。原因很简单啊，因为就目前的使用场景来看，无论注入一个layout还是一个id都不会为0，那这里干嘛还要再写一个default 0呢，直接不要default可以限制业务方的使用，强约束业务方一旦使用注解就必须要在注解里面set一个值进来。这里我要说明一下，我们写注解就是为了方便使用，快速开发，既然要懒，我们就懒到家，干脆就让我们的注解处理器能在业务方没有在Bind中注入值的时候也能生效。 就是要实现下面这种效果: 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bindpublic class MainActivity extends Activity &#123; @Bind private EditText mUsername; @Bind private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; 这样一来，只需要几个全裸的注解一顿狂注之后，就完事了。后面这种的实现方式我这里就不写了，大致说一下思路，注解处理器要制定类名—layout，属性名—id，方法名—id，这样一套转换标准出来，然后注解处理器的处理逻辑是先看业务方有没有手动注入，没有手动注入的情况（也就是前面提到的default 0）下，注解处理器再按照这套标准利用反射来取出对应的R类的对应资源值，只要找到对应的资源值，就和手动注入处理结果的完全一样。 三、 一些问题每当一种事物出现时，只要不是太极端，总会有人拥护，也有人异议。单单站在coder的角度，这种注解的方式给我带来的好处是显而易见的，算是治愈代码密集恐惧症的偏方了。 但是值得深思的是，这里大量使用了反射，在Java中反射的性能问题总是尴尬的不要不要的。虽然jdk每次升级时基本上都在对反射进行优化，但是毕竟是反射，纯理论上讲，它确实没有直接的方法调用高效。 当然针对这个问题，我也有见过这样一种说法，假如我们对所谓”高效“的时间容忍度是1000t(t为一个时间粒度单位)，直接方法调用耗时是1t，反射是50 - 200t。也就是说，反射是耗性能，是不效率，但是这个也只是相对与直接方法调用而言的，而还远远没达到我们对性能指标的容忍值。 我曾经也在高效开发和反射性能消耗之间纠结很久，在这里就不去过多评价，仁者见仁，智者见智了~]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2016%2F08%2F29%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Java是门面向对象的语言，其中的每一个对象都有与之对应的的Class。只要一提到Class，自然就想到Java的反射机制，可见反射在Java中的重要性。 #####一、 Class的几种获取方式 1. 类名.class方式 1Class cls = User.class; 2. 对象.getClass()方式 1Class cls = user.getClass(); 3. Class.forName()方式 12//注意这里的参数是类的全限定名(即含有包名)Class cls = Class.forName("com.reflect.User"); 4. ClassLoader方式 1Class cls = classLoader.findClass("com.reflect.User"); 二、 通过反射创建对象1. 通过Class创建公有的无参构造方法 12Class&lt;User&gt; cls = User.class;User user = cls.newInstance(); 2.通过Constructor创建公有的无参构造方法 123Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getConstructor();User user = constructor.newInstance(); 3.通过Constructor创建私有的无参构造方法 12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor();//注意，此处使用暴力反射，反射中该方法经常被使用constructor.setAccessible(true);User user = constructor.newInstance(); 4.通过Constructor创建私有的含参构造方法 12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor(String.class, int.class);constructor.setAccessible(true);//注意，此处传递的参数类型和上面的String.class和int.class保持一致User user = constructor.newInstance("小莫", 3); 三、 通过反射读写对象属性12345public class User &#123; public static int age; public String name; private String sex;&#125; 1. 读写静态属性 123456Class&lt;User&gt; cls = User.class;Field ageField = cls.getField("age");//读取静态属性int age = (int) ageField.get(null);//设置静态属性ageField.set(null, 10); 2. 读写成员属性 123456Class&lt;User&gt; cls = User.class;Field nameField = cls.getField("name");//读取成员属性String name = (String) nameField.get(user);//设置成员属性nameField.set(user, "大白"); 3. 读写私有成员属性 123456Field sexField = cls.getDeclaredField("sex");sexField.setAccessible(true);//读取私有成员属性String sex = (String) sexField.get(user);//设置私有成员属性sexField.set(user, "大白"); 四、 通过反射调用对象方法12345678public class User &#123; public static void say(String name) &#123; System.out.println("My name is " + name); &#125; public int plus(int a, int b) &#123; return a + b; &#125;&#125; 1. 调用静态方法 123456Class&lt;User&gt; cls = User.class;//注意，这里第一个参数是指方法名，后面的参数是可变长参数，是目标方法的对应参数类型//若目标方法是无参的，则不填Method sayMethod = cls.getMethod("say", String.class);//静态方法不依赖对象实例，所以第一个参数是nullsayMethod.invoke(null, "胡巴"); 12后台输出: My name is 胡巴 2. 调用成员方法 1234567User user = new User();Class&lt;User&gt; cls = User.class;Method plusMethod = cls.getMethod("plus", int.class, int.class);//如果该方法是非public的，则要在invoke之前调用 plusMethod.setAccessible(true);//注意，由于该方法是成员方法，它的执行依赖于一个User实例，所以第一个参数是userint result = (int) plusMethod.invoke(user, 2, 7);System.out.println(result); 12后台输出：9 五、 反射的简单应用123456789101112131415161718 上面我们对于反射中一些常用的Api进行了基本的认识，接下来我们进入一个简单的实战练习，案例驱动，以加深对反射的认识。 场景：我们正在使用一个第三方的jar包，包含两个类User和Dog(见下)，而我们现在需求是，要调用一个User实例中dog的happy方法。public class User &#123; private Dog dog = new Dog();&#125;class Dog &#123; public void sleep() &#123; System.out.println(&quot;the dog went to bed.&quot;); &#125;&#125; 有以下难点： 1. 这两个类都是在jar包里面的，不能直接修改 2. 我们要有Dog类的权限，但是Dog这个类是package的 3. 我们要拿到User实例中的dog引用，但是dog属性是private的 4. 我们最终要调用的sleep的方法也是private的没有反射的话，估计我们只能想到两种办法了，要么基于class字节码进行修改，要么直接找需求方互相伤害去~废话不多说，接下来我们来看通过使用反射的方式，来KO这个需求 12345678910111213141516171819202122//1. 获取user对象对应的ClassClass&lt;User&gt; userCls = User.class;//2. 获取到改对象的dog属性Field dogField = userCls.getDeclaredField("dog");//3. 通过dogField属性获取user实例中对应的dog实例//注意,由于Dog类是package级别的,所以这里无法直接声明Dog,只能使用Object代替dogField.setAccessible(true);Object dog = dogField.get(user);//4. 获取dog对象对象的Class对象Class&lt;?&gt; dogCls = dog.getClass();//这里也可以使用这种方式//Class dogCls = Class.forName("com.groovy.reflect.Dog");//5. 获取到Dog的sleep方法Method sleepMethod = dogCls.getDeclaredMethod("sleep");//6. 调用sleep方法sleepMethod.setAccessible(true);sleepMethod.invoke(dog); 12后台输出：the dog went to bed.]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2016%2F08%2F29%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、 动态代理实现方式Java中的动态代理给我们提供一种动态生成类的方式，有很好的灵活性，这种技术一般会出现在一些第三方框架中，来降低接入方的使用成本。以下为常用的实现动态代理的几种方式： JDK自带的Proxy方式 优点：JDK亲儿子；无依赖；使用简单 缺点：代理类必须继承至少一个接口；无法继承已有父类 asm方式，基于class字节码的操作 优点：很底层的操作，性能高，对性能要求苛刻的建议使用 缺点：使用成本高，要熟悉JVM汇编指令 javassist方式，基于class字节码的操作 优点：Api简单，通熟易懂，使用成本低 缺点：性能相对偏低 cglib方式，这个是基于ASM的 ​优点：Api简单；高性能；高灵活性；支持继承父类；可以不用实现接口 缺点：这个真的很强大，个人感觉比JDK自带的要强大很多，一定要说的话只能说使用这个需要加jar包依赖 二、业务开发的尴尬开门见山，我们直接来看一个业务场景： 1234567891011121314151617181920212223package com.puke.net;/** * @author zijiao * @version 16/8/19 */public class User &#123; public String username; public String uId; public String sex; public String address; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", uId='" + uId + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 这里就是一个用户信息的Entity类，不解释了。 123456789101112131415161718192021222324252627282930package com.puke.net;import com.google.gson.Gson;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class VirtualHelper &#123; private static final Gson sGson = new Gson(); public static String request(String url, Map&lt;String, Object&gt; params) &#123; if (params != null) &#123; if ("123".equals(params.get("username")) &amp;&amp; "456".equals(params.get("password"))) &#123; User user = new User(); user.address = "杭州"; user.sex = "男"; user.uId = "Id"; user.username = "啊啊"; return sGson.toJson(user); &#125; &#125; return null; &#125;&#125; 这里我们模拟一个简单的网络请求。 当我们业务场景需要调用网络请求执行登录操作的时候，会这样写： 1234567891011121314151617181920212223242526package com.puke.net;import com.google.gson.Gson;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 那么，有什么问题呢。其实如果只是一个单单的login方法很难直观的反馈出来问题所在，很多时候我们为了去验证一个事物的合理性我们不妨去开始极端遐想一下这种情况：现在UserApi中又多了register方法，query方法，getToken方法，validate方法……甚至接下来一个UserApi已经满足不了我们了，我们开始有GoodsApi，OrderApi，MessageApi等等等等，试想一下N个Api的类，每个Api类都有N个类似于上面login的这种方法，而实际情况下我们request的入参还远远不止username，password两个这么简单。当我们业务场景扩大的时候，这些都是我们势必要面对的。这是一个问题，那能不能去以一种更优雅的方式去解决从而简化业务方的代码量并且降低使用成本呢。这里便引入了我们的动态代理~ 三、 动态代理的方式去解决我们的目标是状态是这样的：让业务方写写接口，加加注解配置，就可以直接使用 1. 先定义两个支持配置的注解123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface URL &#123; String value();&#125; 123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@interface Param &#123; String value();&#125; 这里不过多说明，就是两个可配字符串的注解。 2. 定义一套接口这一步，其实不是必需的。我们完全可以在动态代理中直接显式的调用VirtualHelper类，但既然抽象出来网络Api这块，那就干脆定义一套接口出来来解耦具体实现。 1234567891011121314151617package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public interface IRequest &#123; String url(); Map&lt;String, Object&gt; params(); Class&lt;?&gt; responseCls();&#125; 123456789101112131415161718192021222324252627282930313233343536package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class Request implements IRequest &#123; String url; Map&lt;String, Object&gt; params; Class&lt;?&gt; responseCls; public Request(String url, Map&lt;String, Object&gt; params, Class&lt;?&gt; responseCls) &#123; this.url = url; this.params = params; this.responseCls = responseCls; &#125; @Override public String url() &#123; return url; &#125; @Override public Map&lt;String, Object&gt; params() &#123; return params; &#125; @Override public Class&lt;?&gt; responseCls() &#123; return responseCls; &#125;&#125; 这是请求接口和实现类，粗略写下，比较简单 1234567891011package com.puke.net.proxy;/** * @author zijiao * @version 16/8/19 */public interface INetExecutor &#123; &lt;T&gt; T execute(IRequest request);&#125; 123456789101112131415161718192021package com.puke.net.proxy;import com.google.gson.Gson;import com.puke.net.VirtualHelper;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class DefaultNetExecutor implements INetExecutor &#123; private static final Gson sGson = new Gson(); @Override public &lt;T&gt; T execute(IRequest request) &#123; String response = VirtualHelper.request(request.url(), request.params()); return (T) sGson.fromJson(response, request.responseCls()); &#125;&#125; 这个是网络执行器已经默认的实现方式（使用上面的VirtualHelper），主要是抽象出接口可以让业务方自主定制真正的执行操作。 3. 动态代理器这个就直接上代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.puke.net.proxy;import android.text.TextUtils;import java.lang.annotation.Annotation;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class ApiGenerator &#123; private static final Map&lt;Class, Object&gt; sApiCache = new HashMap&lt;&gt;(); private static INetExecutor sNetExecutor; private static class Handler&lt;T&gt; implements InvocationHandler &#123; private Class&lt;T&gt; apiInterface; public Handler(Class&lt;T&gt; apiInterface) &#123; this.apiInterface = apiInterface; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; IRequest request = resolveRequest(method, args, apiInterface); if (sNetExecutor == null) &#123; sNetExecutor = defaultNetExecutor(); &#125; return sNetExecutor.execute(request); &#125; &#125; private static &lt;T&gt; IRequest resolveRequest(Method method, Object[] args, Class&lt;T&gt; apiInterface) &#123; StringBuilder urlBuilder = new StringBuilder(); Map&lt;String, Object&gt; params = null; if (apiInterface.isAnnotationPresent(URL.class)) &#123; String baseUrl = apiInterface.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(baseUrl)) &#123; urlBuilder.append(baseUrl); &#125; &#125; if (method.isAnnotationPresent(URL.class)) &#123; String subUrl = method.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(subUrl)) &#123; urlBuilder.append(subUrl); &#125; &#125; int index = 0; for (Annotation[] annotations : method.getParameterAnnotations()) &#123; for (Annotation annotation : annotations) &#123; if (annotation instanceof Param) &#123; String key = ((Param) annotation).value(); if (!TextUtils.isEmpty(key)) &#123; if (params == null) &#123; params = new HashMap&lt;&gt;(); &#125; params.put(key, args[index]); &#125; break; &#125; &#125; index++; &#125; return new Request(urlBuilder.toString(), params, method.getReturnType()); &#125; private static INetExecutor defaultNetExecutor() &#123; return new DefaultNetExecutor(); &#125; public static &lt;T&gt; T generateApi(Class&lt;T&gt; apiInterface) &#123; if (apiInterface == null || !apiInterface.isInterface()) &#123; throw new RuntimeException("the apiInterface is null or isn`t interface."); &#125; synchronized (ApiGenerator.class) &#123; Object api = sApiCache.get(apiInterface); if (api == null) &#123; api = Proxy.newProxyInstance(apiInterface.getClassLoader(), new Class[]&#123;apiInterface&#125;, new Handler(apiInterface)); sApiCache.put(apiInterface, api); &#125; return (T) api; &#125; &#125; /** * 外部提供自定义执行器 * * @param netExecutor 网络执行器 */ public static void setNetExecutor(INetExecutor netExecutor) &#123; sNetExecutor = netExecutor; &#125;&#125; 到此，我们的动态代理的编码部分就结束了。我们可以看一下ApiGenerator这个类有个sApiCache的静态变量，他缓存了动态代理生成的对象，这里这样做还是很有必要的，防止重复创建Api的代理类造成额外的性能消耗。 4. 使用姿势业务方只需要按照我们约束的一套标准来写一个interface即可 1234567891011121314151617package com.puke.dynamicproxy;import com.puke.net.User;import com.puke.net.proxy.Param;import com.puke.net.proxy.URL;/** * @author zijiao * @version 16/8/19 */@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是业务方要写的接口，以及对应的一些注解配置。 接下来就可以直接使用LoginApi生成的具体实例了 1234567891011121314151617181920212223242526package com.puke.dynamicproxy;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Toast;import com.puke.net.User;import com.puke.net.proxy.ApiGenerator;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.login).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LoginApi loginApi = ApiGenerator.generateApi(LoginApi.class); User user = loginApi.login("123", "456"); Toast.makeText(MainActivity.this, user.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 由于此处模拟的网络请求，就不考虑主线程的进行这个操作了。 5. 使用对比这里我再贴一下两种使用前后的代码对比 123456789101112131415public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 这个是传统的Api方式下业务方要写的代码 12345@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是使用了动态代理之后业务方要写的代码 对比一下，明显能感觉到我们的代码精简了一大圈，看上去清晰明了~ 这里我们再回归到最近开始提到的问题，当业务逐渐扩大的时候，这两种模式下，无论是开发效率上还是代码精简度上根本不具有可比性。 四、 一些想法其实，基于动态代理我们还可以做很多事情，当某一类事物有一些共性，我们一直重复去写一堆“孪生”代码，不仅降低了我们的开发效率，还容易让我们产生一种思维定式，按照一个固有的模式去重复做一类事太容易固化我们的思维。不仅仅是动态代理，还有很多很多，开发本该是件轻松的事。工欲善其事，必先利其器。]]></content>
      <categories>
        <category>Develop</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
</search>
