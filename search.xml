<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自动化处理浏览器任务]]></title>
    <url>%2F2018%2F08%2F02%2FPython-Selenium%2F</url>
    <content type="text"><![CDATA[在日常工作当中，我们经常会和浏览器打交道，当然就可能会在浏览器上做一些重复、无脑的工作，这篇文章旨在对于这类问题出一个基于脚本的自动化解决方案。 Selenium库简要一句话概括，Selenium就是一个浏览器自动化测试框架。它支持包括IE、Chrome、Mozilla Firefox、Mozilla Suite在内的大多数主流浏览器。当然本文主要讲述的并不是关于它在自动化测试部分方面的运用，该部分在Selenium官网和网上各种Blog处均有很多也很详细的介绍，这里我们要说的是基于它的浏览器控制能力来演化出的另一个应用方向——自动化处理任务。 快速开始安装首先，在拥有python环境的os中命令行执行 pip install selenium 来安装Selenium库。（Mac os直接安装时可能会出现权限问题，此时尝试命令前面添加sudo，还不行时则需要尝试通过创建Python沙盒的方式来安装。） 其次，下载一个跟自己浏览器和版本对应的webdriver，然后将该文件配置在环境变量下。比如Chrome浏览器的webdriver就在这里下载。这里需要注意下载的webdriver版本不是越新越好，而是要下载跟自己浏览器版本匹配的。我首次安装时在这里踩过坑。具体查看匹配的方式是打开Chrome =&gt; 点击菜单Chrome =&gt; 关于Google Chrome，在该界面能看到自己浏览器的版本。然后进入在上面的下载页面找到与自己版本匹配的webdriver，具体比较的地方在此处 最后测试下是否配置正确，终端打开一个新窗口，输入命令chromedriver -v执行，如果配置没问题，此时便能看到webdriver的版本号，如下 123➜ ~ cd Documents/libs ➜ libs chromedriver -vChromeDriver 2.38.552518 (183d19265345f54ce39cbb94cf81ba5f15905011) 快速开始环境配置完成之后，来通过一个简单的百度搜索然后进入Selenium官网的Demo来看看Selenium的实际运行效果。新建client_selenium.py脚本文件，然后执行添加如下代码 1234567891011121314151617181920# coding=utf-8from selenium import webdriverimport time# 创建一个webdriver实例, 并打开百度页面browser = webdriver.Chrome()browser.get('https://www.baidu.com')# 找到搜索框组件, 并输入关键词"selenium"element_input = browser.find_element_by_id('kw')element_input.send_keys('selenium')# 找到搜索按钮, 并指定点击操作element_search = browser.find_element_by_xpath('//*[@value="百度一下"]')element_search.click()time.sleep(1)# 找到selenium官网的链接, 并点击进入element_target = browser.find_element_by_xpath('//*[contains(text(), "Web Browser Automation")]')element_target.click() 执行该python文件后，脚本会通过webdriver来去驱动浏览器进行一系列的打开、输入、点击等操作，如下图 常用apiSelenium库具有很丰富的api，但对于只需要写任务处理脚本而言，我们只需要了解一些比较核心高频的api，下面列举出常用的api 操作 api 说明 输入 send_keys(&#39;Hello&#39;) 输入文本 点击 click() 执行点击 查找元素 find_element_by_id() 根据ID进查找 查找元素 find_element_by_name() 根据name查找 查找元素 find_element_by_tag_name() 根据标签查找 查找元素 find_element_by_link_text() 根据链接文本查找 查找元素 find_element_by_class_name() 根据class名查找 查找元素 find_elements_by_css_selector() 根据css选择器查找 查找元素 find_elements_by_xpath() 根据xpath语法查找 可以看到，其中Selenium库包含丰富的元素查找相关的api，找到对应的元素是对该元素进行操作的基础，所以能否快速、便捷、精准的查找到目标元素至关重要。 这里着重强调一下find_elements_by_xpath函数，该函数是基于XPath语法规范进行查找元素的，该规范在爬虫开发、浏览器脚本、XML配置查找等方面的使用时相当高频的。实际上，上面的所有查找方法都可以通过该方法进行替代。 应用（涉及到公司业务保密，这里就不展示出来了） 拓展用原生Selenium的Api写过一个应用之后，虽然感觉它的Api不算复杂，但对于我们只想写一个自动化脚本而言，还是不够简练，毕竟它的Api的初衷是给为了做浏览器自动化测试使用的。 而我想要的效果就是，更简单，尽可能一行代码执行一个Action，而一个自动化脚本就是包含多个Action的一个Robot。于是就基于Selenium库封装了很薄的一层selenium-robot库，然后发布到pypi仓库里。 以最上面的访问Selenium官网的那个Demo来比较，用selenium-robot来实现出来的是这样的 12345678910from selenium_robot.actions import *from selenium_robot import Robotbrowser = webdriver.Chrome()Robot( Open('https://www.baidu.com'), Input('wd', 'selenium'), Click('百度一下'), Click('Web Browser Automation')).setup(browser) 代码量减少了一半多，最终运行的效果是一样的，对于自动化脚本的开发可以更加便捷、高效。 总结总的来说，基于上面的Selenium库，我们还能开发出很多自动化脚本： 可以把工作中重复的配置操作通过该方式完成，这种工作在运营人员面前应该不少，比如要配置N个活动，每天配置广告Banner，配置公告信息等； 可以结合某些xml解析库进行爬虫开发，而且这种爬虫是基于浏览器驱动进行数据爬取的，而非像Scrapy等这种基于纯数据角度的爬虫框架一样。人家是模拟浏览器请求，Selenium模拟都不模拟了，自己干脆直接驱动浏览器，这样几乎不会被反爬工具监测到； 脑洞再大一些，甚至还可以写网页版游戏的外挂等等。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python拼接微信好友头像大图]]></title>
    <url>%2F2018%2F07%2F31%2FPython-Wechat-Avatar%2F</url>
    <content type="text"><![CDATA[基于itchat库来获取微信好友头像并执行拼接操作，对微信上文字化好友列表数据进行可视化展示。 获取好友头像123456789101112131415161718192021def save_avatar(folder): """ 保存微信好友头像 :param folder: 保存的文件夹 """ itchat.auto_login(hotReload=True) users = itchat.get_friends() or [] print('%d friends found.' % len(users)) if not os.path.exists(folder): os.makedirs(folder) index = 1 for i, user in enumerate(users): nickname = user.RemarkName username = user.UserName file_path = os.path.join(folder, '%03d_%s.png' % (i, nickname)) if not os.path.isfile(file_path): # 不重复下载 avatar = itchat.get_head_img(username) with open(file_path, 'w') as f: f.write(avatar) print('Download %d: %s' % (index, file_path)) index += 1 这里只需要传入一个保存头像的文件夹即可，运行itchat.auto_login(hotReload=True)后会弹出微信扫码界面让你授权微信登录，以便接下来的好友数据获取。 在图片下载时，我添加了一个防止重复下载的判断，以免多次运行时每次都要重新进行头像的下载。 取出待拼接头像1234567891011def get_image_files(folder, filters=None): """ 取出待拼接头像 :param folder: 目标文件夹 :param filters: 需要过滤的图片 :return: 头像路径 """ filters = filters or [] filenames = [os.path.join(folder, sub) for sub in os.listdir(folder) if sub.endswith('.png') and not filters.__contains__(sub)] return filenames 这里单独写个方法是为了把过滤的逻辑封装进来，以便于去掉指定的微信好友的头像（比如纯色的头像在拼接之后的大图看上去很明显，非强迫症可忽略）。 计算拼接的排列123456789101112def calculate_align_way(image_num, force_align=False): """ 计算图片排版对齐方式 :param image_num: 图片数量 :return: (rowls, columns) """ actual_value = image_num ** 0.5 suggest_value = int(actual_value) if actual_value == suggest_value or force_align: return suggest_value, suggest_value else: return suggest_value, suggest_value + 1 因为需要知道最终拼接图片的行列数，所有这里单独定义一个计算方法。算法就是直接对图片总数开根号，取出的结果如果正好是整数，就直接返回该结果。如果不是整数（大多数情况都如此），则根据参数force_align来决定是否强制进行正好全部铺满的显示。如果设为True，能强制铺满，但会有部分好友未显示完全；反之则是相对的情况。后面发现拼接图片最后一行有很多黑色空位时，只需要更改该参数为True即可。 拼接1234567891011121314151617181920212223242526272829def join_images(image_files, rows, cols, width, height, save_file=None): """ 拼接操作 :param image_files: 待拼接的图片 :param rows: 行数 :param cols: 列数 :param width: 每张小头像的宽度 :param height: 每张小头像的高度 :param save_file: 拼接好图片的保存路径 """ canvas = np.ones((height * rows, width * cols, 3), np.uint8) for row in range(rows): for col in range(cols): index = row * cols + col if index &gt;= len(image_files): break file_path = image_files[index] im = Image.open(file_path) im = im.resize((width, height)) im_data = np.array(im) if len(im_data.shape) == 2: im_data = np.expand_dims(im_data, -1) x = col * width y = row * height canvas[y: y + height, x: x + width, :] = im_data image = Image.fromarray(canvas) image.show() if save_file: image.save(save_file) 拼接图片调用的是科学计算包numpy和图片库PIL，主要就是对ndarray进行操作。 最终将上面的步骤全部串联起来，执行如下主函数，便得到上面的拼接图片。 1234567891011121314FOLDER = 'avatars'if __name__ == '__main__': # 保存所有好友头像 save_avatar(FOLDER) # 取到准备拼接的头像 image_files = get_image_files(FOLDER) # 计算拼接的行列 rows, columns = calculate_align_way(len(image_files), force_align=True) # 执行拼接操作 join_images(image_files, rows, columns, 64, 64, 'result.png') Github源码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>itchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio高频Postfix总结]]></title>
    <url>%2F2018%2F07%2F31%2FAndroid-Studio-Postfix%2F</url>
    <content type="text"><![CDATA[var声明 null判空 notnull判非空 nn判非空 for遍历 fori带索引的遍历 not取反 if条件判断 cast强转 return返回值]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>Android Sutdio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java、Groovy、JavaScript、Python各语言对比]]></title>
    <url>%2F2018%2F07%2F30%2FProgram-Language-Contrast%2F</url>
    <content type="text"><![CDATA[Get startJava12345public class Client &#123; public static void main(String[] args)&#123; System.out.println("Hello, world."); &#125;&#125; Groovy123static void main(String[] args) &#123; println('Hello, world.')&#125; JavaScript1console.log("Hello, world."); Python12if __name__ == '__main__': print('Hello, world.') 字符串Java12345678910111213public class Client &#123; public static void main(String[] args) &#123; String a = "Hello"; // 截取 (Hel) System.out.println(a.substring(0, 3)); // 转化 (123) System.out.println(String.valueOf(123)); // 拼接 (Hello, world.) System.out.println(a + ", world."); // 格式化 (Hello, I am 10.) System.out.println(String.format("%s, I am %d.", a, 10)); &#125;&#125; Groovy1234567891011static void main(String[] args) &#123; def a = "Hello" // 截取 (Hel) println(a[0..3]) // 转化 (123) println(String.valueOf(123)); // 拼接 (Hello, world.) println(a + ", world.") // 格式化 (Hello, I am 10.) println("$&#123;a&#125;, I am $&#123;10&#125;.")&#125; JavaScript123456789let a = "Hello";// 截取 (Hel)console.log(a.substr(0, 3));// 转化 (123)console.log(String(123));// 拼接 (Hello, world.)console.log(a + ", world.");// 格式化 (Hello, I am 10.)console.log(`$&#123;a&#125;, I am $&#123;10&#125;.`); Python12345678910111213# coding=utf-8if __name__ == '__main__': a = "Hello" # 截取 (Hel) print(a[0:3]) # 转化 (123) print(str(123)) # 拼接 (Hello, world.) print(a + ", world.") # 格式化 (Hello, I am 10.) print("%s, I am %d." % (a, 10)) # or print("&#123;&#125;, I am &#123;&#125;.".format(a, 10)) 时间格式化Java12345678910111213public class Client &#123; public static void main(String[] args) &#123; // 当前时间戳 (1532955845305) long currentTimeMillis = System.currentTimeMillis(); System.out.println(currentTimeMillis); // 格式化处理 (2018-07-30 21:04:05) DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); LocalDateTime now = LocalDateTime.now(); String format = formatter.format(now); System.out.println(format); &#125;&#125; Groovy1234567891011static void main(String[] args) &#123; // 当前时间戳 (1532956684952) def currentTimeMillis = System.currentTimeMillis() println(currentTimeMillis) // 格式化处理 (2018-07-30 21:18:05) def formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss") def now = LocalDateTime.now() def format = formatter.format(now) println(format)&#125; JavaScript12345678910111213141516171819202122// 当前时间戳 (1532956509000)let currentTimeMillis = Date.parse(new Date());console.log(currentTimeMillis);// 格式化处理 (2018-07-30 21:15:09)Date.prototype.Format = function (fmt) &#123; let o = &#123; "M+": this.getMonth() + 1, // 月 "d+": this.getDate(), // 日 "h+": this.getHours(), // 时 "m+": this.getMinutes(), // 分 "s+": this.getSeconds(), // 秒 "q+": Math.floor((this.getMonth() + 3) / 3), // 季度 "S": this.getMilliseconds() // 毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (let k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;;let format = new Date().Format("yyyy-MM-dd hh:mm:ss");console.log(format); Python12345678910import timeimport datetimeif __name__ == '__main__': # 当前时间戳 (1532957083) print(int(round(time.time()))) # 格式化处理 (2018-07-30 21:24:43) format = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') print(format) 函数Java12345678910public class Client &#123; public static void main(String[] args) &#123; int result = plus(1, 2); System.out.println(result); &#125; private static int plus(int a, int b) &#123; return a + b; &#125;&#125; Groovy123456789static void main(String[] args) &#123; def result = plus 1, 2 println(result)&#125;static def plus(int a, int b) &#123; // 最后一行return可省略 return a + b&#125; JavaScript123456function plus(a, b) &#123; return a + b;&#125;let result = plus(1, 2);console.log(result); Python123456def plus(a=0, b=0): return a + bif __name__ == '__main__': result = plus(1, 2) print(result) 列表Java1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; // 新建 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加 list.add("a"); list.add("b"); list.add("c"); // 移除 list.remove("c"); // 查询 String first = list.get(0); // 拼接 List&lt;String&gt; added = Arrays.asList("m", "n"); list.addAll(added); // 遍历 for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125; Groovy12345678910111213141516171819202122232425static void main(String[] args) &#123; // 新建 &amp; 添加 def list = ['a', 'b'] // 添加 list &lt;&lt; 'c' // 移除 list -= 'c' // 查询 def first = list[0] // 拼接 def added = ['m', 'n'] list += added // [a, b, m, n] println(list) // 遍历 for (i in list) &#123; println(i) &#125; // or list.each &#123; println(it) &#125;&#125; JavaScript123456789101112131415161718192021// 新建 &amp; 添加let list = ['a', 'b'];// 添加list.push('c');// 移除list = list.filter(s =&gt; s !== 'c');// 查询let first = list[0];// 拼接let added = ['m', 'n'];list = [...list, ...added];// or// list = list.concat(added);// [a, b, m, n]console.log(list);// 遍历for (let i = 0; i &lt; list.length; i++) &#123; console.log(list[i]);&#125; Python1234567891011121314151617181920212223242526# coding=utf-8if __name__ == '__main__': # 新建 &amp; 添加 list = ['a', 'b'] # 添加 list.append('c') # 移除 del list[2] # or # list.remove('c') print(list) # 查询 first = list[0] # 拼接 added = ['m', 'n'] list = list + added # or # list = list.extend(added) # [a, b, m, n] print(list) # 遍历 for i in list: print(i) 字典Java12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; // 新建 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 添加 map.put("a", 1); map.put("b", 2); map.put("c", 3); // 移除 map.remove("c"); // 查询 Integer first = map.get("a"); // 拼接 Map&lt;String, Integer&gt; added = new HashMap&lt;&gt;(); added.put("m", 4); added.put("n", 5); map.putAll(added); // 遍历 map.forEach((key, value) -&gt; &#123; System.out.println(key + ": " + value); &#125;); &#125;&#125; Groovy12345678910111213141516171819static void main(String[] args) &#123; // 新建 &amp; 添加 def map = ['a': 1, 'b': 2] // 添加 map['c'] = 3 // 移除 map.remove('c') // 查询 Integer first = map.get('a') // 拼接 def added = ['m': 4, 'n': 5] map += added // 遍历 map.each &#123; println(it.key + ': ' + it.value) &#125;&#125; JavaScript1234567891011121314151617181920// 新建 &amp; 添加let map = &#123;'a': 1, 'b': 2&#125;;// 添加map['c'] = 3;// 移除delete map['c'];// 查询let first = map['a'];// 拼接let added = &#123;'m': 4, 'n': 5&#125;;map = &#123;...map, ...added&#125;;console.log(map);// 遍历for (let key in map) &#123; if (map.hasOwnProperty(key)) &#123; console.log(`$&#123;key&#125;: $&#123;map[key]&#125;`); &#125;&#125; Python1234567891011121314151617181920# coding=utf-8if __name__ == '__main__': # 新建 &amp; 添加 map = &#123;'a': 1, 'b': 2&#125; # 添加 map['c'] = 3 # 移除 del map['c'] # 查询 first = map['a'] # 拼接 added = &#123;'m': 4, 'n': 5&#125; map.update(added) print(map) # 遍历 for key, value in map.items(): print('%s: %s' % (key, value)) 文件Java1234567public class Client &#123; public static void main(String[] args) throws IOException &#123; File file = new File("/Users/puke/Desktop/TODO.md"); String content = Files.readFile(file); System.out.println(content); &#125;&#125; Groovy12345static void main(String[] args) &#123; def file = new File("/Users/puke/Desktop/TODO.md") def content = file.text println(content)&#125; Python1234if __name__ == '__main__': with open("/Users/puke/Desktop/TODO.md") as f: content = f.read() print(content) 网络Java12345678public class Client &#123; public static void main(String[] args) throws IOException &#123; String url = "https://www.baidu.com"; InputStream inputStream = new URL(url).openStream(); String content = Files.readFile(inputStream); System.out.println(content); &#125;&#125; Groovy12345static void main(String[] args) &#123; def url = "https://www.baidu.com" def content = new URL(url).openStream().text println(content)&#125; Python1234567import urllib2if __name__ == '__main__': url = "https://www.baidu.com" response = urllib2.urlopen(url) content = response.read() print(content)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>Groovy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio之Debug（二）：自定义Debug变量视图]]></title>
    <url>%2F2018%2F06%2F06%2FAndroid-Studio-Debug-2%2F</url>
    <content type="text"><![CDATA[我们在使用IntelliJ的IDE进行Debug时，去查看一个未重写toString方法的对象需要展开当前的视图层级才能看到里面的属性，而通过自定义变量视图的方式可以直接查看，很大程度上提高Debug的效率。 引出问题我们在Debug查看变量时通常会遇到这种情况 此时我想查看Goods对象里面的具体属性值，需要点击左边的展开按钮才能查看里面具体的属性值，不能直接进行查看。更糟糕的是当Goods对象在List容器中时，我们如果想快速查找到当前List里元素的某一项（或几项）属性时，就会出现在下面的情况，我们只能逐一元素进行展开操作才能查看到元素对应的信息。 重写toString及其局限性上述问题的一般解决方式是重写该类的toString方法，然后重新运行Porject，再次Debug时便可以看到变量的视图会自动变为toString方法的返回值，如下 这样便能无需展开直接显示Goods类的成员变量了，但该方式有几个缺点 添加Goods的toString方法之后需要重新运行 如果Goods是被依赖的jar这种已经被编译的只读类，则无法更改 对于Goods中包含大量属性（比如20+个）的情况下，无法全部显示完，所以就无法根据自己的需求决定查看具体哪些属性值 自定义变量视图IDE提供给我们一种自定义变量视图的方式，专门用来解决上面的问题并弥补了toString方法的不足。这里会有个变量解析器的概念，它用来控制当前变量的显示值（即debug时显示在该变量后面的内容，下称”变量视图”）。 首先Debug状态下右击变量，选择Customize Data Views项 接下来在Customize Data Views弹窗的Tab中选择Java Type Renderers项，如下 点击+来添加一个自定义的变量解析器 自定义一个变量解析器，主要需要添加的是名称、解析类型和解析方式三部分。 名称：该解析器的标识名称 解析类型：表示当前的解析器只对哪种类型的类进行解析 解析方式：此处是核心部分，可以写一个Java表达式，也可以写一段代码，这里的返回值就是该变量视图 我们可以在IDE中添加多个变量解析器，通过控制它的开启、禁用、顺序、适用类等来控制当前变量的显示情况，下面进行一次完整的操作流程演示 通过自定义变量解析器的好处是不需要重新运行整个Project；而且还可以在Debug期间动态切换变量视图，比如 查看name属性时：&quot;name: &quot; + getName() 查看type属性时：&quot;type: &quot; + getType() 查看title属性时：&quot;title: &quot; + getTitle() …… 再进一步抽象看了官网的自定义Debug变量视图这部分介绍后，感觉着实对于Debug很实用，通过自实现的方式使得开发者能够动态化控制变量视图。 自定义变量解析器的方式已经能够解决开篇提到的问题，但我更希望能通过它来找到控制变量视图的通法，即写一个通用的变量解析器而不是每debug一种类型的变量就单独添加一个解析器。接下来要做的事情很清楚了，就是添加一个能够将对象实例序列化成字符串的方法即可。最先想到的是通过Json进行转化，但Json一般依赖三方包，而我们想让Debug功能能够跟IDE是统一基准线的，所以尽可能选择使用Jdk自带的api。 于是考虑到了反射，对于一般通用的变量视图，我们可以直接通过反射取到每个属性名，然后结合当前实例来获取属性值，直接在上面的解析类型中指定为java.lang.Object以支持所有类型变量的解析，解析方式中添加下面的代码 12345678910111213141516171819202122if (((Object) this) instanceof String || ((Object) this) instanceof Number || ((Object) this) instanceof Class) &#123; return ((Object) this);&#125;StringBuilder sb = new StringBuilder("&#123;");Class&lt;?&gt; cls = ((Object) this).getClass();java.lang.reflect.Field[] fields = cls.getDeclaredFields();if (fields != null) &#123; int size = fields.length; for (java.lang.reflect.Field field : fields) &#123; field.setAccessible(true); Object value = field.get((Object) this); sb.append(field.getName()) .append("=") .append(String.valueOf(value)); if (--size &gt; 0) &#123; sb.append(", "); &#125; &#125;&#125;return sb.append("&#125;").toString(); 添加完毕之后，会发现此时我们的IDE在Debug时异常强大，所有类型的变量视图均自动转化成key-value形式的字符串，再也不用为了Debug变量而重写toString方法。看下Debug的效果 这里的User和Goods类均没有重写toString方法，但都能通过上面添加的通用解析器来进行变量视图解析。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio之Debug（一）：运行期代码植入]]></title>
    <url>%2F2018%2F06%2F05%2FAndroid-Studio-Debug-1%2F</url>
    <content type="text"><![CDATA[我们开发中经常使用IDE的Debug功能，使用最频繁的就是断点查看变量内容，这篇文章主要是介绍在Debug时很常用的一些功能，如Debug变量更新、动态代码植入等。 背景看下面一段代码 1234567@Data@ToString@AllArgsConstructorpublic class User &#123; private String name; private String sex;&#125; 123456789101112public class Client &#123; private static final String[] NAMES = &#123;"美队", "浩克", "黑寡妇"&#125;; private static final List&lt;User&gt; USERS = Arrays.stream(NAMES) .map(name -&gt; new User(name, "男")) .collect(Collectors.toList()); public static void main(String[] args) &#123; for (User user : USERS) &#123; System.out.println(user); &#125; &#125;&#125; 我们直接运行这段代码，得到的输出如下 123Client.User(name=美队, sex=男)Client.User(name=浩克, sex=男)Client.User(name=黑寡妇, sex=男) 接下来都会围绕这段代码进行说明 普通断点开发过程中普通断点在Debug过程中使用的算是最频繁的，只要在代码处添加该类型的断点，在Debug模式下，一旦代码执行到改行，程序将进入挂起状态，此时我们能查看到当前的运行状态，如图 条件断点当添加断点的方法会被多次执行到，而我们只希望程序在特定的一些特定的地方（如只有在当前的user是黑寡妇时）断下来，此时我们可以借助条件断点，如下 注意看一下Condition部分，此处需要返回一个boolean类型的值，该值就是为了告诉程序当执行到该行代码时是否进行断点，true表示进行断点，false反之。上面只需要对黑寡妇进行断点，所以添加的Condition是&quot;黑寡妇&quot;.equals(user.getName())。 改变变量状态有时需要对断点时的变量赋值操作，已更改此时变量的值，这时可以使用Set Value方式，如下 除了Set Value，还可以通过估值器进行改变值状态，如下 条件断点 + 代码植入改变变量状态能够动态地设置变量值，条件断点可以控制断点是能在此处挂起，那将两者结合就能达到在程序不挂起的情况下进行动态代码植入的效果。 Condition里插入的代码如下 12345if ("黑寡妇".equals(user.getName())) &#123; user.setSex("女");&#125;// 此处返回false为了告诉IDE在该断点出不对程序执行挂起操作return false; 这就相当于提供了运行期代码的动态植入功能，而且可以通过Enable/Disable断点的状态来进行开启/关闭该部分动态代码是否执行。我们可以通过这种方式添加任何希望添加的代码，比如在每个user对象print之前添加自定一段print 应用场景Debug期间动态植入的应用场景其实有很多的，对应Android端，有时候只需要改变一个变量，添加一行代码就需要重新run整个Project，需要花费整个compile和install的时间才能看出改动之后的效果，如果当前这次更改无效的话，甚至需要再次修改再次运行，而通过debug方式，可以直接对其进行操作。对于后端每次改动之后的重新部署也一样（不考虑动态部署的情况）。 以Android场景为例，如下的代码，接收一个imageUrl参数并加载出来 123456789101112131415161718192021public class ImageActivity extends Activity &#123; private static final String KEY_CONTENT = "imageUrl"; public static void open(Context context, String content) &#123; Intent intent = new Intent(context, ImageActivity.class); intent.putExtra(KEY_CONTENT, content); context.startActivity(intent); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView imageView = findViewById(R.id.image); // 取出参数内容 String imageUrl = getIntent().getStringExtra(KEY_CONTENT); Glide.with(this).load(imageUrl).into(imageView); &#125;&#125; 未植入代码之前，跳转到当前页面是这样的 此时如果需要动态改变当前的imageUrl参数，可以进行Debug模式，并通过动态代码植入方式进行imageUrl变量的重赋值，如下 添加植入的复制代码之后，进入Debug模式，然后重新进入该页面，显示的图片便替换为修改后的了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras框架总结]]></title>
    <url>%2F2017%2F11%2F08%2FKeras-Doc-Summary%2F</url>
    <content type="text"><![CDATA[Keras是基于Tensorflow、Theano以及CNTK为后端的高层神经网络API，通过函数式编程风格进行封装，API面向开发者非常友好，能够把idea迅速转换为结果。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Keras</tag>
        <tag>Python</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RNN自动作诗源码剖析]]></title>
    <url>%2F2017%2F10%2F12%2FTensorflow-Poems-Source%2F</url>
    <content type="text"><![CDATA[Tensorflow Poems是一款基于RNN（循环神经网络）的 Github开源项目，它能通过学习大量古诗文和歌词然后能够自己来模仿创造诗文和歌词。 简介就项目本身，其意义不是很大，权当娱乐就行。这里的重点是解读如何从最原始的诗句，到数据的读取，到数据预处理，到模型的构建，再到最后的训练和使用流程。 数据源通过上面的github地址可以下载到项目源码，其中古诗文的数据集是dataset/data/poems.txt，打开可以看到如下的内容（篇幅限制，只显示了前两行诗句）。 123首春:寒随穷律变，春逐鸟声开。初风飘带柳，晚雪间花梅。碧林青旧竹，绿沼翠新苔。芝田初雁去，绮树巧莺来。初晴落景:晚霞聊自怡，初晴弥可喜。日晃百花色，风动千林翠。池鱼跃不同，园鸟声还异。寄言博通者，知予物外志。... 整体的格式还是蛮清晰的，每行就代表一首诗，每首诗由标题和内容两部分组成，中间以冒号分割。 预处理代码位于poems.py文件的process_peoms方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def process_poems(file_name): # 诗集 poems = [] with open(file_name, "r") as f: for line in f.readlines(): try: # 取出title和content title, content = line.strip().split(':') # 移除content中的所有空格 content = content.replace(' ', '') # 过滤掉包含特殊字符的诗 if '_' in content or '(' in content or '（' in content or '《' in content or '[' in content or \ start_token in content or end_token in content: continue # 过滤掉过长或过短的诗句 if len(content) &lt; 5 or len(content) &gt; 79: continue # 将内容加上前缀(G)和后缀(E) content = start_token + content + end_token # 处理后的添加到诗集中 poems.append(content) # 处理过程出错则跳过, 忽略掉 except ValueError as e: pass # 按诗的字数排序 poems = sorted(poems, key=lambda l: len(line)) # 统计每个字出现次数 all_words = [] for poem in poems: all_words += [word for word in poem] # 计算每个字对应的频率 counter = collections.Counter(all_words) # 按照文字频率进行倒序排列 count_pairs = sorted(counter.items(), key=lambda x: -x[1]) # 取出排列后的字集, 赋值给words words, _ = zip(*count_pairs) # 将words最后追加一位空格 words = words[:len(words)] + (' ',) # 每个字映射为一个数字ID word_int_map = dict(zip(words, range(len(words)))) # 将诗句中的每个word都注意映射为对应的数字ID poems_vector = [list(map(lambda word: word_int_map.get(word, len(words)), poem)) for poem in poems] # 依次返回数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 return poems_vector, word_int_map, words 模型代码位于model.py的rnn_model方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def rnn_model(model, input_data, output_data, vocab_size, rnn_size=128, num_layers=2, batch_size=64, learning_rate=0.01): """ 构造rnn的序列模型 :param model: model class :param input_data: 输入数据占位符 :param output_data: 输出数据占位符 :param vocab_size: words的总长度 :param rnn_size: rnn的units数 :param num_layers: rnn中cell的层数 :param batch_size: 每个batch的样本数量 :param learning_rate: 学习率 :return: 模型状态集 """ # 声明模型状态集, 由于模型需要返回多个相关值, 故以map集合的形式向外部返回 end_points = &#123;&#125; # 选择rnn的具体cell类型, 提供了rnn、gru、lstm三种 if model == 'rnn': cell_fun = tf.contrib.rnn.BasicRNNCell elif model == 'gru': cell_fun = tf.contrib.rnn.GRUCell elif model == 'lstm': cell_fun = tf.contrib.rnn.BasicLSTMCell # 构造具体的cell cell = cell_fun(rnn_size, state_is_tuple=True) # 将单层的cell变为更深的cell, 以表征更复杂的关联关系 cell = tf.contrib.rnn.MultiRNNCell([cell] * num_layers, state_is_tuple=True) # 初始化cell的状态 if output_data is not None: # 训练时batch容量为batch_size initial_state = cell.zero_state(batch_size, tf.float32) else: # 使用时batch容量为1 initial_state = cell.zero_state(1, tf.float32) # tensorflow对于lookup_embedding的操作只能再cpu上进行 with tf.device("/cpu:0"): # 构造(vocab_size + 1, run_size)的Tensor embedding = tf.get_variable('embedding', initializer=tf.random_uniform( [vocab_size + 1, rnn_size], -1.0, 1.0)) # embedding_lookup函数 # output = embedding_lookup(embedding, ids): 将ids里的element替换为embedding中对应element位的值 # 即: embedding: [[1, 2], [3, 4], [5, 6]] ids: [1, 2] 则outputs: [[3, 4], [5, 6]] # 类比one_hot, 只是这里是x_hot # embedding: (3, 2) ids: (10, ) outputs: (10, 2) # 处理之后的shape为(batch_size, n_steps, rnn_size) inputs = tf.nn.embedding_lookup(embedding, input_data) # (batch_size, n_steps, rnn_size) =&gt; (batch_size, n_steps, rnn_size) outputs, last_state = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state) # (batch_size, n_steps, rnn_size) =&gt; (batch_size x n_steps, rnn_size) output = tf.reshape(outputs, [-1, rnn_size]) # (batch_size x n_steps, rnn_size) =&gt; (batch_size x n_steps, vocab_size + 1) weights = tf.Variable(tf.truncated_normal([rnn_size, vocab_size + 1])) bias = tf.Variable(tf.zeros(shape=[vocab_size + 1])) logits = tf.nn.bias_add(tf.matmul(output, weights), bias=bias) # [?, vocab_size+1] if output_data is not None: # output_data must be one-hot encode labels = tf.one_hot(tf.reshape(output_data, [-1]), depth=vocab_size + 1) # should be [?, vocab_size+1] loss = tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits) # loss shape should be [?, vocab_size+1] total_loss = tf.reduce_mean(loss) train_op = tf.train.AdamOptimizer(learning_rate).minimize(total_loss) end_points['initial_state'] = initial_state end_points['output'] = output end_points['train_op'] = train_op end_points['total_loss'] = total_loss end_points['loss'] = loss end_points['last_state'] = last_state else: prediction = tf.nn.softmax(logits) end_points['initial_state'] = initial_state end_points['last_state'] = last_state end_points['prediction'] = prediction return end_points 训练获取数据batch的代码位于poem.py的generate_batch方法 123456789101112131415161718192021222324252627282930def generate_batch(batch_size, poems_vec, word_to_int): # 每次取batch_size首诗进行训练 n_chunk = len(poems_vec) // batch_size x_batches = [] y_batches = [] for i in range(n_chunk): # 求得每个batch中start和end的索引值 start_index = i * batch_size end_index = start_index + batch_size # 取出batch的数据 batches = poems_vec[start_index:end_index] # 找到这个batch的所有poem中最长的poem的长度 length = max(map(len, batches)) # 填充一个这么大小的空batch，空的地方放空格对应的index标号 x_data = np.full((batch_size, length), word_to_int[' '], np.int32) for row in range(batch_size): # 每一行就是一首诗，在原本的长度上把诗还原上去 x_data[row, :len(batches[row])] = batches[row] y_data = np.copy(x_data) # y的话就是x向左边也就是前面移动一个 y_data[:, :-1] = x_data[:, 1:] """ x_data y_data [6,2,4,6,9] [2,4,6,9,9] [1,4,2,8,5] [4,2,8,5,5] """ x_batches.append(x_data) y_batches.append(y_data) return x_batches, y_batches 训练代码位于tang_poems.py的run_training方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def run_training(): # 检测模型参数文件夹及父文件夹, 不存在则新建 if not os.path.exists(os.path.dirname(FLAGS.checkpoints_dir)): os.mkdir(os.path.dirname(FLAGS.checkpoints_dir)) if not os.path.exists(FLAGS.checkpoints_dir): os.mkdir(FLAGS.checkpoints_dir) # 读取诗集文件 # 依次得到数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 poems_vector, word_to_int, vocabularies = process_poems(FLAGS.file_path) # 按照batch读取输入和输出数据 batches_inputs, batches_outputs = generate_batch(FLAGS.batch_size, poems_vector, word_to_int) # 声明输入、输出的占位符 input_data = tf.placeholder(tf.int32, [FLAGS.batch_size, None]) output_targets = tf.placeholder(tf.int32, [FLAGS.batch_size, None]) # 通过rnn模型得到结果状态集 end_points = rnn_model(model='lstm', input_data=input_data, output_data=output_targets, vocab_size=len(vocabularies), rnn_size=128, num_layers=2, batch_size=64, learning_rate=FLAGS.learning_rate) # 初始化saver和session saver = tf.train.Saver(tf.global_variables()) init_op = tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()) with tf.Session() as sess: sess.run(init_op) start_epoch = 0 # 加载上次的模型参数(如果有) checkpoint = tf.train.latest_checkpoint(FLAGS.checkpoints_dir) if checkpoint: saver.restore(sess, checkpoint) print("[INFO] restore from the checkpoint &#123;0&#125;".format(checkpoint)) # 如果有模型参数, 则取出对应的epoch, 训练从该epoch开始训练 start_epoch += int(checkpoint.split('-')[-1]) # 开始训练 print('[INFO] start training...') try: for epoch in range(start_epoch, FLAGS.epochs): n = 0 # 计算一个epoch需要多少次batch训练完, 有余数则忽略掉末尾部分 n_chunk = len(poems_vector) // FLAGS.batch_size for batch in range(n_chunk): # 训练并计算loss # batches_inputs[n]: 第n个batch的输入数据 # batches_outputs[n]: 第n个batch的输出数据 loss, _, _ = sess.run([ end_points['total_loss'], end_points['last_state'], end_points['train_op'] ], feed_dict=&#123; input_data: batches_inputs[n], output_targets: batches_outputs[n] &#125;) n += 1 print('[INFO] Epoch: %d , batch: %d , training loss: %.6f' % (epoch, batch, loss)) # 每训练6个epoch进行一次模型保存 if epoch % 6 == 0: saver.save(sess, os.path.join(FLAGS.checkpoints_dir, FLAGS.model_prefix), global_step=epoch) except KeyboardInterrupt: # 用户手动退出时, 尝试保存模型参数 print('[INFO] Interrupt manually, try saving checkpoint for now...') saver.save(sess, os.path.join(FLAGS.checkpoints_dir, FLAGS.model_prefix), global_step=epoch) print('[INFO] Last epoch were saved, next time will start from epoch &#123;&#125;.'.format(epoch)) 使用取词代码位于tang_poems.py的to_word方法 12345678910111213def to_word(predict, vocabs): # 取词逻辑 # 将predict累加求和 t = np.cumsum(predict) # 求出预测可能性的总和 s = np.sum(predict) # 返回将0~s的随机值插值到t中的索引值 # 由于predict各维度对应的词向量是按照训练数据集的频率进行排序的 # 故P(x|predict[i]均等时) &gt; P(x + δ), 即达到了权衡优先取前者和高概率词向量的目的 sample = int(np.searchsorted(t, np.random.rand(1) * s)) if sample &gt;= len(vocabs): sample = len(vocabs) - 1 return vocabs[sample] 作诗代码位于tang_peoms.py的gen_poem方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def gen_poem(begin_word): # 根据首个汉字作诗 # 作诗时, batch_size设为1 batch_size = 1 print('[INFO] loading corpus from %s' % FLAGS.file_path) # 读取诗集文件 # 依次得到数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 poems_vector, word_int_map, vocabularies = process_poems(FLAGS.file_path) # 声明输入的占位符 input_data = tf.placeholder(tf.int32, [batch_size, None]) # 通过rnn模型得到结果状态集 end_points = rnn_model(model='lstm', input_data=input_data, output_data=None, vocab_size=len(vocabularies), rnn_size=128, num_layers=2, batch_size=64, learning_rate=FLAGS.learning_rate) # 初始化saver和session saver = tf.train.Saver(tf.global_variables()) init_op = tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()) with tf.Session() as sess: sess.run(init_op) # 加载上次的模型参数 checkpoint = tf.train.latest_checkpoint(FLAGS.checkpoints_dir) # 注: 无模型参数时, 该步直接crash, 强制有训练好的模型参数 saver.restore(sess, checkpoint) # 取出诗文前缀(G)对应的索引值所谓初始输入 x = np.array([list(map(word_int_map.get, start_token))]) # 得出预测值和rnn的当前状态 [predict, last_state] = sess.run([end_points['prediction'], end_points['last_state']],feed_dict=&#123;input_data: x&#125;) if begin_word: # 用户输入值赋值给word word = begin_word else: # 若未输入, 则取初始预测值的词向量 word = to_word(predict, vocabularies) # 初始化作诗结果变量 poem = '' # 未到结束符时, 一直预测下一个词 while word != end_token: # 没预测一个则追加到结果上 poem += word # 初始化输入为[[0]] x = np.zeros((1, 1)) # 赋值为当前word对应的索引值 x[0, 0] = word_int_map[word] # 根据当前词和当前的上下文状态(last_state)进行预测 # 返回的结果是预测值和最新的上下文状态 [predict, last_state] = sess.run([end_points['prediction'], end_points['last_state']], feed_dict=&#123; input_data: x, end_points['initial_state']: last_state &#125;) # 根据预测值得出词向量 word = to_word(predict, vocabularies) return poem]]></content>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Tensorflow</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《西瓜书》]]></title>
    <url>%2F2017%2F09%2F02%2FWatermelon-Book%2F</url>
    <content type="text"><![CDATA[机器学习理论基础书，涵盖大部分机器学习的常用算法，相对于《机器学习实战》而言，这本书更偏向于理论推导，很多细节部分讲得更加详细。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>思维导图</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sklearn之线性回归]]></title>
    <url>%2F2017%2F09%2F01%2FSklearn-Linear-Regression%2F</url>
    <content type="text"><![CDATA[线性回归模型，主要用作对于连续数值型数据进行预测。为了展现线性回归技术在二维空间的几何表现，这个例子只使用了糖尿病数据集中的第一个特征。下图尝试找到一条使得数据集中各点到直线距离平方和最小的直线。 Source Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# coding=utf-8# Code source: Jaques Grobler# License: BSD 3 clauseimport matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelfrom sklearn.metrics import mean_squared_error, r2_score# 加载糖尿病数据集diabetes = datasets.load_diabetes()# 只选取一个特征diabetes_X = diabetes.data[:, np.newaxis, 2]# 将数据分割为训练集、测试集diabetes_X_train = diabetes_X[:-20]diabetes_X_test = diabetes_X[-20:]# 将目标标量分割为训练集、测试集diabetes_y_train = diabetes.target[:-20]diabetes_y_test = diabetes.target[-20:]# 创建线性回归对象regr = linear_model.LinearRegression()# 使用训练集训练模型regr.fit(diabetes_X_train, diabetes_y_train)# 使用测试集数据进行预测diabetes_y_pred = regr.predict(diabetes_X_test)# 回归系数print('Coefficients: \n', regr.coef_)# 均方误差print("Mean squared error: %.2f" % mean_squared_error(diabetes_y_test, diabetes_y_pred))# 方差分数: 1代表完美预测print('Variance score: %.2f' % r2_score(diabetes_y_test, diabetes_y_pred))# 将测试集数据及预测结果进行绘图输出plt.scatter(diabetes_X_test, diabetes_y_test, color='black')plt.plot(diabetes_X_test, diabetes_y_pred, color='blue', linewidth=3)plt.xticks(())plt.yticks(())plt.show() 输出结果:1234Coefficients: [ 938.23786125]Mean squared error: 2548.07Variance score: 0.47]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Titanic缺失数据处理]]></title>
    <url>%2F2017%2F08%2F03%2FTitanic-Fill-Data%2F</url>
    <content type="text"><![CDATA[Kaggle的比赛入门，通过机器学习模型对泰坦尼克号上幸存情况进行预测，这里主要针对预测前的特征工程处理，对缺失数据进行分析和补全。 加载数据加载csv文件数据 12345678def load_data(path): import csv as csv reader = csv.reader(open(path, 'rb')) header = reader.next() data = [] for line in reader: data.append(line) return header, np.array(data) 测试代码 12train_header, train_data = load_data(TRAIN_PATH)print train_header Output: 1['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked'] 检查缺失数据遍历每一行，记下空字符串元素所在的位置 12345678910def check_empty(header, data): empty = &#123;&#125; for row, line in enumerate(data): for column, value in enumerate(line): if value == '': feature = header[column] if not empty.__contains__(feature): empty[feature] = [] empty[feature].append(line[0]) return empty 测试代码 1234train_header, train_data = load_data(TRAIN_PATH)empty = check_empty(train_header, train_data)for key, value in empty.items(): print '%s: %d' % (key, len(value)) Output: 123Age: 177Cabin: 687Embarked: 2 可以看到训练数据中Age特征有177条缺失数据，另外两个以此类推。 上面是训练集中缺失数据的特征，而我们要得到还有测试集的缺失信息，所以写一个merge函数，将训练集和测试集合并起来（由于现在是缺失值分析阶段，所以不区分训练集和测试集，接下来会一直沿用合并后的数据），然后再检查缺失信息。 12345678910def merge_data(train_data, test_data): # 删除训练集中第二列的幸存信息，以保持数据格式统一 train_without_survive = np.delete(train_data, 1, axis=1) return np.vstack([train_without_survive, test_data])train_header, train_data = load_data(TRAIN_PATH)test_header, test_data = load_data(TEST_PATH)merged = merge_data(train_data, test_data)for key, value in check_empty(test_header, merged).items(): print '%s: %d' % (key, len(value)) Output： 1234Fare: 1Age: 263Cabin: 1014Embarked: 2 于是能够得到所有缺失的特征，分别是Fare、Age、Cabin、Embarked，接下来开始对缺失项一一进行分析、补全。 缺失数据分析Fare表明乘客的票价，有1个缺失值，我们首先看一下该数据的范围，均值，均方差这些信息 12345fare = merged[:, test_header.index('Fare')]fare_with_data = [float(f) for f in fare if f != '']print 'Range: %.2f - %.2f' % (min(fare_with_data), max(fare_with_data))print 'Mean: %.2f' % np.mean(fare_with_data)print 'Mean variance: %.2f' % np.sqrt(np.var(fare_with_data)) Output: 123Range: 0.00 - 512.33Mean: 33.30Mean variance: 51.74 通过这三项数据（以下简称RMM）我们能对票价信息有个大致的了解，范围在0 - 512.33波动，均值是33.3而均方差只有51.74，这表明大多数票价都是偏低的（也能从一定程度上分析出乘客的经济状况，这里就不继续延伸了）。 RMM信息获取很方便，但是不便于直观、确切的观察数据的分布情况，这时考虑通过matplot画出票价的密度分布图。 123import matplotlib.pyplot as pltplt.hist(fare_with_data, alpha=.7)plt.show() 分布图如下 从图中可以很直观的看出绝大部分数据都是部分在50以下的，鉴于这种情况，我们很直观的选择是把均值作为补全值。 1print np.mean(fare_with_data) Output: 133.2954792813 这时33.2954792813便做为Fare补全值了。 为了确保万一，我们要查出该条数据索引 12empty = check_empty(test_header, merged)print empty['Fare'] Output: 1['1044'] 接下来我们根据PassengerId找到该条数据 11044,3,"Storey, Mr. Thomas",male,60.5,0,0,3701,,,S 对比着特征名来分析数据 1PassengerId,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked 可以逐一分析，我们发现Pclass对应N等票，可能会影响到票价Fare特征，因此我们要取出所有跟该名乘客相同Pclass（从数据可以看出是3）的票价分布。 1234fare = merged[:, [test_header.index('Fare'), test_header.index('Pclass')]]fare_with_pclass_3 = [float(f) for f, pclass in fare if f != '' and pclass == '3']plt.hist(fare_with_pclass_3, alpha=.7)plt.show() 分布图如下 对比和上一张图的区别，我们能更加确切的了解到，三等票的票价没有高于70的，因此如果按照上面的结论直接把所有数据的票价均值作为补全值，在一定程度上会使得补全值的误差变大，取而代之的是用Pclass为3的乘客的票价均值作为补全值（这里还是有一定的优化空间，我们可以分析Pclass为3的乘客中的年龄、家属情况、船舱等对票价的影响，这里就不继续展开了）。 有了上面的分析，我们就可以重新计算补全值 1print np.mean(fare_with_pclass_3) Output: 113.3028887006 和上面输出的33.3还是有一定差距的 经过上面的一系列的分析，可以写出Fare特征的补全逻辑 12345678910111213141516def compute_fare_data(all_data, pclass, fare_index, pclass_index): fare_pclass = all_data[:, [fare_index, pclass_index]] fare_with_pclass = [float(f) for f, c in fare_pclass if f != '' and c == pclass] return np.mean(fare_with_pclass)def fill_data_fare(all_data, need_fill_data, header): fare_index = header.index('Fare') pclass_index = header.index('Pclass') fill_cache = &#123;&#125; for f in need_fill_data: if f[fare_index] == '': pclass = f[pclass_index] if not fill_cache.__contains__(pclass): fill_cache[pclass] = compute_fare_data(all_data, pclass, fare_index, pclass_index) f[fare_index] = fill_cache[pclass] 此时我们的主函数应该是这样子 12345train_header, train_data = load_data(TRAIN_PATH)test_header, test_data = load_data(TEST_PATH)merged = merge_data(train_data, test_data)fill_data_fare(merged, train_data, train_header)fill_data_fare(merged, test_data, test_header) Age表明乘客年龄，有263个缺失值，同上，我们先看一下该特征的RMM信息 12345age = merged[:, test_header.index('Age')]age_with_data = [float(f) for f in age if f != '']print 'Range: %.2f - %.2f' % (min(age_with_data), max(age_with_data))print 'Mean: %.2f' % np.mean(age_with_data)print 'Mean variance: %.2f' % np.sqrt(np.var(age_with_data)) Output: 123Range: 0.17 - 80.00Mean: 29.88Mean variance: 14.41 均值29.9，均方差14.4，可见整体年龄层都分布在青壮年阶段，接下来直接看看密度分布图 从该图中我们只能观察到老人（50岁以上）和小孩（16岁以下）占比较小，年龄大多集中在17-40左右，我们必须试图在数据中寻找更好的估值标准。 我们尝试寻找Age与Pclass的关系，先来画出分布图 1234567891011age_pclass = merged[:, [test_header.index('Age'), test_header.index('Pclass')]]# 过滤掉Age为空的数据age_pclass_with_data = [[int(float(a)), int(p)] for a, p in age_pclass if a != '']age_pclass_with_data = np.array(age_pclass_with_data)x = age_pclass_with_data[:, 0]y = age_pclass_with_data[:, 1]plt.scatter(x, y, alpha=.7)plt.xlabel('Age')plt.ylabel('Pclass')plt.title('Pclass &amp; Age')plt.show() 分布图如下 从上图上中可以知道很难直接根据Pclass估值出Age的值。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android上运行手写数字识别模型]]></title>
    <url>%2F2017%2F08%2F02%2FRun-Mnist-On-Android%2F</url>
    <content type="text"><![CDATA[Github源码请移步本文底部。 模型导出pb文件首先我们需要在我们的python代码中保存训练好的模型，save_path参数就传递**.pb，这里导出文件留给接下来使用 1234def save_model_and_params(session, save_path): out_graph_def = tf.graph_util.convert_variables_to_constants(session, session.graph_def, ["output"]) with tf.gfile.FastGFile(save_path, 'wb') as file: file.write(out_graph_def.SerializeToString()) Android中通过JNI调用Tensorflow与Android整合整合部分就直接按照Android端运行Tensorflow中的步骤来就行了。 封装输出数据解析逻辑在手写数字识别模型中的输出是一个size为10的列表，列表元素的索引值对应输出的结果，列表元素对应输出的概率，例如输出是[0.2, 0.7, 0.01……]，即表示有0.2的概率是0，0.7的概率是1，0.01的概率是2…… 因此我们需要在输出中对数据按照概率进行降序排列，以便让结果一目了然。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author zijiao * @version 17/8/2 */public class MnistData &#123; private final List&lt;Item&gt; items = new ArrayList&lt;&gt;(10); public MnistData(float[] data) &#123; for (int i = 0; i &lt; data.length; i++) &#123; items.add(new Item(data[i], i)); &#125; Collections.sort(items); &#125; public String top(int topSize) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; topSize; i++) &#123; Item item = items.get(i); builder.append(item.index) .append(": ") .append(String.format("%.1f%%", item.value * 100)) .append("\n"); &#125; return builder.toString(); &#125; public String output() &#123; return String.valueOf(items.get(0).index); &#125; @Override public String toString() &#123; return output(); &#125; @SuppressWarnings("NullableProblems") private static class Item implements Comparable&lt;Item&gt; &#123; final float value; final float index; private Item(float value, float index) &#123; this.value = value; this.index = index; &#125; @Override public int compareTo(Item o) &#123; return value &lt; o.value ? 1 : -1; &#125; &#125;&#125; 这时我们就能通过MnistData类的top方法得到概率最大的几个结果分别是什么。 构建数字分类器这里通过TensorFlowInferenceInterface来调用模型，注释写得很清楚，值得注意的一点是，input和output的名称要和模型中的变量名称保持一致。 1234567891011121314151617181920212223242526272829303132/** * @author zijiao * @version 17/8/2 */public class MnistClassifier &#123; private final TensorFlowInferenceInterface inference; public MnistClassifier(AssetManager assetManager) &#123; inference = new TensorFlowInferenceInterface(); // 加载模型图 inference.initializeTensorFlow(assetManager, TF.MODEL); // 模型使用阶段, 不需要进行dropout处理, 所以keep_prob直接为1.0 inference.fillNodeFloat(TF.KEEP_PROB_NAME, new int[]&#123;1&#125;, new float[]&#123;1.0f&#125;); &#125; public MnistData inference(float[] input) &#123; if (input == null || input.length != 28 * 28) &#123; throw new RuntimeException("Input data is error."); &#125; // 填入Input数据 inference.fillNodeFloat(TF.INPUT_NAME, TF.INPUT_TYPE, input); // 运行结果, 类似Python中的sess.run([outputs]) inference.runInference(new String[]&#123;TF.OUTPUT_NAME&#125;); float[] output = new float[10]; // 取出结果集中我们需要的 inference.readNodeFloat(TF.OUTPUT_NAME, output); // 将输出结果交给MnistData处理 return new MnistData(output); &#125;&#125; 添加画板模型处理的逻辑已经写完了，接下来就是如何得到输入源了。由于是手写数字识别，所以接下来就要写画板类。这里只贴出关键代码部分（完整代码可以看本文底部的Github地址）。 手指滑动屏幕时画出手指滑动的轨迹 123456789101112131415161718192021@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(path, paint);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; float x = event.getX(); float y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: path.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: path.lineTo(x, y); break; &#125; invalidate(); return true;&#125; 向外部提供读取画布数据的方法 1234567891011121314151617181920212223242526272829303132public float[] fetchData(int width, int height) &#123; float[] data = new float[height * width]; try &#123; setDrawingCacheEnabled(true); setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_LOW); Bitmap cache = getDrawingCache(); fillInputData(cache, data, width, height); &#125; finally &#123; setDrawingCacheEnabled(false); &#125; return data;&#125;private void fillInputData(Bitmap bm, float[] data, int newWidth, int newHeight) &#123; // 获得图片的宽高 int width = bm.getWidth(); int height = bm.getHeight(); // 计算缩放比例 float scaleWidth = ((float) newWidth) / width; float scaleHeight = ((float) newHeight) / height; // 取得想要缩放的matrix参数 Matrix matrix = new Matrix(); matrix.postScale(scaleWidth, scaleHeight); // 得到新的图片 Bitmap newbm = Bitmap.createBitmap(bm, 0, 0, width, height, matrix, true); for (int y = 0; y &lt; newHeight; y++) &#123; for (int x = 0; x &lt; newWidth; x++) &#123; int pixel = newbm.getPixel(x, y); data[newWidth * y + x] = pixel == 0xffffffff ? 0 : 1; &#125; &#125;&#125; 运行测试布局代码就直接省略了，我们只需要在点击识别的时候，调用下面这段的识别逻辑即可。 123456789// 识别public void onInference(View view) &#123; if (canvasView.isEmpty()) &#123; resultPanel.setText("画板为空"); return; &#125; MnistData result = classifier.inference(canvasView.fetchData(28, 28)); resultPanel.setText(result.top(3));&#125; 最后附上运行效果图 这里是该项目的Github源码]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Tensorflow</tag>
        <tag>Mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android端运行Tensorflow]]></title>
    <url>%2F2017%2F08%2F02%2FTensorflow-On-Android%2F</url>
    <content type="text"><![CDATA[将Tensorflow训练好的模型部署在Android端，网上找到的很多资料要么过于复杂，要么就根本不能运行，于是记录下具体的整合步骤。 New Projectlocal.propertities文件中指定ndk目录1ndk.dir=/Users/zijiao/Library/Android/sdk/ndk-bundle 向src/main/jniLibs/[cpu]目录添加对应的libtensorflow_demo.so文件其中[cpu]包含arm64-v8a、armeabi-v7a、x86、x86_64修改build.gradle文件android闭包中添加1aaptOptions &#123; noCompress 'pb' &#125; android-defaultConfig闭包下添加（可选）123456ndk&#123; //生成的so名字 moduleName "tensorflow_demo" //输出指定三种abi体系结构下的so库。目前可有可无。 abiFilters "arm64-v8a", "armeabi-v7a", "x86_64", "x86" &#125; 将TensorFlowInferenceInterface.java 拷到src/main/java/org.tensorflow.contrib.android目录下注意加载so文件 123static &#123; System.loadLibrary("tensorflow_demo");&#125; 将Model文件和Label文件拷到src/main/assets目录下测试是否成功123456TensorFlowInferenceInterface inference = new TensorFlowInferenceInterface();String modelPath = "file:///android_asset/[.pb文件名]";int code = inference.initializeTensorFlow(getAssets(), modelPath);if (code == 0) &#123; // 初始化成功&#125; ​]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Machine Learning</tag>
        <tag>Tensorflow</tag>
        <tag>移动AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《机器学习实战》]]></title>
    <url>%2F2017%2F08%2F01%2FMachine-Learning-Inaction%2F</url>
    <content type="text"><![CDATA[用了一个多月的时间看完了这本书，在这段时间里穿插了不少事情，公司的业务开发经历了两次班车迭代，还有一周多的时间用来研究图像语义分割。由于本职的Android开发还是占用很大一部分精力和时间，所以看书只能抽一些时间碎片进行。 谈谈自己对该书的整体感觉，这本书作为ML的入门、科普书籍当然是不错的，整体的章节设定看上去一目了然。书中列出了很多ML的经典算法，同时也有对应的代码实现，这里要点赞的一点是对于算法的封装性和拓展性而言，该书做的还是蛮不错的，很多实现代码基本上是可以拿过来直接使用的。还有就是书中整体的连贯性写的很到位，A算法已经很实用了，但在某某方面还存在缺陷，而B算法会在兼容A算法精华部分的基础上还解决了对应的缺陷，于是很平滑的过渡到B算法的讲解部分，这样给读者一种前因后果的感觉，而非凭空冒出个B算法。 同时也有些我认为美中不足的地方，关于一些算法公式方面，讲着讲着就突然莫名来了一个公式，有的公式甚至没什么说明，直接就用上了。其实能够理解作为一本ML的书籍不适合在算法公式的推导上花费太多的篇幅，但也不至于简短的描述都没有，一下子看到一坨公式的时候真是一脸茫然。还有一点是，看该书还是需要一定的线代基础的，在回归的讲解部分如果没有线代基础基本上就是走马观花了。 之前也看过不少技术书籍，时间越久淡忘的就越多，所以这次打算把看过的部分都记下来，一方面加深自己的印象，另一方面也为了提高日后复习的效率。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>思维导图</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio代码块打标]]></title>
    <url>%2F2017%2F03%2F21%2FAndroid-Studio-Code-Block-Mark%2F</url>
    <content type="text"><![CDATA[Android Studio代码块打标，让我们迅速定位到代码逻辑块。当我们开发中写的某些类的代码量相对比较庞大时，就会遇到维护这个类变得困难的问题，抛开对于该类的设计层面的因素，只从代码量的角度来看这个问题。基于IntelliJ的IDE给我们提供了一种能够给我们的代码块进行归纳的标签（以下称为代码块打标），如下 123// &lt;editor-fold defaultstate="collapsed" desc="[A]"&gt;[B]// &lt;/editor-fold&gt; 其中，[A] 对应打标的描述语言，[B] 对应待打标代码块。 根据上述规则我们来对MainActivity进行打标操作，代码如下 123456789101112131415161718192021222324252627282930313233343536373839/** * @author zijiao * @version 17/3/21 */public class MainActivity extends Activity &#123; // &lt;editor-fold defaultstate="collapsed" desc="成员变量"&gt; private Button button; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="onCreate逻辑"&gt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); &#125; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="findView逻辑"&gt; private void initView() &#123; button = (Button) findViewById(R.id.button); &#125; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="点击事件处理逻辑"&gt; private void initListener() &#123; button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "Click button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; // &lt;/editor-fold&gt;&#125; 可以看到我们将各个代码块按照逻辑进行分类并添加对应的描述标签，当我们下次再打开该类时，查看或修改某部分代码就会一目了然（当代码庞大时，其优点将会尤为明显），参见下图 可以看到代码块打标是很方便，但是有一点不好，就是当我们需要给某一个代码块打标时我们总是要在代码块之前添加 1// &lt;editor-fold defaultstate="collapsed" desc="[A]"&gt; 然后在代码块之后添加 1// &lt;/editor-fold&gt; 这个步骤很繁琐，但好消息是我们可以结合AS提供给我们的LiveTempalte，将这个过程封装成一个打标模板，来看看具体操作 打开Android Studio，进入Preferences — Editor — Live Templates ，新建一个Live Template Abbreviation处填写Mark Code Block，Template text处填写 123// &lt;editor-fold defaultstate="collapsed" desc="$description$"&gt;$SELECTION$// &lt;/editor-fold&gt; 点击Define，勾选Java复选框 点击Apply 这个时候你的界面应该是这样，可以核对下 到这里，打标模板已经完成了，你可以随便找一个类进行测试，选中一个代码块，按下快捷键Command + Option + J（Windows系统可以在Preferences — Keymap 中搜索Surround with Live Template...对应的快捷键）来选择Mark Code Block模板，此时我们就可以快速进行代码块打标操作了，如下图]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>编程洁癖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Template]]></title>
    <url>%2F2017%2F03%2F10%2FAndroid-Studio-Template%2F</url>
    <content type="text"><![CDATA[本文为图片展示篇，展示业界对Android Studio Template的评价。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TemplateBuilder(中文版)]]></title>
    <url>%2F2017%2F03%2F06%2FTemplateBuilder%5BChinese%5D%2F</url>
    <content type="text"><![CDATA[将Android Studio Template的开发过程集成于Android Studio Plugin中，只需要一键就能将当前文件制作为Template。 Android Studio的模板包括以下三种，这里讲的是第三种Multi Template。在阅读本文之前，默认你是了解该模板的，知道为什么要使用它，如果不清楚它是什么，可以在网上查阅相关资料，当然也可以直接点击这里查看一下同行们对它的评价 Live Template：代码片段级别 File Template：单文件级别 Multi Template：多个文件级别（以下称 Android Studio Template） WHATTemplateBuilder是一款能够帮助我们快速生成Android Studio Template的AS插件，将通过逐个文件去配置模板的方式改进为通过插件来实现，对于简单的模板制作，只需要一键即可生成。 HOW安装打开Android Studio，Preferences – Plugins – Brown Repositories, 搜索TemplateBuilder 并下载，下载之后重启IDE即可使用。 使用动态图展示先直接贴上Gif的演示效果，分别对应模板的导出与导入 导出： 选择待导出的文件或文件夹，按下ALT + T，在弹出界面中更改模板名称（MVP Test）和描述后直接Finish，然后重启IDE； 导入： 选择一个包，按下Command + N键，输入模板分类名（默认为电脑用户名），选择MVP Test模板进行导入。 快速制作这里我们拿对一个MVP模板的抽取来举例，首先选中需要制作为模板的类文件（如果需要选中某个文件夹里的全部文件，可以直接选中该文件夹），然后按下启动改插件的快捷键ALT + T，便能看到如下界面 下面来说明一下该界面对应的内容 Template Category 对应模板的分类，对应选择导入模板时的模板分类，这里默认值是电脑的用户名。 Template Name 对应模板名称，对应选择导入模板时的模板名称，默认值是当前的Project名称。 Template Description 对应模板描述信息，对应导入模板时弹出的导入界面的文字描述，默认为空。 Template Folder 对应生成模板所存放的位置，如果是Mac操作系统则默认为/Applications/Android Studio.app/Contents/plugins/android/lib/templates， Windows系统的话由于差异比较大，就默认为空了，可以自行配置[Android Studio安装目录]/plugins/android/lib/templates（这里只需要配置一次即可，插件将自动保存该位置）。 Input data区域 （见下：配置模板变量） 如果你只是想简单抽取你写的这个模板，你只需要输入下Template Name和Template Description即可，当然如果你不想输入的话这也可以省略掉。接下来直接点击Finish，就能在IDE底部看到弹出如下图所示的提示，此时你已经制作成功，重启IDE即可使用该模板。 到这里，如果你了解Android Studio Template制作流程的话，你可能觉得相对于完全自己手动去做这样固然简单，但是灵活性上降低了不少。例如模板中有组价依赖关系的时候，你需要在build.gradle.ftl中去添加对应的依赖；导入模板之后你想自动打开某个文件时，你需要编辑recipe.xml.ftl；选择模板适用于哪个版本时，你需要编辑template.xml等等。如果你有这方面的需求，可以点击Next来代替Finish，点击之后你就能看到如下界面，在这里提供了所有你需要关注的配置文件的编辑，编辑完成直接点击OK开始自动生成。 配置模板变量在上面的界面中可以看到Input data区域，它对应着导入模板时的变量输入，如果你想增强模板的可配性将会用到它，它就对应着AS模板中template.xml的&lt;parameter /&gt;标签，也就是下面的每一个配置项。 关于Input data的使用，先解释下每个属性对应的含义 id 变量名，必须和模板中使用的变量名对应，必填 name 变量简介，必填 type 变量类型，string和boolean两种，通过下拉框选择，必填 default 变量对应的默认值，选填 help 添加该变量时的提示信息，选填 下面我举个例子，假设待导出的模板文件是UserActivity类，代码如下： 123456789101112public class UserActivity extends Activity &#123; private TextView mUserName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user); mUserName = (TextView) findViewById(R.id.user_name); &#125; &#125; 代码很简单，假设我们想让引入模板时mUserName属性名是可配的，并且在Activity中是否调用setContentView方法也是可配的，那我们就需要这样改写该类： 12345678910111213public class UserActivity extends Activity &#123; private TextView $&#123;textViewName&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &lt;#if setContentView&gt; setContentView(R.layout.activity_user); $&#123;textViewName&#125; = (TextView) findViewById(R.id.user_name); &lt;/#if&gt; &#125;&#125; 我们用到了textViewName和setContentView两个变量，所以当我们按下ALT + T时就要在对应的Input data区域点击Add来添加两个对应的变量。 Input data textViewName setContentView id textViewName setContentView type string boolean name TextView属性名 是否设置布局 default mUserName false help 输入TextView对应的属性名 勾选则设置布局文件，反之不设置 添加完模板变量后导出，重启IDE选择导入该模板，此时便能看到刚才配置的两个变量，你可以输入不同的值来验证模板的正确性。 添加模板依赖模板中需要添加gradle依赖时，点击Next在第二个页面中build.gradle.ftl添加如下所示对应的仓库和依赖即可。 123456789repositories &#123; // 如果仓库是jcenter()，则可省略 jcenter()&#125;dependencies &#123; compile 'io.reactivex.rxjava2:rxjava:2.0.6' compile 'io.reactivex.rxjava2:rxandroid:2.0.1'&#125; WHY如果你尝试过自己去制作一个Android Studio Template的话，相信你一定会为模板配置、更改文件名、添加可配参数等等繁琐的操作而烦恼，因为哪怕一个很简单的模板抽取都需要把这一系列流程全都走一遍，更改好几个配置文件。 说下我的个人感受，当我发现Android Studio Template时我顿时感觉有太多太多可以抽取出来的模板以供日后快速使用，但当我刚开始抽取几个模板的时候就已经被深深的恶心到了，因为这个过程真心很繁琐。记得当时还专门写groovy脚本来辅助进行这些模板的配置，但也还是需要向脚本里添加一些模板文件的入参信息，依然很麻烦。后来我决定将这个制作过程尽可能通过自动化来完成，当时考虑Gradle插件、Java GUI、AS Plugin等多种方式来完成模板制作，最终选择了快而方便的AS Plugin，插件的名称就是上面所提到的TemplateBuilder。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TemplateBuilder]]></title>
    <url>%2F2017%2F03%2F06%2FTemplateBuilder%2F</url>
    <content type="text"><![CDATA[中文版 Integrate the development process of the Android Studio Template into the Android Studio Plugin, only one-click will be able to make the current file as a Template. Statement Android Studio templates include the following three, here is the third Multi Template. Before reading this article, Acquiescence you know the template, know why to use it, if it is not clear what it is, you can check the relevant information online, of course, you can also click here to see the peer to its evaluation Live Template：Code snippet level File Template：Single file level Multi Template：Multiple file levels (hereinafter referred to as Android Studio Template) WHATTemplateBuilder is an AS plug-in that can help us to quickly generate Android Studio Template, through a file to configure the template to improve the way through the plug-in to achieve, for simple template production, only one button can be generated. HOWInstallOpen Android Studio, Preferences – Plugins – Brown Repositories, search TemplateBuilder and download, then restart the IDE and try. InstructionsGif effectFirst directly show the Gif presentation effect, respectively, corresponding to the template export and import Export: Select the file or folder to be exported, press ALT + T, in the pop-up interface to change the template name (MVP Test) and description, then click Finish, and then restart the IDE; Import: Select a package, press the Command + N key, enter the template category name (the default is the computer user name), select the MVP Test template to import. Detailed explanationHere we take an example of the extraction of an MVP template, first select the need to create a template for the template file (if you need to select a package below all the files, you can directly select the package), and then press the shortcut ALT + T to start the plug, you can see the following interface Here to explain the corresponding content of the interface Template Category Corresponding to the template classification, corresponding to select the template template when the import, where the default is the computer’s user name. Template Name Corresponding to the template name, corresponding to the template name when selecting the import template, the default is the current Project name. Template Description Corresponding to the template description information, corresponding to the template when the import interface pop-up description of the text, the default is empty. Template Folder Corresponding to the location generated by the template, if the Mac operating system is the default / Applications / Android Studio.app/Contents/plugins/android/lib/templates, Windows OS, because the difference is relatively large, the default is empty, you can Configure the [Android Studio installation directory] / plugins / android / lib / templates(here only need to configure once, the plugin will automatically save the location). Input data area If you want to enhance the compatibility of the template will use it, it corresponds to the AS template Template.xml tag, that is, each of the following configuration items. The whole UI interface is clear, if you just want to simply extract the template you write, you only need to enter the Template Name and Template Description can, of course, if you do not want to enter this can also be omitted. Then click Finish, you can see the bottom of the IDE pop-up as shown below the prompt, then you have been successful, restart the IDE to use the template. Here, if you understand the Android Studio Template production process, you may feel that compared to their own manual to do this is simple, but the flexibility to reduce a lot. For example, when there is a group dependency in the template, you need to add the corresponding dependencies in build.gradle.ftl. After importing the template, you will need to edit recipe.xml.ftl when you want to open a file automatically. In which version, you need to edit template.xml and so on. If you have this need, you can click Next to replace the Finish, click on the following you will be able to see the following interface, where you need to focus on all the configuration file editing, editing directly click OK to start automatically generated. WHYIf you try to make your own Android Studio Template, I believe you will be for the template configuration, change the file name, add the parameters can be complicated, and so cumbersome operation and worry, because even a very simple template extraction need to put this A series of processes all go again, change several configuration files. Say my personal feelings, when I found Android Studio Template I suddenly felt there are too many can be extracted out of the template for future rapid use, but when I first started to extract a few templates when it has been deep Disgusted, because this process is very tedious. Remember to also write groovy script to assist in the configuration of these templates, but still need to add some template to the script file entry information, still very troublesome. Later, I decided to make this process as much as possible through the automation to complete, then consider the Gradle plug-in, Java GUI, AS Plugin and other ways to complete the template production, the final choice of a quick and convenient AS Plugin, plug-in name is mentioned above To the TemplateBuilder.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件组]]></title>
    <url>%2F2016%2F10%2F16%2FAndroid-Studio-Template-For-File-Group%2F</url>
    <content type="text"><![CDATA[文件组模板是基于FreeMarker模板语言的一个功能很强大的Android开发模板，可以这样说，代码片段模板和文件模板是一种提高编码效率的工具，而文件组模板可以算是一种模板引擎。 效果图展示一图胜千言，先上图 已有工程中使用模板效果图 创建工程时使用模板 示例场景在进行Android开发时，我们经常会创建一个Demo工程，目的可能有很多种，可能是为了验证一个问题，可能是为了学习一个框架的使用，可能为了测试自己写的一个lib库等等。这个时候我们可能会创建一个Activity，然后再在xml写一些按钮，再在Activity里写该按钮的事件监听逻辑，也就是说为了执行一段代码我们要做这么多操作。为了简化这段重复操作，我这边写了一个DebugActivity类，然后支持我们只需要写个子类来继承它，然后像下面这样写几个方法即可，运行的时候会根据方法动态创建按钮，并在点击按钮时执行该方法的代码逻辑。 123public void _test() &#123; T("弹出Toast");&#125; 由于本文主要介绍模板相关的，所以该场景相关的具体代码技术细节就不多说了，有兴趣的可以看下，DebugActivity的代码，这里提出来只是为模板开发简单的做个铺垫。 模板位置Android Studio Template中有系统预设的一些模板，我们可以直接修改，也可以另行添加新的模板。打开Android Studio安装目录/Contents/plugins/android/lib/templates这个文件夹我们能看到下面的目录结构，这里便是AS中模板存放的位置。 我们接下来的工作也就在这里，保险起见我们在这里新建一个目录，我们自己写的模板都放在自己新建的目录里，例如我这里就创建了一个叫pk的目录。 模板规范在上面的基础上，我们可以直接打开/activies/EmptyActivity目录，如下图 我们可以看到上面红色区域便是Template的文件结构，大致说下各个文件（夹）的含义 globals.xml.ftl 模板中参数配置的地方（可选） recipe.xml.ftl 模板行为执行处，引入这个模板之后，接下来要做什么事情，就是它说的算（可选，但是不选就没有意义了，因为模板引入是要要行为驱动的） root 存放模板文件及引入资源的目录，模板文件可以是.xml、.java、.gradle等任何一个文本格式的文件，资源一般是我们引入的.png资源文件（可选，不选同上） template_blank_activity.png 引入模板时的引导图（可选） template.xml 面向模板引擎的配置文件（必选） 我们可以看到，真正核心的部分就是root、recipe.xml.ftl和template.xml，接下来这重点说明这三部分。 我们可以打开root目录，能够看到里面的文件除了图片资源文件都是以.ftl结尾的，而.ftl是标准的FreeMarker的文件。FreeMarker是类似于Velocity的一种模板框架，据说对于多文件处理时它具有更好的性能，大概也是Android Studio选择Velocity作为单文件模板，选择FreeMarker作为文件组模板的原因吧。有兴趣的可以去FreeMarker官网学习一下，它的自定义标签功能还是很强大的，个人感觉比Velocity的更加接地气。 接下来我们看一下recipe.xml.ftl 的内容，打开如下 1234567891011121314&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;#include "../common/recipe_manifest.xml.ftl" /&gt;&lt;#if generateLayout&gt; &lt;#include "../common/recipe_simple.xml.ftl" /&gt; &lt;open file="$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml" /&gt;&lt;/#if&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt;&lt;/recipe&gt; 这里以&lt;#开头的都是FreeMarker的语法，基本上比葫芦画瓢就能看明白，就不多说了。其实对于这个文件最重要的部分是下面四个标签 copy 就是简单的copy，把模板root目录下的某个文件copy到目标工程的某个目录下 instantiate 跟copy很类似，唯一多的一点功能就是并不只简单的走IO流进行copy，而是通过FreeMarker框架按照模板中的FreeMarker能识别的逻辑判断和数据引入来生成最终的目标文件 merge 目标项目中有了某文件，而我们还要想该文件合并一些我们的模板的部分时，就选用merge，例如我们添加一个Activity时需要mergeAndroidManifest.xml的配置。目前支持的merge格式有.xml和.gradle，但是对.gradle支持的不怎么好，不过不影响该模板的开发，对于这套模板引擎的开发者来说，这可能是最麻烦的部分了，但是对于我们使用者就不用考那么多了，直接使用吧 open 这个很简单，就是指定模板引入之后要IDE打开的文件 然后看下template.xml内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Empty Activity" minApi="7" minBuildApi="14" description="Creates a new empty activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity Name" type="string" constraints="class|unique|nonempty" suggest="$&#123;layoutToActivity(layoutName)&#125;" default="MainActivity" help="The name of the activity class to create" /&gt; &lt;parameter id="generateLayout" name="Generate Layout File" type="boolean" default="true" help="If true, a layout file will be generated" /&gt; &lt;parameter id="layoutName" name="Layout Name" type="string" constraints="layout|unique|nonempty" suggest="$&#123;activityToLayout(activityClass)&#125;" default="activity_main" visibility="generateLayout" help="The name of the layout to create for the activity" /&gt; &lt;parameter id="isLauncher" name="Launcher Activity" type="boolean" default="false" help="If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher" /&gt; &lt;parameter id="packageName" name="Package name" type="string" constraints="package" default="com.mycompany.myapp" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; 当我们进行模板引入时，AS会弹出一个如下图的UI界面，要我们来填入或选择一些数据，例如输入Activity的的名称，选择SDK的版本之类的。而这个界面就是根据由该文件而来的。 内容比较多，为减少篇幅我挑些重要的说 template标签 name 引入模板时的模板名称，就死根据他选择哪个模板的 description 弹出Dialog的标题，对应上去的区域1 category 表示该模板属于哪种分类，在引入的时候会有个分类的选择 parameter 每个该标签就对应Dialog界面的一个输入项 id 该参数的唯一标识符，也是我们在.ftl中引入的值，例如定义的id为username，引用时就是$username name 对应Dialog上面该输入项的名称 type 对应该参数的类型，Dialog就是根据这个来决定对应输入是选择框、输入框还是下拉框等等 constraints 对应该参数的约束，如果有多个要用|分割开 suggest 建议值，这个输入部分是由级联效应的，可能你改了A参数，B参数也会跟着改变，就是根据这个参数决定的 default 参数的默认值 visibility 可见性，要配置一个boolean类型的参数，一般指向另一个输入源 help 当焦点在某个输入源上面时，上图的区域3的就限制这儿的内容 操刀实战了解了模板规范之后，我们编写模板时就不会那么被动了，下面我们来自己动手编写文章开始部分展示的模板。 首先在刚才提到的自定义的模板下创建如下图所示的目录结构 DebugActivity root src app_package DebugActivity.java.ftl JumpActivity.java.ftl SimpleActivity.java.ftl AndroidManifest.xml.ftl globals.xml.ftl recipe.xml.ftl template.xml template_debug_activity.png 然后将下面的代码对应贴进去（图片部分随便找一张代替好了…） globals.xml.ftl 123456&lt;?xml version="1.0"?&gt;&lt;globals&gt; &lt;global id="resOut" value="$&#123;resDir&#125;" /&gt; &lt;global id="srcOut" value="$&#123;srcDir&#125;/$&#123;slashedPackageName(packageName)&#125;" /&gt; &lt;global id="relativePackage" value="&lt;#if relativePackage?has_content&gt;$&#123;relativePackage&#125;&lt;#else&gt;$&#123;packageName&#125;&lt;/#if&gt;" /&gt;&lt;/globals&gt; recipe.xml.ftl 123456789101112131415161718192021&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;instantiate from="root/src/app_package/DebugActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;#if addJumpActivity&gt; &lt;instantiate from="root/src/app_package/JumpActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/JumpActivity.java" /&gt; &lt;/#if&gt; &lt;merge from="root/AndroidManifest.xml.ftl" to="$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt;&lt;/recipe&gt; template.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Debug Activity" minApi="7" minBuildApi="14" description="创建一个Debug的Activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity名称" type="string" constraints="class|unique|nonempty" default="SetupActivity" help="创建Activity的名称" /&gt; &lt;parameter id="addExample" name="是否添加按钮使用示例" type="boolean" default="false" help="选择时会自动生成测试按钮；否则不生成" /&gt; &lt;parameter id="addJumpActivity" name="是否添加跳转Activity示例" type="boolean" default="false" help="选择时会自动生成跳转Activity相关逻辑；否则不生成" /&gt; &lt;parameter id="isLauncher" name="设为启动页面" type="boolean" default="true" help="选择时设置该页面为启动页面；否则不设" /&gt; &lt;parameter id="packageName" name="包名" type="string" constraints="package" default="com.mycompany.myapp" help="输入Application包名" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_debug_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; AndroidManifest.xml.ftl 123456789101112131415161718&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;application&gt; &lt;#if addJumpActivity&gt; &lt;activity android:name="$&#123;relativePackage&#125;.JumpActivity"/&gt; &lt;/#if&gt; &lt;activity android:name="$&#123;relativePackage&#125;.SetupActivity"&gt; &lt;#if !(isLibraryProject!false) &amp;&amp; isLauncher&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/#if&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; DebugActivity.java.ftl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package $&#123;packageName&#125;;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * Debug测试类,快速调试Demo工程&lt;hr /&gt; * 使用姿势:&lt;br /&gt; * 1. 新建一个子类继承该类&lt;br /&gt; * 2. 跳转Activity: 在子类配置&#123;@link Jump&#125;注解, 然后在注解中配置跳转Activity的类型&lt;br /&gt; * 3. 点击按钮触发方法: 在子类声明一个名称以"_"开头的方法(支持任意修饰符),最终生成按钮的文字便是改方法截去"_"&lt;br /&gt; * 4. 方法参数支持缺省参数和单个参数&lt;br /&gt; * 5. 如果是单个参数,参数类型必须是Button或Button的父类类型,当方法执行时,该参数会被赋值为该Buttom对象&lt;br /&gt; * https://github.com/puke3615/DebugActivity&lt;br /&gt; * &lt;p&gt; * * @author zijiao * @version 16/10/16 */public abstract class DebugActivity extends Activity &#123; protected static final String FIXED_PREFIX = "_"; private final String TAG = getClass().getName(); private final List&lt;ButtonItem&gt; buttonItems = new ArrayList&lt;&gt;(); protected LinearLayout linearLayout; protected Context context; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Jump &#123; Class&lt;? extends Activity&gt;[] value() default &#123;&#125;; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.context = this; ScrollView scrollView = new ScrollView(this); setContentView(scrollView); this.linearLayout = new LinearLayout(this); this.linearLayout.setOrientation(LinearLayout.VERTICAL); scrollView.addView(linearLayout); try &#123; resolveConfig(); createButton(); &#125; catch (Throwable e) &#123; error(e.getMessage()); &#125; &#125; private void createButton() &#123; for (ButtonItem buttonItem : buttonItems) &#123; linearLayout.addView(buildButton(buttonItem)); &#125; &#125; protected View buildButton(final ButtonItem buttonItem) &#123; final Button button = new Button(this); button.setText(buttonItem.name); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (buttonItem.target != null) &#123; to(buttonItem.target); &#125; else &#123; Method method = buttonItem.method; method.setAccessible(true); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); int paramSize = parameterTypes.length; switch (paramSize) &#123; case 0: try &#123; method.invoke(DebugActivity.this); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; case 1: if (parameterTypes[0].isAssignableFrom(Button.class)) &#123; try &#123; method.invoke(DebugActivity.this, button); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; &#125; default: error(method.getName() + "方法参数配置错误."); break; &#125; &#125; &#125; &#125;); return button; &#125; private void resolveConfig() &#123; Class&lt;?&gt; cls = getClass(); //读取跳转配置 if (cls.isAnnotationPresent(Jump.class)) &#123; Jump annotation = cls.getAnnotation(Jump.class); for (Class&lt;? extends Activity&gt; activityClass : annotation.value()) &#123; buttonItems.add(buildJumpActivityItem(activityClass)); &#125; &#125; //读取方法 for (Method method : cls.getDeclaredMethods()) &#123; handleMethod(method); &#125; &#125; protected void handleMethod(Method method) &#123; String methodName = method.getName(); if (methodName.startsWith(FIXED_PREFIX)) &#123; methodName = methodName.replaceFirst(FIXED_PREFIX, ""); ButtonItem buttonItem = new ButtonItem(); buttonItem.method = method; buttonItem.name = methodName; buttonItems.add(buttonItem); &#125; &#125; protected ButtonItem buildJumpActivityItem(Class&lt;? extends Activity&gt; activityClass) &#123; ButtonItem buttonItem = new ButtonItem(); buttonItem.name = "跳转到" + activityClass.getSimpleName(); buttonItem.target = activityClass; return buttonItem; &#125; public void L(Object s) &#123; Log.i(TAG, s + ""); &#125; public void error(String errorMessage) &#123; T("[错误信息]\n" + errorMessage); &#125; public void T(Object message) &#123; Toast.makeText(context, String.valueOf(message), Toast.LENGTH_SHORT).show(); &#125; public void to(Class&lt;? extends Activity&gt; target) &#123; try &#123; startActivity(new Intent(this, target)); &#125; catch (Exception e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; &#125; public void T(String format, Object... values) &#123; T(String.format(format, values)); &#125; protected static class ButtonItem &#123; public String name; public Method method; public Class&lt;? extends Activity&gt; target; &#125;&#125; JumpActivity.java.ftl 1234567891011121314151617181920package $&#123;packageName&#125;;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;/** * @author zijiao * @version 16/10/16 */public class JumpActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView text = new TextView(this); text.setText("跳转Activity成功"); setContentView(text); &#125;&#125; SimpleActivity.java.ftl 12345678910111213141516171819202122232425262728293031323334353637383940package $&#123;packageName&#125;;@DebugActivity.Jump(&#123;&lt;#if addJumpActivity&gt; JumpActivity.class,&lt;#else&gt;&lt;/#if&gt;&#125;)public class $&#123;activityClass&#125; extends DebugActivity &#123;&lt;#if addExample&gt; private int number = 0; public void _无参方法调用() &#123; T("无参方法调用"); &#125; public void _有参方法调用(Button button) &#123; button.setText("number is " + number++); &#125; //代码执行不到,直接弹出toast提示报错 public void _错误参数调用(String msg) &#123; T("test"); &#125; //方法名没有以"_"开头,按钮无法创建成功 public void 无效调用() &#123; T("test"); &#125; //crash会被会被catch住,以toast方式弹出 public void _Crash测试() &#123; int a = 1 / 0; &#125;&lt;/#if&gt;&#125; ok，到此对于该模板的编写过程就结束了，接下来重启下Android Studio，然后New Project一路next下去，直到这个界面，这里就是我们自定义的DebugActivity模板了 下面是该模板的Github源码 https://github.com/puke3615/DebugActivity.git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件]]></title>
    <url>%2F2016%2F10%2F15%2FAndroid-Studio-Template-For-File%2F</url>
    <content type="text"><![CDATA[文件模板是指以一个文件为基础的模板，这种形式的模板比代码片段级别的模板要复杂一些，模板中设计到VTL(Velocity Template Language)语法。文件级别比代码级别能够存储更多的代码内容，而且能够通过VTL很大程度上提高模板的灵活度，让模板不再是一个不变的文本字符串。 我们开发的过程中可能会遇到有些类在不同的工程下都需要使用，单独抽成jar包可能又有点小题大做了，而且还得在下次使用的时候去依赖它，这个时候我们AS中的FileTemplate便派上用场了。 我们开发中可能经常去写一个继承BaseAdapter的子Adapter，而且里面有一大串无脑代码，于是我写了这个DataAdapter的模板。 Android Studio给我提供了创建模板的快捷方式，我们可以打开任意一个类，然后选择顶部的Tools—Save File As Template便可以快速创建一个当前类的模板文件 或者直接通过Preferences — Editor — File and Code Templates右边的加号创建 然后IDE会自动打开这个界面 大致说下这几个区域 区域1：模板的名称，唯一标识一个文件模板 区域2：模板的后缀名，填写当前属于哪种文件的模板 区域3：模板编辑区 区域4：一些可选配置 区域5：官方对FileTemplate的简单描述，往下滑我们可以看到系统的预设变量（类似于上一章中的预设变量），这里的内容不是很多但营养价值很高，建议看一下 接下来我们编辑模板，把这段模板内容直接粘贴到编辑区，然后给模板命名为User即保存关闭该弹窗 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] name = &#123;&#125;;&#125; 现在我们来引入刚写的模板，右键选择待添加模板的包 — New — User 也可以New一个Java Class然后在弹窗中通过上下方向键或者下拉列表来选择找到创建的User模板 还可以直接在New下面选择 创建模板之后的引入方式有很多，我们可以使用自己比较喜欢的方式去引入。最终输入文件名点确定，代码直接生成出来。 上面说的是最基本的文件模板需求，当我们的文件需要多个参数时，例如User这个模板的name属性名可能是多边的，只有引入模板时才能确定下来，这时我们可以用自定义变量来表示，如下 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] $&#123;fieldName&#125; = &#123;&#125;;&#125; 这个时候我们再引入模板时，IDE会扫描有没有自定义变量，如果有的并且没有被初始化赋值的话就在弹出的对话框中多一个可编辑的区域，如下图 这便支持自定义参数的场景，到这一步为止，一般的文件模板需求我们都可以自己满足了。下面介绍一些相对深一点的使用方式，有兴趣的可以看看。 Android Studio的FileTemplate使用Velocity Template Language（简称VTL）进行逻辑判断和流程控制，有兴趣的可以直接看下Velocity的官方文档。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之代码片段]]></title>
    <url>%2F2016%2F10%2F14%2FAndroid-Studio-Template-For-Part%2F</url>
    <content type="text"><![CDATA[代码片段是Template上的最小单位，因此它也具有最大的灵活性，支持多参数配置、TAB切换、代码块包装等多种特性（IDEA同样适用）。 创建一个单例类 写一个将InputStream转化为String的方法 生成main方法并打印数字 用try catch来包装代码块 上面的这些有的是IDE自带的，有的是自定义的。具体位置我们可以进入IDE，Preserences，Editor，Live Templates，我们可以在右边栏看到一些列IDE预设的template，如下图 这里我们展开Android，可以看到下图 这里面所有的我们都可以使用，括号后面的内容是为了描述该模板的，你也可以取消前面的勾选来取消该模板。 其实系统预设的有很多都是很实用的，有兴趣的可以去试一试，不多说。这里主要看一下如何自定义模板，把一些常用的代码片段DIY到自己的模板库中，当下次再需要同样代码的时候只需要一个标识符就能迅速自动生成。 我们点击右上角的加号，我们可以看到两个选项一个是Live Template，这个表示一个模板，另一个是Template Group，这个表示一个模板所属的分组，就像上面看到的Android，它就属于一个分组。 接下来我们先创建一个自己的Template Group，名称随便取，不要与已有的分组重名就行，这里就取为Custom。然后我们选中新建的这个Custom分组再创建Live Template，会看到如下界面 我对这个界面做了数字标志，大致说下每个区域代表的含义 区域1：表示模板的缩写，也是我们最终使用时在编辑区输入的指令 区域2：表示模板的提示，当输入对应缩写时，就会弹出这个提示 区域3：这里就是最关键的模板区了，模板区包含两部分，一个是模板内容，它可以是任意字符串，另一个是模板变量，它有自己特殊的含义并且格式固定，首尾都是”$”符。模板变量又包含预设变量和自定义变量，比如”$END$”就是一个预设变量，它指定了模板导入结束后鼠标光标最终要停留的位置，而自定义变量则表示模板中一些动态性的部分，比如类名，它在不同的类中引入的结果是不同的。在多个自定义变量的情况下引入模板时，默认按TAB键切换至下个自定义变量位置。 区域4：自定义变量的配置入口，可以给我们的自定义变量添加一些约束条件 区域5：指定该模板的作用域，例如指定用于Java还是groovy等等 区域6：提供一些引入模板的可选操作 这里我们来写一个生成单例的模板，我们按照下图定义好缩写，描述与模板内容 模板内容的代码如下 12345678910111213141516private static final byte[] sInstanceLock = new byte[0];private static $className$ sInstance;private $className$() &#123;&#125;public static $className$ instance() &#123; if (sInstance == null) &#123; synchronized (sInstanceLock) &#123; if (sInstance == null) &#123; sInstance = new $className$(); &#125; &#125; &#125; return sInstance;&#125; 然后我们选择区域4来编辑我们的自定义变量，我们进去后可以看到如下弹窗 Name为自定义的变量名称 Expression表示系统提供的一些方法 Default value为改变量的默认值 Skip if define勾选后，如果该变量被赋值则跳过，相当于引入过程中一次手动的TAB 接着我们在Expression中选择className()，并勾选Skip if define，并点击确定 最后我们点击区域5来选择模板的作用域，我们选择Java—Declaration 然后保存，我们的单例模板便生成成功了。测试下，在IDE中新建个Java类，在类的内部输入single便出现最上面的那个UserManager的效果。 当然除此之外还有使用”$SELECTION$”来包装代码块的模板，这个使用场景相对较少这里就不举例了，主要使用的就是这种直接的模板模式。感觉一些常用的，特别是工具类中静态方法相关的，我们都可以抽取成模板，提高开发效率。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CallbackProxy模式]]></title>
    <url>%2F2016%2F09%2F04%2FCallbackProxy%2F</url>
    <content type="text"><![CDATA[对于一个核心类或者框架来说，通常会在运行时向外部回调多种操作以便于使用方做出一些主流程上面的AOP或者Intercept操作。而很多操作可能是预留不足以提供的，当我们逐渐去拓展我们的Callback时，使用方的代码将会大量增加，于是引入CallbackProxy的模式解决这个问题。 Callback问题背景1234567891011121314151617181920212223242526public class Manager &#123; public void operate() &#123; a(); b(); c(); d(); e(); &#125; private void a() &#123; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 这是一个简单的Manager类，模拟的是一个底层框架向上层提供的管理类，这里先假设我们这个类的使用方有10个(在这里我们就编号C1~C10)，而他们最终的运行环境都是一致的，只是开发期的环境不一致。我想过直接把一些真实场景中的代码拿出来举例，但是偏向业务的代码往往比较复杂且冗余，所以这里我们就简单粗暴地写了几个空方法模拟。其中operate()方法是提供给外部调用的方法，operate()方法中会调用到内部的a~e的一系列方法。 需求叠加本来是一个简单的业务逻辑，但是突然有个业务方C1说他们需要在Manager的operate()方法的a()方法中添加一个回调，给业务方去处理。于是便有了我们的Callback接口： 123public interface Callback &#123; void callA();&#125; 并且我们还要改造我们的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private Callback mCallback; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们在Manger类中添加一个Callback变量，并向业务方提供了setCakkback(CallbackA callback)方法为了方便外部把自己想在a()方法中做的操作set进来，这样处理既能让我们的业务方C1能够在a()方法中做他们定制化的处理，也不会影响到其他业务方的正常使用。 下面便是业务方C1的代码实现部分： 1234567891011121314public class ClientA &#123; public static void main(String[] args) &#123; Manager manager = new Manager(); manager.setCallbackA(new Callback() &#123; @Override public void callA() &#123; //do something &#125; &#125;); manager.operate(); &#125; &#125; 需求再叠加由于业务是多变的，业务会随着许多主观以及客观的情况不断发生改变，某一天我们的业务方C2突然跟我们说，他们需要在b()方法中添加一个回调以处理他们内部的业务逻辑。于是我们开始考虑，上次C1提到要在a()方法中添加回调的时候，我们有创建了一个Callback的接口，并且有在Manager类中提供了setCallback()方法，那我们能不能为了代码的复用性而直接在Callback接口中添加一个回调方法callB()呢。但答案是否认的，因为如果你这样做了，业务方C1会莫名躺枪的…… 既然我们不能添加Callback中的方法，又不想想我们对业务方C2支持的同时又去影响到C1，那我们只能新建一个接口CallbackB了： 123public interface CallbackB &#123; void callB(); &#125; 于是，我们的Manager又得这样改变： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Manager &#123; private Callback mCallback; private CallbackB mCallbackB; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB; &#125; private void b() &#123; if (mCallbackB != null) &#123; mCallbackB.callB(); &#125; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们开始看一下我们对Manager类的改动，我们这次的代码增量是： 123456789101112//1. 新增的CallbackB属性private CallbackB mCallbackB;//2. 新增的CallbackB的set方法public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB;&#125;//3. 新增的回调逻辑的调用时机if (mCallbackB != null) &#123; mCallbackB.callB();&#125; 我这里将增量部分切分为1、2、3三个部分。我们来仔细分析一下这三个部分，其中1和2其实是一种“无脑操作”，就是新增加一个回调接口，并提供回调接口的set方法而已，更甚至来说，3中的非空判断也都是冗余的。 仅仅为了满足C2的回调处理其实是简单的，只是既然今天C2会过来说是需要b()方法的回调，那接下来谁也不敢保证C3、C4、C5会不会再过来提出要在c()方法，d()方法，e()方法中添加对应的回调，甚至C3要abc的回调，C4要ace的回调。业务简单的时候，代码不一定是简单的，但是业务复杂的时候，代码一定是复杂的。 而且，站在职责单一的角度来看，对于我们的Manager类是不应该去维护这样一系列繁琐的Callback，并且还要在每个回调时机时进行非空判断的。 CallbackProxy模式CallbackProxy的引入这里我们引入CallbackProxy模式，我们先定义一个空接口： 12public interface Callback &#123;&#125; 这个接口就是对于Manager类的一个统一协定，协定所有Manager向外的回调都必须继承该接口。 接下来便有我们的一系列Callback： 123public interface CallbackA &#123; void callA();&#125; 123public interface CallbackB &#123; void callB();&#125; 123public interface CallbackC &#123; void callC();&#125; 然后有一个类来实现所有的Manager需要向外回调的Callback，然后都是一些空实现。 12345678910111213141516public class SimpleCallback implements CallbackA, CallbackB, CallbackC &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125;&#125; 然后便有我们的重头戏CallbackProxy，它继承于SimpleCallback，然后内部存储一个真实的Callback，并向外提供一个setCallback()方法: 1234567891011121314151617181920212223242526272829public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125;&#125; 接下来我们来看一下我们的引入CallbackProxy之后的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们可以看到，现在的Manager类不需要再声明一系列的Callback，再提供一系列的setCallback方法，再来一堆的非空判断，这些都让我们的CallbackProxy来做了。而我们的Manger类只需要专注于他自己的业务逻辑处理和选择合适的时机进行回调即可。 拓展性上面的引入Callback的例子中我们写了a~c的回调，现在假如某个业务方还需要我们提供d()方法的回调，接下来我们只需要在新建一个CallbackD类，并在SimpleCallback和CallbackProxy做出对应的改变，然后在我们的真正做回调处理的Manager类中直接在d()方法中调用mCallback的callD()方法即可，代码如下： 123public interface CallbackD &#123; void callD();&#125; 123456789101112131415161718192021public class SimpleCallback implements CallbackA, CallbackB, CallbackC, CallbackD &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125; @Override public void callD() &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125; @Override public void callD() &#123; if (mCallback instanceof CallbackD) &#123; ((CallbackD) mCallback).callD(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; mCallbackProxy.callD(); &#125; private void e() &#123; &#125;&#125; 我们会发现我们的逻辑变得很清晰，类虽然多点，但是各司其职、有条不紊。 更高效开发其实到了上面，CallbackProxy的介绍已经是完成了，但有一点需要说明，就是关于对Callback拓展的时候。我们发现其实我们真正做的回调操作仅仅是定义CallbackD和在Manager的d()方法中添加callB()的回调这两个地方。其他的在SimpleCallback和CallbackProxy的处理都是绝对无脑的，于是我们应用APT技术来简化我们的SimpleCallback和CallbackkProxy的处理(由于该篇不是为了介绍APT的，这里只把简单的使用效果贴出来)。 12345678@ProxyGenerator( rootClass = Callback.class)public interface Api extends Base, CallbackHolder.Callback1, CallbackHolder.Callback2, CallbackHolder.Callback3, CallbackHolder.Callback4 &#123; String login(String username);&#125; 这里我们只需要写一个接口继承我们所有需要添加的Callback，然后加上一些注解配置，即可自动生成对应的SimpleCallback和CallbackProxy类： 123456789101112131415161718192021222324252627282930313233public abstract class SimpleApi implements Api &#123; @Override public String login(String username) &#123; return null; &#125; @Override public void base() &#123; &#125; @Override public int commonOperation() &#123; return 0; &#125; @Override public void call1() &#123; &#125; @Override public void call2(String name, int age) &#123; &#125; @Override public int call3(String name) &#123; return 0; &#125; @Override public String call4(int age) &#123; return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public final class ApiProxy implements Api &#123; private Callback mCallback; @Override public String login(String username) &#123; if (mCallback instanceof Api) &#123; return ((Api) mCallback).login(username); &#125; return null; &#125; @Override public void base() &#123; if (mCallback instanceof Base) &#123; ((Base) mCallback).base(); &#125; &#125; @Override public int commonOperation() &#123; if (mCallback instanceof Base) &#123; return ((Base) mCallback).commonOperation(); &#125; return 0; &#125; @Override public void call1() &#123; if (mCallback instanceof CallbackHolder.Callback1) &#123; ((CallbackHolder.Callback1) mCallback).call1(); &#125; &#125; @Override public void call2(String name, int age) &#123; if (mCallback instanceof CallbackHolder.Callback2) &#123; ((CallbackHolder.Callback2) mCallback).call2(name, age); &#125; &#125; @Override public int call3(String name) &#123; if (mCallback instanceof CallbackHolder.Callback3) &#123; return ((CallbackHolder.Callback3) mCallback).call3(name); &#125; return 0; &#125; @Override public String call4(int age) &#123; if (mCallback instanceof CallbackHolder.Callback4) &#123; return ((CallbackHolder.Callback4) mCallback).call4(age); &#125; return null; &#125; public final void setCallback(Callback mCallback) &#123; this.mCallback = mCallback; &#125;&#125; 也就是说当我们需要拓展一个新的Callback时，只需要让Api这个接口多继承一个新的Callback并generate，然后 就可以在Manager类中添加对应的回调就ok了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FCodeGenerator%2F</url>
    <content type="text"><![CDATA[Android Studio Plugin的一些拓展插件使用，简化我们的日常开发。 单例生成 Copy生成 FindView生成 MainMethod生成 Activity添加到AndroidManifest.xml]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin - 高效开发 - Generaotr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BuilderGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FBuilderGenerator%2F</url>
    <content type="text"><![CDATA[日常开发中，我们经常会使用到Builder模式，我们一般都是直接手动地去写一个Builder类来使用。这里我们采用APT的方式进行配置生成Builder类。 快速接入配置apt依赖外层gradle添加 1classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' 内层build.gradle添加 1apply plugin: 'com.neenbedankt.android-apt' 配置该框架依赖内层build.gradle添加 12compile 'com.puke:buildergenerator-api:1.0.0'apt 'com.puke:buildergenerator-compiler:1.0.0' 到这里，配置部分就结束了，接下来就是使用过程。 使用姿势这里我们模拟一个需要使用Builder模式的类Dog 123456789101112131415public class Dog &#123; private String name; private int age; private String sex; private Color color; @Builder("configure") Dog(@Item("customName") String name, @Item int age, @Item String sex, Color color) &#123; this.name = name; this.age = age; this.sex = sex; this.color = color; &#125;&#125; 然后只需要build一下Project就ok了 我们可以在该Module的“build/generated/source/apt”目录下找到对应的DogBuilder类，如下 1234567891011121314151617181920212223242526272829// this is a generated file.package com.puke.buildergeneator;public final class DogBuilder &#123; private String customName; private int age; private String sex; public final DogBuilder configureCustomName(String customName) &#123; this.customName = customName; return this; &#125; public final DogBuilder configureAge(int age) &#123; this.age = age; return this; &#125; public final DogBuilder configureSex(String sex) &#123; this.sex = sex; return this; &#125; public final Dog build() &#123; return new Dog(customName, age, sex, null); &#125;&#125; 几点说明整体比较轻巧，使用起来也比较简单，我们可以重点看一下该类的构造方法，接下来几点说明： 构造方法上面加了@Builder注解 表示该类是要生成Builder类 @Builder中注入了“configure” 表示生成注解类的组装子Item的方法前面全部都要加上”configure“关键字，当然这个是可选的，如果不加的话就会直接就直接取方法名 构造方法中加入了@Item注解 加入了@Item注解的参数表示Builder类中可以加入的参数，未加则不能通过Builder加入 @Item中注入“customName” 表示在Builder类中给对应的属性设置的别名，不设时默认去参数名 项目源码https://github.com/puke3615/BuilderGeneator.git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>APT</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android注解]]></title>
    <url>%2F2016%2F08%2F29%2FAndroid-Annotation%2F</url>
    <content type="text"><![CDATA[在Java中经常会用到注解，通过注解的方式可以实现很多灵活性的东西。很多优秀的框架都支持注解的方式，如Spring的中对Bean的注解，Hibernate中对POJO类的注解，Mybatis中对Mapper的注解，ButterKnife中对View的注解，Dagger中对各个Component的注解， Retrofit对Api的注解。一言以蔽之，使用注解可以让整个代码风格看起来清爽明了。 传统的代码风格activity_main.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/username" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入用户名.." /&gt; &lt;Button android:id="@+id/submit" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="提交" /&gt;&lt;/LinearLayout&gt; 很简单的一个界面，只有一个EditText和一个Button，就不过多解释了。 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends Activity &#123; private EditText mUsername; private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initListener(); &#125; private void findView() &#123; mUsername = (EditText) findViewById(R.id.username); mSubmit = (Button) findViewById(R.id.submit); &#125; private void initListener() &#123; mSubmit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 我们这里要做到是用户点击提交的时候，Toast弹出EditText输入的内容，比较简单，略过~ 传统的风格是这样的，这样看来也许觉得没什么问题，但是实际的开发当中我们一个页面当中包含的View，以及对应的View的一些事件回调要远远比这个繁琐。我相信一个Activity中要处理十几二十几个View也不算是什么稀奇的事情，那这样会造成什么结果呢。。。 你的属性声明会是这样的 12345678private Button mButton1;private Button mButton2;private Button mButton3;private Button mButton4;private Button mButton5;private Button mButton6;private Button mButton7;private Button mButton8; 你的findView会是这样的 12345678mButton1 = (Button) findViewById(R.id.button1);mButton2 = (Button) findViewById(R.id.button2);mButton3 = (Button) findViewById(R.id.button3);mButton4 = (Button) findViewById(R.id.button4);mButton5 = (Button) findViewById(R.id.button5);mButton6 = (Button) findViewById(R.id.button6);mButton7 = (Button) findViewById(R.id.button7);mButton8 = (Button) findViewById(R.id.button8); 你的事件监听会是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mButton1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 例子举得不怎么恰当，但是足以说明随着业务代码的不断扩大，这些看上去的”无脑操作“也会让我们广大coder变得愈加的不耐烦，而且会使得我们的类变得庞大而臃肿。 那么，接下来我们就通过注解的方式来搞一发~ 注解的编码风格我们打算使用注解的方式实现 xml的配置 View的注入 点击事件的绑定 接下来就是具体实现逻辑 首先我们先定义一个Bind注解 12345678910111213141516package com.puke.annotationdemo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/18 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)public @interface Bind &#123; int value() default 0;&#125; 然后写Bind注解对应的注解处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.puke.annotationdemo;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author zijiao * @version 16/8/18 */public class BindHandler &#123; /** * 处理对Activity的注解 * * @param activity 目标Activity */ public static void handleBind(Activity activity) &#123; Class cls = activity.getClass(); handleSetContentView(activity); handleFindView(cls.getDeclaredFields(), activity); handleClickEvent(cls.getDeclaredMethods(), activity); &#125; //绑定xml布局 private static void handleSetContentView(Activity activity) &#123; Class&lt;?&gt; cls = activity.getClass(); if (cls.isAnnotationPresent(Bind.class)) &#123; //Activity中加入Bind注解时取出注解配置 Bind bind = cls.getAnnotation(Bind.class); int layout = bind.value(); if (layout != 0) &#123; activity.setContentView(layout); &#125; &#125; &#125; //View的注入 private static void handleFindView(Field[] declaredFields, Activity activity) &#123; if (declaredFields == null || declaredFields.length == 0) &#123; return; &#125; for (Field field : declaredFields) &#123; //找到被Bind注解且是View的所有属性 if (field.isAnnotationPresent(Bind.class) &amp;&amp; View.class.isAssignableFrom(field.getType())) &#123; Bind bind = field.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; View view = activity.findViewById(id); field.setAccessible(true); try &#123; //直接通过反射set进去 field.set(activity, view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //点击事件的绑定 private static void handleClickEvent(Method[] declaredMethods, final Activity activity) &#123; if (declaredMethods == null || declaredMethods.length == 0) &#123; return; &#125; for (final Method method : declaredMethods) &#123; //找到被Bind注解且无参的所有方法（注意这里限制无参是为了与下面调用method.invoke(activity)的无参保持一致） if (method.isAnnotationPresent(Bind.class) &amp;&amp; method.getParameterTypes().length == 0) &#123; Bind bind = method.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; activity.findViewById(id).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; method.invoke(activity); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125;&#125; 好了，到了这一步，我们的注解工作算是结束了，代码相对有点多，但这个是一劳永逸的。 接下来就是对注解的使用了 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bind(R.layout.activity_main)public class MainActivity extends Activity &#123; @Bind(R.id.username) private EditText mUsername; @Bind(R.id.submit) private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind(R.id.submit) public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; Run一下，完美运行~ 我们这里可以看到，使用注解之后 setContentView方法没了 findViewById方法没了 setOnClickListener方法没了 MainActivity整个类减肥了 所有的所有，都让注解处理器一手承包了。而我们要做的是什么，要做的是真正应该由coder做的事情，在对应的地方加上对应的注解配置就ok了。 然后我们可以回过头看一下Bind这个注解，细心的同学可能发现注解声明value()的时候理论上来讲不应该有一个default为0的默认值。原因很简单啊，因为就目前的使用场景来看，无论注入一个layout还是一个id都不会为0，那这里干嘛还要再写一个default 0呢，直接不要default可以限制业务方的使用，强约束业务方一旦使用注解就必须要在注解里面set一个值进来。这里我要说明一下，我们写注解就是为了方便使用，快速开发，既然要懒，我们就懒到家，干脆就让我们的注解处理器能在业务方没有在Bind中注入值的时候也能生效。 就是要实现下面这种效果: 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bindpublic class MainActivity extends Activity &#123; @Bind private EditText mUsername; @Bind private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; 这样一来，只需要几个全裸的注解一顿狂注之后，就完事了。后面这种的实现方式我这里就不写了，大致说一下思路，注解处理器要制定类名—layout，属性名—id，方法名—id，这样一套转换标准出来，然后注解处理器的处理逻辑是先看业务方有没有手动注入，没有手动注入的情况（也就是前面提到的default 0）下，注解处理器再按照这套标准利用反射来取出对应的R类的对应资源值，只要找到对应的资源值，就和手动注入处理结果的完全一样。 一些问题每当一种事物出现时，只要不是太极端，总会有人拥护，也有人异议。单单站在coder的角度，这种注解的方式给我带来的好处是显而易见的，算是治愈代码密集恐惧症的偏方了。 但是值得深思的是，这里大量使用了反射，在Java中反射的性能问题总是尴尬的不要不要的。虽然jdk每次升级时基本上都在对反射进行优化，但是毕竟是反射，纯理论上讲，它确实没有直接的方法调用高效。 当然针对这个问题，我也有见过这样一种说法，假如我们对所谓”高效“的时间容忍度是1000t(t为一个时间粒度单位)，直接方法调用耗时是1t，反射是50 - 200t。也就是说，反射是耗性能，是不效率，但是这个也只是相对与直接方法调用而言的，而还远远没达到我们对性能指标的容忍值。 我曾经也在高效开发和反射性能消耗之间纠结很久，在这里就不去过多评价，仁者见仁，智者见智了~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>高效开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2016%2F08%2F29%2FJava-Reflection%2F</url>
    <content type="text"><![CDATA[Java是门面向对象的语言，其中的每一个对象都有与之对应的的Class。只要一提到Class，自然就想到Java的反射机制，可见反射在Java中的重要性。 Class的获取类名.class1Class cls = User.class; 对象.getClass()1Class cls = user.getClass(); Class.forName()12//注意这里的参数是类的全限定名(即含有包名)Class cls = Class.forName("com.reflect.User"); ClassLoader1Class cls = classLoader.findClass("com.reflect.User"); 创建对象通过Class创建公有的无参构造方法12Class&lt;User&gt; cls = User.class;User user = cls.newInstance(); 通过Constructor创建公有的无参构造方法123Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getConstructor();User user = constructor.newInstance(); 通过Constructor创建私有的无参构造方法12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor();//注意，此处使用暴力反射，反射中该方法经常被使用constructor.setAccessible(true);User user = constructor.newInstance(); 通过Constructor创建私有的含参构造方法12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor(String.class, int.class);constructor.setAccessible(true);//注意，此处传递的参数类型和上面的String.class和int.class保持一致User user = constructor.newInstance("小莫", 3); 读写对象属性12345public class User &#123; public static int age; public String name; private String sex;&#125; 静态属性123456Class&lt;User&gt; cls = User.class;Field ageField = cls.getField("age");//读取静态属性int age = (int) ageField.get(null);//设置静态属性ageField.set(null, 10); 成员属性123456Class&lt;User&gt; cls = User.class;Field nameField = cls.getField("name");//读取成员属性String name = (String) nameField.get(user);//设置成员属性nameField.set(user, "大白"); 私有成员属性123456Field sexField = cls.getDeclaredField("sex");sexField.setAccessible(true);//读取私有成员属性String sex = (String) sexField.get(user);//设置私有成员属性sexField.set(user, "大白"); 调用对象方法12345678public class User &#123; public static void say(String name) &#123; System.out.println("My name is " + name); &#125; public int plus(int a, int b) &#123; return a + b; &#125;&#125; 静态方法123456Class&lt;User&gt; cls = User.class;//注意，这里第一个参数是指方法名，后面的参数是可变长参数，是目标方法的对应参数类型//若目标方法是无参的，则不填Method sayMethod = cls.getMethod("say", String.class);//静态方法不依赖对象实例，所以第一个参数是nullsayMethod.invoke(null, "胡巴"); 12后台输出: My name is 胡巴 成员方法1234567User user = new User();Class&lt;User&gt; cls = User.class;Method plusMethod = cls.getMethod("plus", int.class, int.class);//如果该方法是非public的，则要在invoke之前调用 plusMethod.setAccessible(true);//注意，由于该方法是成员方法，它的执行依赖于一个User实例，所以第一个参数是userint result = (int) plusMethod.invoke(user, 2, 7);System.out.println(result); 12后台输出：9 反射的简单应用123456789101112131415161718 上面我们对于反射中一些常用的Api进行了基本的认识，接下来我们进入一个简单的实战练习，案例驱动，以加深对反射的认识。 场景：我们正在使用一个第三方的jar包，包含两个类User和Dog(见下)，而我们现在需求是，要调用一个User实例中dog的happy方法。public class User &#123; private Dog dog = new Dog();&#125;class Dog &#123; public void sleep() &#123; System.out.println(&quot;the dog went to bed.&quot;); &#125;&#125; 有以下难点： 1. 这两个类都是在jar包里面的，不能直接修改 2. 我们要有Dog类的权限，但是Dog这个类是package的 3. 我们要拿到User实例中的dog引用，但是dog属性是private的 4. 我们最终要调用的sleep的方法也是private的没有反射的话，估计我们只能想到两种办法了，要么基于class字节码进行修改，要么直接找需求方互相伤害去~废话不多说，接下来我们来看通过使用反射的方式，来KO这个需求 12345678910111213141516171819202122//1. 获取user对象对应的ClassClass&lt;User&gt; userCls = User.class;//2. 获取到改对象的dog属性Field dogField = userCls.getDeclaredField("dog");//3. 通过dogField属性获取user实例中对应的dog实例//注意,由于Dog类是package级别的,所以这里无法直接声明Dog,只能使用Object代替dogField.setAccessible(true);Object dog = dogField.get(user);//4. 获取dog对象对象的Class对象Class&lt;?&gt; dogCls = dog.getClass();//这里也可以使用这种方式//Class dogCls = Class.forName("com.groovy.reflect.Dog");//5. 获取到Dog的sleep方法Method sleepMethod = dogCls.getDeclaredMethod("sleep");//6. 调用sleep方法sleepMethod.setAccessible(true);sleepMethod.invoke(dog); 12后台输出：the dog went to bed.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2016%2F08%2F29%2FDynamic-Proxy%2F</url>
    <content type="text"><![CDATA[Java的动态代理极大程度提高了我们开发的灵活度，使用动态代理我们能达到强解耦的目的。动态代理能够给我们带来很多开发便捷，这里就介绍下在Android网络请求时的应用。 动态代理实现方式Java中的动态代理给我们提供一种动态生成类的方式，有很好的灵活性，这种技术一般会出现在一些第三方框架中，来降低接入方的使用成本。以下为常用的实现动态代理的几种方式： JDK自带的Proxy方式优点：JDK亲儿子；无依赖；使用简单 缺点：代理类必须继承至少一个接口；无法继承已有父类 asm方式，基于class字节码的操作优点：很底层的操作，性能高，对性能要求苛刻的建议使用 缺点：使用成本高，要熟悉JVM汇编指令 javassist方式，基于class字节码的操作优点：Api简单，通熟易懂，使用成本低 缺点：性能相对偏低 cglib方式，这个是基于ASM的​优点：Api简单；高性能；高灵活性；支持继承父类；可以不用实现接口 缺点：这个真的很强大，个人感觉比JDK自带的要强大很多，一定要说的话只能说使用这个需要加jar包依赖 业务开发的尴尬开门见山，我们直接来看一个业务场景： 1234567891011121314151617181920212223package com.puke.net;/** * @author zijiao * @version 16/8/19 */public class User &#123; public String username; public String uId; public String sex; public String address; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", uId='" + uId + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 这里就是一个用户信息的Entity类，不解释了。 123456789101112131415161718192021222324252627282930package com.puke.net;import com.google.gson.Gson;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class VirtualHelper &#123; private static final Gson sGson = new Gson(); public static String request(String url, Map&lt;String, Object&gt; params) &#123; if (params != null) &#123; if ("123".equals(params.get("username")) &amp;&amp; "456".equals(params.get("password"))) &#123; User user = new User(); user.address = "杭州"; user.sex = "男"; user.uId = "Id"; user.username = "啊啊"; return sGson.toJson(user); &#125; &#125; return null; &#125;&#125; 这里我们模拟一个简单的网络请求。 当我们业务场景需要调用网络请求执行登录操作的时候，会这样写： 1234567891011121314151617181920212223242526package com.puke.net;import com.google.gson.Gson;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 那么，有什么问题呢。其实如果只是一个单单的login方法很难直观的反馈出来问题所在，很多时候我们为了去验证一个事物的合理性我们不妨去开始极端遐想一下这种情况：现在UserApi中又多了register方法，query方法，getToken方法，validate方法……甚至接下来一个UserApi已经满足不了我们了，我们开始有GoodsApi，OrderApi，MessageApi等等等等，试想一下N个Api的类，每个Api类都有N个类似于上面login的这种方法，而实际情况下我们request的入参还远远不止username，password两个这么简单。当我们业务场景扩大的时候，这些都是我们势必要面对的。这是一个问题，那能不能去以一种更优雅的方式去解决从而简化业务方的代码量并且降低使用成本呢。这里便引入了我们的动态代理~ 动态代理的方式去解决我们的目标状态是这样的：让业务方写写接口，加加注解配置，就可以直接使用 先定义两个支持配置的注解123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface URL &#123; String value();&#125; 123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@interface Param &#123; String value();&#125; 这里不过多说明，就是两个可配字符串的注解。 定义一套接口这一步，其实不是必需的。我们完全可以在动态代理中直接显式的调用VirtualHelper类，但既然抽象出来网络Api这块，那就干脆定义一套接口出来来解耦具体实现。 1234567891011121314151617package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public interface IRequest &#123; String url(); Map&lt;String, Object&gt; params(); Class&lt;?&gt; responseCls();&#125; 123456789101112131415161718192021222324252627282930313233343536package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class Request implements IRequest &#123; String url; Map&lt;String, Object&gt; params; Class&lt;?&gt; responseCls; public Request(String url, Map&lt;String, Object&gt; params, Class&lt;?&gt; responseCls) &#123; this.url = url; this.params = params; this.responseCls = responseCls; &#125; @Override public String url() &#123; return url; &#125; @Override public Map&lt;String, Object&gt; params() &#123; return params; &#125; @Override public Class&lt;?&gt; responseCls() &#123; return responseCls; &#125;&#125; 这是请求接口和实现类，粗略写下，比较简单 1234567891011package com.puke.net.proxy;/** * @author zijiao * @version 16/8/19 */public interface INetExecutor &#123; &lt;T&gt; T execute(IRequest request);&#125; 123456789101112131415161718192021package com.puke.net.proxy;import com.google.gson.Gson;import com.puke.net.VirtualHelper;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class DefaultNetExecutor implements INetExecutor &#123; private static final Gson sGson = new Gson(); @Override public &lt;T&gt; T execute(IRequest request) &#123; String response = VirtualHelper.request(request.url(), request.params()); return (T) sGson.fromJson(response, request.responseCls()); &#125;&#125; 这个是网络执行器已经默认的实现方式（使用上面的VirtualHelper），主要是抽象出接口可以让业务方自主定制真正的执行操作。 动态代理器这个就直接上代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.puke.net.proxy;import android.text.TextUtils;import java.lang.annotation.Annotation;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class ApiGenerator &#123; private static final Map&lt;Class, Object&gt; sApiCache = new HashMap&lt;&gt;(); private static INetExecutor sNetExecutor; private static class Handler&lt;T&gt; implements InvocationHandler &#123; private Class&lt;T&gt; apiInterface; public Handler(Class&lt;T&gt; apiInterface) &#123; this.apiInterface = apiInterface; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; IRequest request = resolveRequest(method, args, apiInterface); if (sNetExecutor == null) &#123; sNetExecutor = defaultNetExecutor(); &#125; return sNetExecutor.execute(request); &#125; &#125; private static &lt;T&gt; IRequest resolveRequest(Method method, Object[] args, Class&lt;T&gt; apiInterface) &#123; StringBuilder urlBuilder = new StringBuilder(); Map&lt;String, Object&gt; params = null; if (apiInterface.isAnnotationPresent(URL.class)) &#123; String baseUrl = apiInterface.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(baseUrl)) &#123; urlBuilder.append(baseUrl); &#125; &#125; if (method.isAnnotationPresent(URL.class)) &#123; String subUrl = method.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(subUrl)) &#123; urlBuilder.append(subUrl); &#125; &#125; int index = 0; for (Annotation[] annotations : method.getParameterAnnotations()) &#123; for (Annotation annotation : annotations) &#123; if (annotation instanceof Param) &#123; String key = ((Param) annotation).value(); if (!TextUtils.isEmpty(key)) &#123; if (params == null) &#123; params = new HashMap&lt;&gt;(); &#125; params.put(key, args[index]); &#125; break; &#125; &#125; index++; &#125; return new Request(urlBuilder.toString(), params, method.getReturnType()); &#125; private static INetExecutor defaultNetExecutor() &#123; return new DefaultNetExecutor(); &#125; public static &lt;T&gt; T generateApi(Class&lt;T&gt; apiInterface) &#123; if (apiInterface == null || !apiInterface.isInterface()) &#123; throw new RuntimeException("the apiInterface is null or isn`t interface."); &#125; synchronized (ApiGenerator.class) &#123; Object api = sApiCache.get(apiInterface); if (api == null) &#123; api = Proxy.newProxyInstance(apiInterface.getClassLoader(), new Class[]&#123;apiInterface&#125;, new Handler(apiInterface)); sApiCache.put(apiInterface, api); &#125; return (T) api; &#125; &#125; /** * 外部提供自定义执行器 * * @param netExecutor 网络执行器 */ public static void setNetExecutor(INetExecutor netExecutor) &#123; sNetExecutor = netExecutor; &#125;&#125; 到此，我们的动态代理的编码部分就结束了。我们可以看一下ApiGenerator这个类有个sApiCache的静态变量，他缓存了动态代理生成的对象，这里这样做还是很有必要的，防止重复创建Api的代理类造成额外的性能消耗。 使用姿势业务方只需要按照我们约束的一套标准来写一个interface即可 1234567891011121314151617package com.puke.dynamicproxy;import com.puke.net.User;import com.puke.net.proxy.Param;import com.puke.net.proxy.URL;/** * @author zijiao * @version 16/8/19 */@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是业务方要写的接口，以及对应的一些注解配置。 接下来就可以直接使用LoginApi生成的具体实例了 1234567891011121314151617181920212223242526package com.puke.dynamicproxy;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Toast;import com.puke.net.User;import com.puke.net.proxy.ApiGenerator;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.login).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LoginApi loginApi = ApiGenerator.generateApi(LoginApi.class); User user = loginApi.login("123", "456"); Toast.makeText(MainActivity.this, user.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 由于此处模拟的网络请求，就不考虑主线程的进行这个操作了。 使用对比这里我再贴一下使用前后的代码对比 123456789101112131415public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 这个是传统的Api方式下业务方要写的代码 12345@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是使用了动态代理之后业务方要写的代码 对比一下，明显能感觉到我们的代码精简了一大圈，看上去清晰明了~ 这里我们再回归到最近开始提到的问题，当业务逐渐扩大的时候，这两种模式下，无论是开发效率上还是代码精简度上根本不具有可比性。 一些想法其实，基于动态代理我们还可以做很多事情，当某一类事物有一些共性，我们一直重复去写一堆“孪生”代码，不仅降低了我们的开发效率，还容易让我们产生一种思维定式，按照一个固有的模式去重复做一类事太容易固化我们的思维。不仅仅是动态代理，还有很多很多，开发本该是件轻松的事。工欲善其事，必先利其器。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>高效开发</tag>
        <tag>动态代理</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
