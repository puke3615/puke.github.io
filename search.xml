<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[彻底解耦RecyclerView.Adapter]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-RecyclerView-Architecture-Design%2F</url>
    <content type="text"><![CDATA[在RecyclerView中的ItemType很多时，Adapter的代码量也会随之不断增加，最近我一直在思考如何通过代码设计的方式来解决这种具象的业务问题，能否找到解决该类问题的通法？如何设计出一种模式，使得增删改一种ItemType时的成本降到最低？如何能够彻底解耦掉这些问题的核心大类——Adapter？ 我们在使用RecyclerView的时候，总会遇到多项ItemType的场景。随着业务复杂度的增加，ItemType会越变越多，导致代码量越来越多，最终发展为“上帝类”，本文将从代码设计的角度来找到解决这类问题的通法。 业务场景还原这里先通过Demo来还原一下真实的业务场景，后面便基于该场景进行问题的串联。假设现在只有三种ItemType，为了简单起见就分别对应A、B、C三种类型。 渲染数据一般对应的数据也会有个字段来标识当前数据隶属于哪种type，首先定义实体ItemData。 123456789101112public class ItemData &#123; /** * typeA: A类型 * typeB: B类型 * typeC: C类型 */ public String type; public String textA; public String textB; public String textC;&#125; 通用模板然后就是通用的代码模板，几乎所有的RyclerView.Adapter都会要写的数据传递和更新的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839public class TargetAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; @NonNull private final List&lt;ItemData&gt; dataSource; public TargetAdapter() &#123; this.dataSource = new ArrayList&lt;&gt;(); &#125; /** * 数据刷新 * * @param dataSource 数据源 */ public void setDataSource(@Nullable List&lt;ItemData&gt; dataSource) &#123; this.dataSource.clear(); if (dataSource != null) &#123; this.dataSource.addAll(dataSource); &#125; notifyDataSetChanged(); &#125; /** * 数据添加 * * @param dataSource 数据源 */ public void addDataSource(@Nullable List&lt;ItemData&gt; dataSource) &#123; if (dataSource != null &amp;&amp; !dataSource.isEmpty()) &#123; this.dataSource.addAll(dataSource); notifyDataSetChanged(); &#125; &#125; @Override public int getItemCount() &#123; return dataSource.size(); &#125;&#125; ItemType相关定义ItemTypeItemType具体的值需要我们自己去定义，这里由于我们预先知道了一共三种type，所以预定义好如下常量。 123private static final int TYPE_A = 0;private static final int TYPE_B = 1;private static final int TYPE_C = 2; 重写getItemViewType重写该方法是为了告诉RecyclerView当前数据项对应哪中具体的ItemType。 12345678910111213@Overridepublic int getItemViewType(int position) &#123; ItemData itemData = dataSource.get(position); switch (itemData.type) &#123; case "typeA": return TYPE_A; case "typeB": return TYPE_B; case "typeC": return TYPE_C; &#125; return TYPE_C;&#125; 定义对应type的ViewHolder我们假设一个ViewHolder只对应单独的TextView，也只有一种普通的事件处理的需求。 1234567private static class AViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; AViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_a); &#125;&#125; 其中B、C对应类似的代码，这里就不贴出来了。 重写onCreateViewHolder重写该方法是为了给RecyclerView新建一个当前这种类型对应的ViewHolder实例。该方法的代码量直观感觉上不是太多，但却是后续进行代码解耦的难点所在。 123456789101112131415161718@NonNull@Overridepublic RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); final View itemView; switch (viewType) &#123; case TYPE_A: itemView = inflater.inflate(R.layout.item_a, parent, false); return new AViewHolder(itemView); case TYPE_B: itemView = inflater.inflate(R.layout.item_b, parent, false); return new BViewHolder(itemView); case TYPE_C: default: itemView = inflater.inflate(R.layout.item_c, parent, false); return new CViewHolder(itemView); &#125;&#125; 重写onBindViewHolder最后一步，重写该方法是为了处理ItemView的渲染和交互逻辑。该方法是Adapter逐渐臃肿的直接原因，这里为了简化Demo，已经将方法的处理逻辑简化掉了很多了，只包含一个TextView的渲染和点击交互，但即便如此该方法仍然占用接近40行的代码量。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; int viewType = getItemViewType(position); final Context context = holder.itemView.getContext(); ItemData itemData = dataSource.get(position); switch (viewType) &#123; case TYPE_A: AViewHolder aViewHolder = (AViewHolder) holder; aViewHolder.textView.setText(itemData.textA); aViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item A", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; case TYPE_B: BViewHolder bViewHolder = (BViewHolder) holder; bViewHolder.textView.setText(itemData.textB); bViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item B", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; case TYPE_C: CViewHolder cViewHolder = (CViewHolder) holder; cViewHolder.textView.setText(itemData.textC); cViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item C", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; &#125;&#125; 代码总览截止到目前，场景还原部分已经全部完成，此时的代码量已经有小200行了，而实际业务场景中的代码量只会多不会少。为了便于后续的描述，最后贴出当前Adapter全量的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class TargetAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private static final int TYPE_A = 0; private static final int TYPE_B = 1; private static final int TYPE_C = 2; @NonNull private final List&lt;ItemData&gt; dataSource; public TargetAdapter() &#123; this.dataSource = new ArrayList&lt;&gt;(); &#125; /** * 数据刷新 * * @param dataSource 数据源 */ public void setDataSource(@Nullable List&lt;ItemData&gt; dataSource) &#123; this.dataSource.clear(); if (dataSource != null) &#123; this.dataSource.addAll(dataSource); &#125; notifyDataSetChanged(); &#125; /** * 数据添加 * * @param dataSource 数据源 */ public void addDataSource(@Nullable List&lt;ItemData&gt; dataSource) &#123; if (dataSource != null &amp;&amp; !dataSource.isEmpty()) &#123; this.dataSource.addAll(dataSource); notifyDataSetChanged(); &#125; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); final View itemView; switch (viewType) &#123; case TYPE_A: itemView = inflater.inflate(R.layout.item_a, parent, false); return new AViewHolder(itemView); case TYPE_B: itemView = inflater.inflate(R.layout.item_b, parent, false); return new BViewHolder(itemView); case TYPE_C: default: itemView = inflater.inflate(R.layout.item_c, parent, false); return new CViewHolder(itemView); &#125; &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; int viewType = getItemViewType(position); final Context context = holder.itemView.getContext(); ItemData itemData = dataSource.get(position); switch (viewType) &#123; case TYPE_A: AViewHolder aViewHolder = (AViewHolder) holder; aViewHolder.textView.setText(itemData.textA); aViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item A", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; case TYPE_B: BViewHolder bViewHolder = (BViewHolder) holder; bViewHolder.textView.setText(itemData.textB); bViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item B", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; case TYPE_C: CViewHolder cViewHolder = (CViewHolder) holder; cViewHolder.textView.setText(itemData.textC); cViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item C", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; &#125; &#125; @Override public int getItemViewType(int position) &#123; ItemData itemData = dataSource.get(position); switch (itemData.type) &#123; case "typeA": return TYPE_A; case "typeB": return TYPE_B; case "typeC": return TYPE_C; &#125; return TYPE_C; &#125; @Override public int getItemCount() &#123; return dataSource.size(); &#125; private static class AViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; AViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_a); &#125; &#125; private static class BViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; BViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_b); &#125; &#125; private static class CViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; CViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_c); &#125; &#125;&#125; 开发痛点梳理面向开发者而言，我们评判一个架构设计好坏的原则通常有两个维度——拓展性和维护性（当然还有健壮性，或称为鲁棒性，但该指标主要依赖于边界条件和异常情况的处理，它是所有编码的基本要求，这里不做赘述）。下面就基于这两个维度进行展开说明 拓展性拓展性主要体现在基于当前的架构设计进行新功能增加时对原有代码所带来改动成本和波及范围方面，拓展性越差的设计所带来的改动成本和代码波及范围就越大，反之就越小。 下面结合一个具象的例子来体会当前的代码设计下的改动成本，假设现在添加一个新类型D，那我们需要如下改动： 首先需要添加一个新的ItemType常量 1private static final int TYPE_D = 3; 然后需要getItemViewType方法添加 12case "typeD": return TYPE_D; 然后需要新的ViewHolder 1234567private static class DViewHolder extends RecyclerView.ViewHolder &#123; TextView textView; DViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_d); &#125;&#125; 然后onCreateViewHolder方法添加 123case TYPE_D: itemView = inflater.inflate(R.layout.item_d, parent, false); return new DViewHolder(itemView); 最后onBindViewHolder方法添加 12345678910case TYPE_D: DViewHolder dViewHolder = (DViewHolder) holder; dViewHolder.textView.setText(itemData.textD); dViewHolder.textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item D", Toast.LENGTH_SHORT).show(); &#125; &#125;); break; 至此，一个新类型的ViewHolder的逻辑已经全部添加完成，一共需要添加上述的5处的代码。 说下我个人最直观的感受——繁琐，非常繁琐！我新建一种类型的ViewHolder需要在一个几百行、甚至几千行代码的Adapter大类中去分别找到这5处不同的代码位置，然后逐一进行更改，缺一不可。万一我漏掉了一处怎么办？万一其中一处的代码我copy错了怎么办？都不能正常显示出新加项。而实际的开发场景中，我确实会很容易犯此类错误，以至于新添加一项ViewHolder就像背口诀一样逐一确认，防止漏加错加。 我希望的场景是怎样的，我希望新加ViewHolder时只需要添加一个类，从而低耦合；我希望这个类包含且只包含新加项的代码逻辑，从而高内聚。 维护性维护性主要体现在基于当前的架构设计进行老功能修改时对原有代码所带来改动成本和波及范围方面，维护性越差的设计所带来的改动成本和代码波及范围就越大，反之就越小。此外，基于维护性而言编码最忌讳的就是“上帝类”的出现。 我们不需要也不希望一个类身兼多职、包罗万象。和企业用人不同的是，企业在资金有限的情况下，为减少开支尤为钟爱全能型人才，人越多使用成本越大；而编码方面，我们不怕小类多，我们怕大类不纯。不扯什么单一原则、设计模式，我们就说最实在的，维护代码量太大的类，逻辑找起来揪心、改起来闹心。 比如现在要更改一下CViewHolder中的文本颜色逻辑，要根据数据进行动态设置。实际上只需要添加如下这一行代码即可，而我们定位到待添加代码的位置却要产生额外的检索时间消耗，即便我们的IDE很强大。 1cViewHolder.textView.setTextColor(itemData.isVip ? Color.YELLOW : Color.BLACK); 明确目的基于对上面开发痛点的梳理，现在总结下接下来最主要的目标——解耦Adapter，将各自ViewHolder的代码逻辑独立出去。 彻底解耦Adapter对于解耦Adapter，由于之前我也有这方面的思考和尝试，也把ViewHolder从Adapter中进行抽离，但一直都不彻底，因为一个很核心的原因——ItemType，我在网上也看过很多的RecyclerView解耦方案，也同样有这个不足。 解耦从哪里开始对于一个泛化意义的类，它开始转变复杂的最根本原因在于抽象语义的方法被业务场景具象化。所以我开始直接去找抽象语义的方法，就是如下的三个，而接下来解耦的主要工作就是这三个方法 12345678// 创建RecyclerView.ViewHolder实例RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType);// ViewHolder数据绑定void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position); // 判断当前项对应哪个ItemTypeint getItemViewType(int position); 创建抽象基类我们需要把多种类型ViewHolder里公有的逻辑抽象出来，而这些公有逻辑需要一个抽象基类作为逻辑载体。所以我们创建一个BaseViewHolder类。 12345678910111213public class BaseViewHolder extends RecyclerView.ViewHolder &#123; protected final Context context; public BaseViewHolder(View itemView) &#123; super(itemView); context = itemView.getContext(); &#125; public void onBindData(ItemData data) &#123; &#125; &#125; 现在这个基类非常简单，只有一个onBindData的方法，用来让Adapter对ViewHolder进行数据绑定。有了该类之后，我便可以解耦出第一个方法onBindViewHolder了： 12345@Overridepublic void onBindViewHolder(@NonNull BaseViewHolder holder, int position) &#123; ItemData itemData = dataSource.get(position); holder.onBindData(itemData);&#125; 这一步我们相当于把具象化（A、B、C、D）的数据绑定逻辑抽象到基类里去了，然后只需要我们的具象ViewHolder继承该基类进行onBindData方法的重写即可，以AViewHolder为例： 123456789101112131415161718192021public class AViewHolder extends BaseViewHolder implements View.OnClickListener &#123; private final TextView textView; public AViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.item_text_a); textView.setOnClickListener(this); &#125; @Override public void onBindData(ItemData data) &#123; super.onBindData(data); textView.setText(data.textA); &#125; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item A", Toast.LENGTH_SHORT).show(); &#125;&#125; 与最开始我们在Adapter写的ViewHolder不同的是，ViewHolder不再仅仅是View的载体了，在当前这种模式下ViewHolder还包含数据绑定和事件处理逻辑。 同理，我们也对另外的B、C、D三种类型进行对应ViewHolder的创建。 而到了这一步，我们做的虽然并不是很多，但我们实际上已经完成了Adapter中很大部分的代码解耦了。因为上面也提到过，代码量占比最多的onBindViewHolder方法已经被我们两行代码搞定了。 80%的精力解决20%的问题选择，继续剥离还是适可而止事先着重强调一点，选择没有明确对错，主要是看哪种更合适自己当前的业务场景。 如果只是简单的一两个ViewHolder的场景，哪怕连BaseViewHolder都没必要抽取； 如果类型稍微多一些，比如3-5种时，就要考虑抽取基类了，因为此时的代码量正常情况下已经足以让你的Adapter变得很臃肿、很庞大了； 如果类型更多，或者说明确知道后续还会有拓展，那仅仅到这一步还是远远不够的，因为Adapter里面还会包含各种type常量的声明，各种ViewHolder的创建。而且类型越多、对应的ViewHolder就越多，Adapter类就会越混乱、越庞大； 接下来就针对于继续剥离的分支进行讲述。 陷入僵局，蛇咬住了自己的尾巴接下来，我们重点看onCreateViewHolder方法： 1BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType); 入参是parrent和viewType，我们需要在该方法返回一个BaseViewHolder的实例给我们的RecyclerView。我们能不能把该方法再进行抽象？那我们又如何去根据viewType来实例化我们具象的BaseViewHolder？上面我们之所以能把onBindViewHolder的逻辑往基类里面抽取，是因为有具象的ViewHolder实例，我们可以通过具象的子ViewHolder实例来调用自己重写的逻辑块。但这里不一样，因为这里是创建BaseViewHolder的地方，也就是说此时我们根本没有ViewHolder实例，所以我们无法将这个创建逻辑通过BaseViewHolder进行抽象表征。 RecyclerView：我告诉你viewType，你给我创建一个ViewHolder实例。 Adapter：我可以创建，但我不知道你要哪种实例。你给我ViewHolder，我得问它。 RecyclerView：你不给我创建ViewHolder，我怎么给你？ Adapter：你不给我ViewHolder，我怎么创建？ 我们现在把具象的ViewHolder作为具象的逻辑载体；而实例化这些具象ViewHolder对象也属于具象的逻辑。这就好像是蛇咬住了自己的尾巴。 破局，再向上抽象一层ViewHolder能具象解决的是视图渲染和用户交互，不能解决的是自身实例的创建。所以我打算在ViewHolder的基础上再向上抽象一层，专门为了解决ViewHolder的实例化问题。而在Java中这种专门为了创建实例的方法，我们一般称之为工厂方法，所以我就打算BaseViewHolder里新建一个工厂类，同时各个子ViewHolder里都有对应的Factory来继承它，如下： 12345678910111213public interface Factory &#123; /** * 创建当前ViewHolder实例 */ @NonNull BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType); /** * 返回当前Factory对应的ItemType */ int getItemType();&#125; 抽象出来的工厂接口中有个getItemType方法，用以告诉Adapter当前ViewHolder对应的ItemType。 1234567891011121314151617181920212223@NonNullprivate final List&lt;? extends BaseViewHolder.Factory&gt; factories;public TargetAdapter(@NonNull List&lt;? extends BaseViewHolder.Factory&gt; factories) &#123; this.dataSource = new ArrayList&lt;&gt;(); this.factories = factories;&#125;@NonNull@Overridepublic BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; BaseViewHolder.Factory targetFactory = null; for (BaseViewHolder.Factory factory : factories) &#123; if (factory.getItemType() == viewType) &#123; targetFactory = factory; break; &#125; &#125; if (targetFactory == null) &#123; throw new RuntimeException("No factory found with viewType equals " + viewType); &#125; return targetFactory.onCreateViewHolder(parent, viewType);&#125; 在Adapter中就用当前项的ItemType来跟每个Factory返回的进行比对，看是否是当前ViewHolder能识别的，进而决定调用哪个Factory类的实例方法。 对应的，我们现在就可以把Adapter中创建ViewHolder的代码迁移到子类中去了，如下为AViewHolder的内部类： 12345678910111213public static class Factory implements BaseViewHolder.Factory &#123; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); final View itemView = inflater.inflate(R.layout.item_a, parent, false); return new AViewHolder(itemView); &#125; @Override public int getItemType() &#123; return 0; &#125;&#125; 同样的抽离方式，我们把另外几个类型（B、C、D）都添加如上的Factory类。 最难的问题，还是来了onCreateViewHolder方法已经解耦出去了，但马上便遇到另一个问题，每个Factory内都要返回一个ItemType，而返回的ItemType实际上是不能重复的，因为Adapter创建ViewHolder是根据ItemType来区分的。现在我们的ViewHolder虽然从Adapter抽离出来了，但是ViewHolder之间却还有这种相互制约的关系。我每新添加一个新类型的ViewHolder时都还需要看一下之前的ViewHolder里对应返回的ItemType以免冲突，这种方式着实很不方便，这个问题记为①先暂且放下。 除此之外我们还有第②个问题，那边是此时的Adapter还有最有一个未解耦也是最难解耦的方法——getItemType，我们再看下该方法此刻的代码： 123456789101112131415@Overridepublic int getItemViewType(int position) &#123; ItemData itemData = dataSource.get(position); switch (itemData.type) &#123; case "typeA": return TYPE_A; case "typeB": return TYPE_B; case "typeC": return TYPE_C; case "typeD": return TYPE_D; &#125; return TYPE_C;&#125; 我们可以看到这里的TYPE_A、TYPE_B等常量不仅在这里使用，而且还要跟抽取的Factory中返回的getItemType要对应上。 而这两个问题都是ItemType相关的逻辑，为了更加透彻的了解ItemType真实用意，我们来看下源码的解释： 123456789101112131415/** * Return the view type of the item at &lt;code&gt;position&lt;/code&gt; for the purposes * of view recycling. * * &lt;p&gt;The default implementation of this method returns 0, making the assumption of * a single view type for the adapter. Unlike ListView adapters, types need not * be contiguous. Consider using id resources to uniquely identify item view types. * * @param position position to query * @return integer value identifying the type of the view needed to represent the item at * &lt;code&gt;position&lt;/code&gt;. Type codes need not be contiguous. */public int getItemViewType(int position) &#123; return 0;&#125; 大意是说，它跟ListView里的getItemType不同的是，这里的ItemType可以是不连续的，但必须是唯一的，可以考虑使用id作为唯一标识。确实是很不错的建议，这样便能解决第一个ItemType冲突的问题。但是第二个问题依然解决不了，因为我还需要去做数据层的ItemData#type到View层的ItemType的关系映射。 很坦白的说，我在这个问题上思考了很久，我尝试在网上去寻找一些框架、源码、解决方案，但最终一无所获。 寻根溯源，从根本上解决我开始进行了很长一段时间的思维脑洞，促使我最终开始慢慢理清问题的脉络 Adapter为什么要有ItemType的概念，用来干什么？ 我们的RecyclerView有复用View的机制，同时RecyclerView中还可以包含不同种的类型的View，那在复用的时候，它需要一个表明当前数据项对应哪中类型View的标识，而这个标识便是ItemType。 ItemType在当前场景下的整条链路关系是怎样的？ 后端返回的是ItemData数据实体，该实体的type字段用以标识当前的类型 我们重写Adapter的getItemType方法，在这里做一层后端type字段到Adapter中ItemType的映射关系，然后告诉Adapter当前的ItemType Adapter用我们告诉它的ItemType来查找对应缓存的子ViewHolder是否足够使用，够则复用，不够则创建，而这里的创建便是onCreateViewHolder方法 无论创建还是复用，得到这个ViewHolder对象之后，都会再调用onBindViewHolder方法让我们进行页面渲染和事件绑定 据上，ItemType的根本作用就是唯一标识ViewHolder的类型，而实际上ItemData中的type已经是为了标识而存在的，我们重写Adapter的getItemType方法只是为了将type字段的字符串标识值翻译成int标识值以适配Adapter中关于ItemType的约定。既然如此，那我们为什么不把这层映射关系通过编码的方式实现来取代这种手动一对一映射的方式呢？ 于是，便有了下一个版本的Factory类： 12345678910111213public interface Factory &#123; /** * 创建当前ViewHolder实例 */ @NonNull BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType); /** * 返回当前Factory对应的ItemType标识 */ String getType();&#125; 现在我们的Factory不在依赖于一个具象写死且无含义的ItemType，而是对应一个带有语义的字符串，而且上面也提到，后端返回给我们的type其实就是一个字符串的值（如”typeA”,”typeB”…），这样我们就能解耦掉Adapter中的最后一个方法getItmeType了，现在的Adapter变动的代码如下： 123456789101112131415161718192021222324252627282930@NonNullprivate final List&lt;? extends BaseViewHolder.Factory&gt; factories;private final Map&lt;String, Integer&gt; type2ItemType = new HashMap&lt;&gt;();public TargetAdapter(@NonNull List&lt;? extends BaseViewHolder.Factory&gt; factories) &#123; this.dataSource = new ArrayList&lt;&gt;(); this.factories = factories; // 记录数据type与RecyclerView的ItemType之间的映射关系 for (int i = 0; i &lt; factories.size(); i++) &#123; BaseViewHolder.Factory factory = factories.get(i); type2ItemType.put(factory.getType(), i); &#125;&#125;@NonNull@Overridepublic BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; BaseViewHolder.Factory targetFactory = factories.get(viewType); if (targetFactory == null) &#123; throw new RuntimeException("No factory found with type equals " + viewType); &#125; return targetFactory.onCreateViewHolder(parent, viewType);&#125;@Overridepublic int getItemViewType(int position) &#123; ItemData itemData = dataSource.get(position); String type = itemData.type; return type2ItemType.get(type);&#125; 这里之所以要记录数据type和ItemType的映射关系，是因为我们需要在getItemViewType方法中知道type =&gt; ItemType的映射关系，进而将我们语义理解的type转为RecyclerView能够识别的ItemType。 与此对应的，子ViewHolder的Factory也需要做出细微的调整： 12345678910111213public static class Factory implements BaseViewHolder.Factory &#123; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); final View itemView = inflater.inflate(R.layout.item_a, parent, false); return new AViewHolder(itemView); &#125; @Override public String getType() &#123; return "typeA"; &#125;&#125; 渲染问题刚解决，通信问题又出现前面花费了很大的精力将ViewHolder从Adapter中解耦出来，已经完全解决了ViewHolder中View的渲染问题，但接踵而至的便是通信问题，比如，我在点击ViewHolder中的某一个子View的时候，我需要对应的Activity去做一些一些逻辑处理，或者说我需要在ViewHolder中取获取Activity的内部状态（如获取成员变量）。 注：我看过很多在ViewHolder等组件中直接通过将context强转成当前页面的Activity，然后调用其方法的写法，如果页面、业务逻辑不是复杂这个写法尚可，一旦变得复杂，这种写法是很不推荐的。业务主体类不要被其子组件显式调用，如果一定需要调用，那就替换为通过Callback来隐式调用的方式。否则就会出现，A类依赖B，B类依赖A这种相互依赖依赖的关系，会让逻辑变得异常混乱；而且如果子组件要被复用时，代码中的这种强转+显式调用的代码将成为抽取抽象逻辑时很大的一个坑。 该问题出现的根本原因，其实并不是我们解耦的ViewHolder导致的，对于一个普通的Activity =&gt; Adapter =&gt; ViewHolder这样的调用链而言也一样会存在该问题。只不过我们的设计结构在这条链路上多添加了一个Factory的节点而已，添加之后的链路变成了Activity =&gt; Adapter =&gt; Factory =&gt; ViewHolder。所以我们需要一个上下文类，来穿透这条调用链路，然后ViewHolder中触发的事件便可以通过该上下文类将事件透传到Activity中去。这样描述起来可能会写生硬，下面直接看代码 123456789101112131415161718192021222324252627282930// 定义上下文类public interface HolderContext &#123; /* A被点击时触发 */ void onClickA();&#125;// Activity中实现HolderContext接口并将实现类传递给AdapterHolderContext holderContext = new HolderContext() &#123; @Override public void onClickA() &#123; Toast.makeText(MainActivity.this, "Click Item A", Toast.LENGTH_SHORT).show(); &#125;&#125;;new TargetAdapter(holderContext, Collections.singletonList(new AViewHolder.Factory()));// Adapter将holderContext传递给Factoryreturn targetFactory.onCreateViewHolder(holderContext, parent, viewType);// AViewHolder构造时，将该参数传递进来return new AViewHolder(itemView, holderContext);// AViewHolder中监听到点击事件后，通过HolderContext将事件透传出去@Overridepublic void onClick(View v) &#123; holderContext.onClickA();&#125; 这样一整条链路便串联起来了，ViewHolder与Activity的通信就直接通过HolderContext即可完成，而不需要Adapter和Factory的任何额外处理。这条链路的传递看起来很长、很复杂，但其实这层传递只需要写一遍，后续拓展如果再需要添加一个BViewHolder的事件，只需要在HolderContext中添加一个onClickB方法，并在Activity中实现即可。 端上结构设计已解耦，数据再解耦到了这里，基于结构设计的维度，Adapter中已经不再是与业务耦合的类了，但是当前类还包含ItemData这个数据类，我想把该类再进行一层抽象，从而让Adapter完全与业务无关，因为只要使得它完全与业务无关，我才能进对于该类进行抽象，做成了抽象也就意味着通用。 接下来把ItemData替换为如下的IType接口： 1234public interface IType &#123; @NonNull String getType();&#125; 接下来把Adapetr中出现ItemData的地方全部替换为IType即可 收官，最终的模样前面都是以遇到的问题为线索逐一进行解决，下面可以看下Adapter最终的代码结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class TargetAdapter extends RecyclerView.Adapter&lt;BaseViewHolder&gt; &#123; @NonNull private final List&lt;IType&gt; dataSource; @NonNull private final HolderContext holderContext; @NonNull private final List&lt;? extends BaseViewHolder.Factory&gt; factories; private final Map&lt;String, Integer&gt; type2ItemType = new HashMap&lt;&gt;(); public TargetAdapter(@NonNull HolderContext holderContext, @NonNull List&lt;? extends BaseViewHolder.Factory&gt; factories) &#123; this.holderContext = holderContext; this.dataSource = new ArrayList&lt;&gt;(); this.factories = factories; for (int i = 0; i &lt; factories.size(); i++) &#123; BaseViewHolder.Factory factory = factories.get(i); type2ItemType.put(factory.getType(), i); &#125; &#125; @Override public int getItemViewType(int position) &#123; IType iType = dataSource.get(position); String type = iType.getType(); return type2ItemType.get(type); &#125; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; BaseViewHolder.Factory targetFactory = factories.get(viewType); if (targetFactory == null) &#123; throw new RuntimeException("No factory found with type equals " + viewType); &#125; return targetFactory.onCreateViewHolder(holderContext, parent, viewType); &#125; /** * 数据刷新 * * @param dataSource 数据源 */ public void setDataSource(@Nullable List&lt;IType&gt; dataSource) &#123; this.dataSource.clear(); if (dataSource != null) &#123; this.dataSource.addAll(dataSource); &#125; notifyDataSetChanged(); &#125; /** * 数据添加 * * @param dataSource 数据源 */ public void addDataSource(@Nullable List&lt;IType&gt; dataSource) &#123; if (dataSource != null &amp;&amp; !dataSource.isEmpty()) &#123; this.dataSource.addAll(dataSource); notifyDataSetChanged(); &#125; &#125; @Override public void onBindViewHolder(@NonNull BaseViewHolder holder, int position) &#123; IType itemData = dataSource.get(position); holder.onBindData(itemData); &#125; @Override public int getItemCount() &#123; return dataSource.size(); &#125;&#125; 到了这一步，Adapter中不再冗余任何具象业务逻辑的代码，这也就意味着该类不再是基于当前业务维度的类，而是一个解耦掉ViewHolder且从具象业务逻辑中泛化出来的抽象类，所以对于任何需要添加多个ItemType的Recycler.Adapter场景均可基于该类进行添加。 痛点不再痛回顾以上提到的两个痛点，维护性和拓展性，现在就开始基于本文最开始业务场景进行类型E这种Type进行拓展，来看下对应的代码改动： 1. 添加一个独立的EViewHolder类1234567891011121314151617181920212223242526272829303132333435363738public class EViewHolder extends BaseViewHolder implements View.OnClickListener &#123; private final TextView textView; public EViewHolder(View itemView, HolderContext holderContext) &#123; super(itemView, holderContext); textView = itemView.findViewById(R.id.item_text_e); textView.setOnClickListener(this); &#125; @Override public void onBindData(IType iType) &#123; ItemData data = (ItemData) iType; textView.setText(data.textE); &#125; @Override public void onClick(View v) &#123; Toast.makeText(context, "Click Item E", Toast.LENGTH_SHORT).show(); &#125; public static class Factory implements BaseViewHolder.Factory &#123; @NonNull @Override public BaseViewHolder onCreateViewHolder(@NonNull HolderContext holderContext, @NonNull ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view = inflater.inflate(R.layout.item_e, parent, false); return new EViewHolder(view, holderContext); &#125; @Override public String getType() &#123; return "typeE"; &#125; &#125; &#125; 2. 注册EViewHolder.Factory1234567adapter = new BaseAdapter(holderContext, Arrays.asList( new AViewHolder.Factory(), new BViewHolder.Factory(), new CViewHolder.Factory(), new DViewHolder.Factory(), new EViewHolder.Factory())); 是的，仅此两步就已经结束了！ 回顾最开始提到的低耦合高内聚的原则，再对比一下在解耦前后来新添加EViewHolder对应的代码改动。 关于耦合，整个Activity与EViewHolder唯一耦合的地方只有一处绑定关系的代码：new EViewHolder.Factory()，而如果业务上有临时变更不需要展示EViewHolder项，只需要注释掉该行代码即可（Adapter需要添加通用的边界处理逻辑，不赘述）。 关于内聚，对比最开始的结构，每种类型的ViewHolder代码都是散落在Adapter中的各个地方：ItemType的声明写在Adapter的常量中，ViewHolder的创建写在了onCreateViewHolder方法中，ViewHolder的渲染写在了onBindViewHolder中，后端数据的type到ItemType的映射写在了getItemType中。而解耦之后，这里所有与ItemType有关的具象业务逻辑全部都内聚在EViewHolder.java一个文件中了。 至此，Adapter解耦的一整套链路全部已经打通了。 总结由于本文整篇较长，所以这里再做一下前面核心脉络的回顾： 开发痛点是拓展性和维护性不够好，而基于这两者再进行分析，可归纳为一点——Adapter与ViewHolder之间的耦合性太强，所以明确接下来的目的就是解耦Adapter与ViewHolder 接下来便开始解耦Adapter中最关键的三个方法：onBindViewHolder、onCreateViewHolder、getItemType 解耦onBindViewHolder通过抽象BaseViewHolder的方式解决 解耦onCreateViewHolder通过ViewHolder中新建Factory方式解决 解耦getItemType通过将最开始的Factory中的getItemType返回具象ItemType的方式替换为getType返回数据层面的type的方式解决 然后进行数据层的抽象，将ItemData业务实体替换为Adapter关注的IType抽象接口 最后进行业务层的业务层的彻底剥离，将所有业务无关项进行Base类统一抽象 Github源码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>代码设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的优化原理]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-RecyclerView-Theory%2F</url>
    <content type="text"><![CDATA[Android端Native业务开发中涉及到列表的场景时，我们最先想到的就是使用RecyclerView或ListView（两者基本原理是相通的，以下均以RecyclerView为例说明），这篇文章将尝试通过基于一个具体场景来说明RecyclerView内部的优化原理。 全量加载替换为逐项懒加载为了对比说明RecyclerView的优势，这里以LinearLayout作为参考进行对比。 在列表场景中，我们使用RecyclerView来代替LinearLayout，是因为前者通过对单项ItemView进行加载的方式来渲染整个页面，而不是基于整个页面进行一次性渲染。 举个例子，假如一个页面需要加载有100项的列表，其中每一项加载耗时需要5ms。如果使用传统的LinearLayout，一次性全部加载的时间就是100 * 5ms = 500ms，500ms加载时间对于用户而言是什么？以Android系统为了使得用户能在端上拥有60FPS的体验，而做出的每过1s / 60FPS ≈ 16ms发出一个VSYNC信号进行UI刷新为准，500ms就意味着在加载这个列表时将出现(500ms - 16ms) / 16ms ≈ 30帧的丢失，而用户感受到的就是当前列表加载时非常卡顿。而如果使用RecyclerView方式进行进行渲染，则每项渲染时间为5ms，两项渲染的间隙里仍然可以进行VSYNC对应的UI刷新操作，这种场景下几乎不会造成丢帧现象。 除此之外，RecyclerView对单项进行加载并非简单地从1次加载100项拆分为100次加载各加载1项，它在此基础上还做了懒加载的操作，即只有当用户界面滑动到当前项时才会进行加载。 举个例子，用户手机一屏最多能展示10项时，此时RecyclerView便只会渲染10次，每次渲染1项。当用户往下滑动到第11项准备要“露出来”的时候，RecyclerView才会渲染第11项，剩下的89项也是同样的加载方式。这样的设计带来的好处同常用的懒加载类似，就是将短时间内的密集型任务进行离散化分配，尽可能降低CPU的压力。 该特性是RecylerView内部实现的，面向开发者是透明的 ItemView复用仅仅单项懒加载还不够，还要更快，这时我们需要将矛头指向耗时操作的罪魁祸首——LayoutInflater#inflate。在这一步中，Android系统会去解析layout.xml的资源文件，然后还可能会进行一系列的反射操作来实例化View，这一步的操作相较于View信息的填充而言，是尤为耗时的。而对于100项的列表，如果我们每次都去进行inflate操作的话，也将会对运行性能带来不少压力。 RecyclerView对应该问题解法就是复用，它内部会有个mCachedViews的缓存变量，可以抽象理解为里面存储着每一个创建的子View，每次渲染子View时如果缓存中有未使用的子View会优先从缓存中取，当缓存的View不足以界面展示时，它就会再去创建新View并添加进去。 比如，总共需要展示100项，一屏显示10项，此时缓存中包含10个子View。 当滑动到第11项时，发现缓存的10项全部用来UI展示，没有未使用的子View，此时便再创建一项子View并放到缓存中 当滑动到第12项时，此时第1项已经完全从屏幕上方滑到屏幕显示之外了，该项便是未使用的子View，此时RecylerView会直接复用该项来渲染第12项 后续项的加载都会隶属于上面的两种情况 注：该特性也是RecyclerView内部实现的，一样不需要开发者额外处理；而更早设计的ListView会不存在该特性的，我们开发者一般会通过View#setTag方式来手动实现该特性。这也是为什么RecyclerView的官方Api中直接显式的提出ViewHolder概念而ListView中并未有任何ViewHolder概念（ListView的ViewHolder是我们开发中手动加入的）的原因。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于深度学习的文本生成过程]]></title>
    <url>%2F2018%2F08%2F10%2FML-Text-Generator%2F</url>
    <content type="text"><![CDATA[前言：基于RNN的文本生成器涉及到很多知识点，本文结合一个比较小的例子进行整个生成模型的流程总结，只涉及思路，不包含算法和代码，目的是理清整个预处理、训练、生成预测的流程。 例子1这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。 这里选择了电影《大鱼海棠》中一句很经典的台词作为示例，进行整个流程的总结。最终的目的是让我们的模型能够自动生成该句子。 数据预处理在目前深度学习框架如同雨后春笋般萌生的时代里，深度学习模型的搭建本身不再是高门槛的事情，相比之下数据预处理却是一个尤为重要且直接关系到最终生成结果的一环。 分词一句话，一篇文章，我们要训练它，首先需要把它变成结构化、计算机可理解的序列。 这里我们就需要将上面的这段话进行拆分为很多个词，以供下一步处理。而我们常用的拆词有两种方式，基于char和基于word（对应到中文就是基于字和基于词），下面将展开说明两种拆词方式。 基于char分词最直观的看这种拆词方式，直接看拆分的结果： 1['这', '短', '短', '的', '一', '生', '，', '我', '们', '最', '终', '都', '会', '失', '去', '。', '你', '不', '妨', '大', '胆', '一', '些', '，', '爱', '一', '个', '人', '，', '攀', '一', '座', '山', '，', '追', '一', '个', '梦', '。'] 这种方式中的一个字、一个标点符号、一个空格、一个换行符，都是一个独立的词，我们都要进行统计。同时，在拆词时我们还需要对每个词进行词频统计并按照词频从高到低进行排序，以供接下来的去词使用，我们统计得出如下的结果 基于word分词基于词进行拆分的方式是指拆分后的句子中会直接包含一些词语而非单字。对于英文就是一个单词，对于中文可以是一个字，也可以是一个词语。如果是一个词语，那该词语一定是确实有含义的而非任意进行组合。比如基于该示例进行的拆词结果： 1['这', '短短的', '一生', '，', '我们', '最终', '都', '会', '失去', '。', '你', '不妨', '大胆', '一些', '，', '爱', '一个', '人', '，', '攀', '一座', '山', '，', '追', '一个', '梦', '。'] 对应的词频统计如下 去词在本示例汇总，去词步骤是可以省略的，因为总次数特别少。但对于几百M、甚至几十G的文本而言，该步骤会显得尤为重要。如果一本小说中有5000个字（去重后），但可能其有1000个词只出现过10次以下的，这部分词我们需要剔除掉，因为对于整个庞大的数据集而言这种低频次的词是可以忽略不计的。从这个维度来说只能说明保留低频词的不必要性，而实际上，我们还需要从另一维度来说明取出低频词的必要性，那就是防止维度爆炸，关于这一点会在后面提到。 数据映射上面提到我们需要将数据转化为计算机可理解的序列，而实际上仅仅将句子转化为词的层面上，还是不够的。我们需要对词在进行数字形式的离散化，以便后面我们的模型能够进行识别。 这里我们就以上面基于char分词的结果进行映射选择，我们的词和数字索引的映射关系是这样的： 1234567891011121314151617181920212223242526272829"一": 0"，": 1"短": 2"个": 3"。": 4"都": 5"追": 6"这": 7"胆": 8"终": 9"的": 10"生": 11"爱": 12"梦": 13"最": 14"攀": 15"我": 16"座": 17"山": 18"妨": 19"失": 20"大": 21"去": 22"你": 23"会": 24"们": 25"人": 26"些": 27"不": 28 该映射关系非常重要，将纵向贯穿到接下来的数据处理、模型训练和最后的模型预测的整个流程。由于该映射关系是标识词 =&gt; 词索引的，所以我们简称之为word2index；相反的，我们还需要一个词索引 =&gt; 词的反向映射关系，即0: &quot;一&quot;, 1: &quot;，&quot;, 2: &quot;短&quot;, …这种形式的映射关系，我们简称之为index2word。 数据对齐宏观来说，RNN模型是专门用来处理序列数据的，它最大的优势就是能够打破普通神经网络中维度固定的限制；但微观来说，RNN模型的基本单元又是一个个基本的神经元组成的，所以更小范畴内来看，在数据处理方面还是需要对训练数据进行数据对齐操作的。 具体的对齐操作是指我们根据指定长度（比如5）的词作为输入，前面不足该长度的用起始符（这里用【）代替，该输入序列的下一词会作为对应的输出，然后再结合该输出作为下次预测的输入继续进行预测，直到预测到结束符（这里用】标识）为止，便完成了一整个预测流程。 12345678910111213141516171819202122232425262728293031323334353637383940['【', '【', '【', '【', '【'] =&gt; '这'['【', '【', '【', '【', '这'] =&gt; '短'['【', '【', '【', '这', '短'] =&gt; '短'['【', '【', '这', '短', '短'] =&gt; '的'['【', '这', '短', '短', '的'] =&gt; '一'['这', '短', '短', '的', '一'] =&gt; '生'['短', '短', '的', '一', '生'] =&gt; '，'['短', '的', '一', '生', '，'] =&gt; '我'['的', '一', '生', '，', '我'] =&gt; '们'['一', '生', '，', '我', '们'] =&gt; '最'['生', '，', '我', '们', '最'] =&gt; '终'['，', '我', '们', '最', '终'] =&gt; '都'['我', '们', '最', '终', '都'] =&gt; '会'['们', '最', '终', '都', '会'] =&gt; '失'['最', '终', '都', '会', '失'] =&gt; '去'['终', '都', '会', '失', '去'] =&gt; '。'['都', '会', '失', '去', '。'] =&gt; '你'['会', '失', '去', '。', '你'] =&gt; '不'['失', '去', '。', '你', '不'] =&gt; '妨'['去', '。', '你', '不', '妨'] =&gt; '大'['。', '你', '不', '妨', '大'] =&gt; '胆'['你', '不', '妨', '大', '胆'] =&gt; '一'['不', '妨', '大', '胆', '一'] =&gt; '些'['妨', '大', '胆', '一', '些'] =&gt; '，'['大', '胆', '一', '些', '，'] =&gt; '爱'['胆', '一', '些', '，', '爱'] =&gt; '一'['一', '些', '，', '爱', '一'] =&gt; '个'['些', '，', '爱', '一', '个'] =&gt; '人'['，', '爱', '一', '个', '人'] =&gt; '，'['爱', '一', '个', '人', '，'] =&gt; '攀'['一', '个', '人', '，', '攀'] =&gt; '一'['个', '人', '，', '攀', '一'] =&gt; '座'['人', '，', '攀', '一', '座'] =&gt; '山'['，', '攀', '一', '座', '山'] =&gt; '，'['攀', '一', '座', '山', '，'] =&gt; '追'['一', '座', '山', '，', '追'] =&gt; '一'['座', '山', '，', '追', '一'] =&gt; '个'['山', '，', '追', '一', '个'] =&gt; '梦'['，', '追', '一', '个', '梦'] =&gt; '。'['追', '一', '个', '梦', '。'] =&gt; '】' 上面的映射关系是为了便于我们理解而写的形式，而实际上提供给我们模型学习的数据是通过上面的word2index映射的数据。如下： 1234567['39', '39', '39', '39', '39'] =&gt; ' 7'['39', '39', '39', '39', ' 7'] =&gt; ' 2' . . .[' 1', ' 6', ' 0', ' 3', '13'] =&gt; ' 4'[' 6', ' 0', ' 3', '13', ' 4'] =&gt; '40' 由于index形式的数据可读性不好，就不一一展示出来了。 注：word形式的数据到index形式的数据需要特别注意的一点是，【和】这两个标识符在word2index中是没有对应的index的，这个时候需要我们来约定一种映射关系：起始符对应总词数，结束符对应总词数 + 1。比如对于本例公有有39个词，那词索引范围就是0-38，此时起始符就对应总词数39，结束符就对应总次数39+1=40。 模型训练数据供给方式数据供给是指预处理后的数据供给模型进行训练，一般的数据供给的方式有两种：全量供给和基于生成器的供给。 全量顾名思义，全量供给是指一次性把所有的数据全部提供给模型，告诉模型如何每次吃下多少（batch_size）条数据，然后模型自己会每次从中去取。 该方式的好处是数据供给方便，不需要过多的计算steps_per_epoch和batch_size的关系；缺点就是会占用全量训练数据的内存，所以对于小数据集的数据推荐使用该方式。 生成器基于生成器模式的数据提供，它实际上是采用了懒加载的方式，模型通过迭代来取到下一batch的数据，生成器方式的数据供给可以通过Python语言的yield关键词来配合完成。 由于数据是懒加载的，因此该方式的好处是极大程度节省内存占用；当然对应的缺点就是实现的成本要高于前者，且需要计算出steps_per_epoch来间接告诉模型总数据量。（在CV方向的DL模型中基本上都会使用该方式。） 模型预测初始数据模型预测时可以选择一个”引子”作为模型初始状态的上下文，比如把”这短短的一”；当然也可以不选择，让模型自动预测，以作为下次迭代的上下文。 预测和模型训练时不同的是，预测时我们只需要把batch_size设置为1即可，因为我们只需要预测当前的上下文出现的下一个词。 结果选择模型最终预测的结果是一个(n_words + 2, )形式的numpy数组，其中每个元素就代表预测下一个词（或者是起始/结束符）的概率值。比如[0.1, 0.03, 0.7, ...]就表示0的概率是0.1，1的概率是0.03，2的概率是0.7，这里的0、1、2对应的就是预处理阶段的词索引，即对应一个词。 此时我们一般会按照预测的词概率进行选词，而非直接去选择概率最高的那个词。因为模型训练后的参数是固定的，如果”引子”数据也是固定的，那直接选择概率最高的词就会导致每次预测的结果是完全一样的，这有悖于我们要希望生成样本多样性的初衷。 迭代预测与预处理阶段的方式相同，我们每次都会将当前这次的输出结果并入到下次预测的输入，从而进入下次预测。比如当前的上下文是这短短，对应的预测结果是的，那下一次预测的上下文就是这短短的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化处理浏览器任务]]></title>
    <url>%2F2018%2F08%2F02%2FPython-Selenium%2F</url>
    <content type="text"><![CDATA[在日常工作当中，我们经常会和浏览器打交道，当然就可能会在浏览器上做一些重复、无脑的工作，这篇文章旨在对于这类问题出一个基于脚本的自动化解决方案。 Selenium库简要一句话概括，Selenium就是一个浏览器自动化测试框架。它支持包括IE、Chrome、Mozilla Firefox、Mozilla Suite在内的大多数主流浏览器。当然本文主要讲述的并不是关于它在自动化测试部分方面的运用，该部分在Selenium官网和网上各种Blog处均有很多也很详细的介绍，这里我们要说的是基于它的浏览器控制能力来演化出的另一个应用方向——自动化处理任务。 快速开始安装首先，在拥有python环境的os中命令行执行 pip install selenium 来安装Selenium库。（Mac os直接安装时可能会出现权限问题，此时尝试命令前面添加sudo，还不行时则需要尝试通过创建Python沙盒的方式来安装。） 其次，下载一个跟自己浏览器和版本对应的webdriver，然后将该文件配置在环境变量下。比如Chrome浏览器的webdriver就在这里下载。这里需要注意下载的webdriver版本不是越新越好，而是要下载跟自己浏览器版本匹配的。我首次安装时在这里踩过坑。具体查看匹配的方式是打开Chrome =&gt; 点击菜单Chrome =&gt; 关于Google Chrome，在该界面能看到自己浏览器的版本。然后进入在上面的下载页面找到与自己版本匹配的webdriver，具体比较的地方在此处 最后测试下是否配置正确，终端打开一个新窗口，输入命令chromedriver -v执行，如果配置没问题，此时便能看到webdriver的版本号，如下 123➜ ~ cd Documents/libs ➜ libs chromedriver -vChromeDriver 2.38.552518 (183d19265345f54ce39cbb94cf81ba5f15905011) 快速开始环境配置完成之后，来通过一个简单的百度搜索然后进入Selenium官网的Demo来看看Selenium的实际运行效果。新建client_selenium.py脚本文件，然后执行添加如下代码 1234567891011121314151617181920# coding=utf-8from selenium import webdriverimport time# 创建一个webdriver实例, 并打开百度页面browser = webdriver.Chrome()browser.get('https://www.baidu.com')# 找到搜索框组件, 并输入关键词"selenium"element_input = browser.find_element_by_id('kw')element_input.send_keys('selenium')# 找到搜索按钮, 并指定点击操作element_search = browser.find_element_by_xpath('//*[@value="百度一下"]')element_search.click()time.sleep(1)# 找到selenium官网的链接, 并点击进入element_target = browser.find_element_by_xpath('//*[contains(text(), "Web Browser Automation")]')element_target.click() 执行该python文件后，脚本会通过webdriver来去驱动浏览器进行一系列的打开、输入、点击等操作，如下图 常用apiSelenium库具有很丰富的api，但对于只需要写任务处理脚本而言，我们只需要了解一些比较核心高频的api，下面列举出常用的api 操作 api 说明 输入 send_keys(&#39;Hello&#39;) 输入文本 点击 click() 执行点击 查找元素 find_element_by_id() 根据ID进查找 查找元素 find_element_by_name() 根据name查找 查找元素 find_element_by_tag_name() 根据标签查找 查找元素 find_element_by_link_text() 根据链接文本查找 查找元素 find_element_by_class_name() 根据class名查找 查找元素 find_elements_by_css_selector() 根据css选择器查找 查找元素 find_elements_by_xpath() 根据xpath语法查找 可以看到，其中Selenium库包含丰富的元素查找相关的api，找到对应的元素是对该元素进行操作的基础，所以能否快速、便捷、精准的查找到目标元素至关重要。 这里着重强调一下find_elements_by_xpath函数，该函数是基于XPath语法规范进行查找元素的，该规范在爬虫开发、浏览器脚本、XML配置查找等方面的使用时相当高频的。实际上，上面的所有查找方法都可以通过该方法进行替代。 应用（涉及到公司业务保密，这里就不展示出来了） 拓展用原生Selenium的Api写过一个应用之后，虽然感觉它的Api不算复杂，但对于我们只想写一个自动化脚本而言，还是不够简练，毕竟它的Api的初衷是给为了做浏览器自动化测试使用的。 而我想要的效果就是，更简单，尽可能一行代码执行一个Action，而一个自动化脚本就是包含多个Action的一个Robot。于是就基于Selenium库封装了很薄的一层selenium-robot库，然后发布到pypi仓库里。 以最上面的访问Selenium官网的那个Demo来比较，用selenium-robot来实现出来的是这样的 12345678910from selenium_robot.actions import *from selenium_robot import Robotbrowser = webdriver.Chrome()Robot( Open('https://www.baidu.com'), Input('wd', 'selenium'), Click('百度一下'), Click('Web Browser Automation')).setup(browser) 代码量减少了一半多，最终运行的效果是一样的，对于自动化脚本的开发可以更加便捷、高效。 总结总的来说，基于上面的Selenium库，我们还能开发出很多自动化脚本： 可以把工作中重复的配置操作通过该方式完成，这种工作在运营人员面前应该不少，比如要配置N个活动，每天配置广告Banner，配置公告信息等； 可以结合某些xml解析库进行爬虫开发，而且这种爬虫是基于浏览器驱动进行数据爬取的，而非像Scrapy等这种基于纯数据角度的爬虫框架一样。人家是模拟浏览器请求，Selenium模拟都不模拟了，自己干脆直接驱动浏览器，这样几乎不会被反爬工具监测到； 脑洞再大一些，甚至还可以写网页版游戏的外挂等等。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python拼接微信好友头像大图]]></title>
    <url>%2F2018%2F07%2F31%2FPython-Wechat-Avatar%2F</url>
    <content type="text"><![CDATA[基于itchat库来获取微信好友头像并执行拼接操作，对微信上文字化好友列表数据进行可视化展示。 获取好友头像123456789101112131415161718192021def save_avatar(folder): """ 保存微信好友头像 :param folder: 保存的文件夹 """ itchat.auto_login(hotReload=True) users = itchat.get_friends() or [] print('%d friends found.' % len(users)) if not os.path.exists(folder): os.makedirs(folder) index = 1 for i, user in enumerate(users): nickname = user.RemarkName username = user.UserName file_path = os.path.join(folder, '%03d_%s.png' % (i, nickname)) if not os.path.isfile(file_path): # 不重复下载 avatar = itchat.get_head_img(username) with open(file_path, 'w') as f: f.write(avatar) print('Download %d: %s' % (index, file_path)) index += 1 这里只需要传入一个保存头像的文件夹即可，运行itchat.auto_login(hotReload=True)后会弹出微信扫码界面让你授权微信登录，以便接下来的好友数据获取。 在图片下载时，我添加了一个防止重复下载的判断，以免多次运行时每次都要重新进行头像的下载。 取出待拼接头像1234567891011def get_image_files(folder, filters=None): """ 取出待拼接头像 :param folder: 目标文件夹 :param filters: 需要过滤的图片 :return: 头像路径 """ filters = filters or [] filenames = [os.path.join(folder, sub) for sub in os.listdir(folder) if sub.endswith('.png') and not filters.__contains__(sub)] return filenames 这里单独写个方法是为了把过滤的逻辑封装进来，以便于去掉指定的微信好友的头像（比如纯色的头像在拼接之后的大图看上去很明显，非强迫症可忽略）。 计算拼接的排列123456789101112def calculate_align_way(image_num, force_align=False): """ 计算图片排版对齐方式 :param image_num: 图片数量 :return: (rowls, columns) """ actual_value = image_num ** 0.5 suggest_value = int(actual_value) if actual_value == suggest_value or force_align: return suggest_value, suggest_value else: return suggest_value, suggest_value + 1 因为需要知道最终拼接图片的行列数，所有这里单独定义一个计算方法。算法就是直接对图片总数开根号，取出的结果如果正好是整数，就直接返回该结果。如果不是整数（大多数情况都如此），则根据参数force_align来决定是否强制进行正好全部铺满的显示。如果设为True，能强制铺满，但会有部分好友未显示完全；反之则是相对的情况。后面发现拼接图片最后一行有很多黑色空位时，只需要更改该参数为True即可。 拼接1234567891011121314151617181920212223242526272829def join_images(image_files, rows, cols, width, height, save_file=None): """ 拼接操作 :param image_files: 待拼接的图片 :param rows: 行数 :param cols: 列数 :param width: 每张小头像的宽度 :param height: 每张小头像的高度 :param save_file: 拼接好图片的保存路径 """ canvas = np.ones((height * rows, width * cols, 3), np.uint8) for row in range(rows): for col in range(cols): index = row * cols + col if index &gt;= len(image_files): break file_path = image_files[index] im = Image.open(file_path) im = im.resize((width, height)) im_data = np.array(im) if len(im_data.shape) == 2: im_data = np.expand_dims(im_data, -1) x = col * width y = row * height canvas[y: y + height, x: x + width, :] = im_data image = Image.fromarray(canvas) image.show() if save_file: image.save(save_file) 拼接图片调用的是科学计算包numpy和图片库PIL，主要就是对ndarray进行操作。 最终将上面的步骤全部串联起来，执行如下主函数，便得到上面的拼接图片。 1234567891011121314FOLDER = 'avatars'if __name__ == '__main__': # 保存所有好友头像 save_avatar(FOLDER) # 取到准备拼接的头像 image_files = get_image_files(FOLDER) # 计算拼接的行列 rows, columns = calculate_align_way(len(image_files), force_align=True) # 执行拼接操作 join_images(image_files, rows, columns, 64, 64, 'result.png') Github源码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
        <tag>itchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio高频Postfix总结]]></title>
    <url>%2F2018%2F07%2F31%2FAndroid-Studio-Postfix%2F</url>
    <content type="text"><![CDATA[var声明 null判空 notnull判非空 nn判非空 for遍历 fori带索引的遍历 not取反 if条件判断 cast强转 return返回值]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>高效开发</tag>
        <tag>Android Sutdio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java、Groovy、JavaScript、Python各语言对比]]></title>
    <url>%2F2018%2F07%2F30%2FProgram-Language-Contrast%2F</url>
    <content type="text"><![CDATA[Get startJava12345public class Client &#123; public static void main(String[] args)&#123; System.out.println("Hello, world."); &#125;&#125; Groovy123static void main(String[] args) &#123; println('Hello, world.')&#125; JavaScript1console.log("Hello, world."); Python12if __name__ == '__main__': print('Hello, world.') 字符串Java12345678910111213public class Client &#123; public static void main(String[] args) &#123; String a = "Hello"; // 截取 (Hel) System.out.println(a.substring(0, 3)); // 转化 (123) System.out.println(String.valueOf(123)); // 拼接 (Hello, world.) System.out.println(a + ", world."); // 格式化 (Hello, I am 10.) System.out.println(String.format("%s, I am %d.", a, 10)); &#125;&#125; Groovy1234567891011static void main(String[] args) &#123; def a = "Hello" // 截取 (Hel) println(a[0..3]) // 转化 (123) println(String.valueOf(123)); // 拼接 (Hello, world.) println(a + ", world.") // 格式化 (Hello, I am 10.) println("$&#123;a&#125;, I am $&#123;10&#125;.")&#125; JavaScript123456789let a = "Hello";// 截取 (Hel)console.log(a.substr(0, 3));// 转化 (123)console.log(String(123));// 拼接 (Hello, world.)console.log(a + ", world.");// 格式化 (Hello, I am 10.)console.log(`$&#123;a&#125;, I am $&#123;10&#125;.`); Python12345678910111213# coding=utf-8if __name__ == '__main__': a = "Hello" # 截取 (Hel) print(a[0:3]) # 转化 (123) print(str(123)) # 拼接 (Hello, world.) print(a + ", world.") # 格式化 (Hello, I am 10.) print("%s, I am %d." % (a, 10)) # or print("&#123;&#125;, I am &#123;&#125;.".format(a, 10)) 时间格式化Java12345678910111213public class Client &#123; public static void main(String[] args) &#123; // 当前时间戳 (1532955845305) long currentTimeMillis = System.currentTimeMillis(); System.out.println(currentTimeMillis); // 格式化处理 (2018-07-30 21:04:05) DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); LocalDateTime now = LocalDateTime.now(); String format = formatter.format(now); System.out.println(format); &#125;&#125; Groovy1234567891011static void main(String[] args) &#123; // 当前时间戳 (1532956684952) def currentTimeMillis = System.currentTimeMillis() println(currentTimeMillis) // 格式化处理 (2018-07-30 21:18:05) def formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss") def now = LocalDateTime.now() def format = formatter.format(now) println(format)&#125; JavaScript12345678910111213141516171819202122// 当前时间戳 (1532956509000)let currentTimeMillis = Date.parse(new Date());console.log(currentTimeMillis);// 格式化处理 (2018-07-30 21:15:09)Date.prototype.Format = function (fmt) &#123; let o = &#123; "M+": this.getMonth() + 1, // 月 "d+": this.getDate(), // 日 "h+": this.getHours(), // 时 "m+": this.getMinutes(), // 分 "s+": this.getSeconds(), // 秒 "q+": Math.floor((this.getMonth() + 3) / 3), // 季度 "S": this.getMilliseconds() // 毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (let k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;;let format = new Date().Format("yyyy-MM-dd hh:mm:ss");console.log(format); Python12345678910import timeimport datetimeif __name__ == '__main__': # 当前时间戳 (1532957083) print(int(round(time.time()))) # 格式化处理 (2018-07-30 21:24:43) format = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') print(format) 函数Java12345678910public class Client &#123; public static void main(String[] args) &#123; int result = plus(1, 2); System.out.println(result); &#125; private static int plus(int a, int b) &#123; return a + b; &#125;&#125; Groovy123456789static void main(String[] args) &#123; def result = plus 1, 2 println(result)&#125;static def plus(int a, int b) &#123; // 最后一行return可省略 return a + b&#125; JavaScript123456function plus(a, b) &#123; return a + b;&#125;let result = plus(1, 2);console.log(result); Python123456def plus(a=0, b=0): return a + bif __name__ == '__main__': result = plus(1, 2) print(result) 列表Java1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; // 新建 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加 list.add("a"); list.add("b"); list.add("c"); // 移除 list.remove("c"); // 查询 String first = list.get(0); // 拼接 List&lt;String&gt; added = Arrays.asList("m", "n"); list.addAll(added); // 遍历 for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125; Groovy12345678910111213141516171819202122232425static void main(String[] args) &#123; // 新建 &amp; 添加 def list = ['a', 'b'] // 添加 list &lt;&lt; 'c' // 移除 list -= 'c' // 查询 def first = list[0] // 拼接 def added = ['m', 'n'] list += added // [a, b, m, n] println(list) // 遍历 for (i in list) &#123; println(i) &#125; // or list.each &#123; println(it) &#125;&#125; JavaScript123456789101112131415161718192021// 新建 &amp; 添加let list = ['a', 'b'];// 添加list.push('c');// 移除list = list.filter(s =&gt; s !== 'c');// 查询let first = list[0];// 拼接let added = ['m', 'n'];list = [...list, ...added];// or// list = list.concat(added);// [a, b, m, n]console.log(list);// 遍历for (let i = 0; i &lt; list.length; i++) &#123; console.log(list[i]);&#125; Python1234567891011121314151617181920212223242526# coding=utf-8if __name__ == '__main__': # 新建 &amp; 添加 list = ['a', 'b'] # 添加 list.append('c') # 移除 del list[2] # or # list.remove('c') print(list) # 查询 first = list[0] # 拼接 added = ['m', 'n'] list = list + added # or # list = list.extend(added) # [a, b, m, n] print(list) # 遍历 for i in list: print(i) 字典Java12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; // 新建 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 添加 map.put("a", 1); map.put("b", 2); map.put("c", 3); // 移除 map.remove("c"); // 查询 Integer first = map.get("a"); // 拼接 Map&lt;String, Integer&gt; added = new HashMap&lt;&gt;(); added.put("m", 4); added.put("n", 5); map.putAll(added); // 遍历 map.forEach((key, value) -&gt; &#123; System.out.println(key + ": " + value); &#125;); &#125;&#125; Groovy12345678910111213141516171819static void main(String[] args) &#123; // 新建 &amp; 添加 def map = ['a': 1, 'b': 2] // 添加 map['c'] = 3 // 移除 map.remove('c') // 查询 Integer first = map.get('a') // 拼接 def added = ['m': 4, 'n': 5] map += added // 遍历 map.each &#123; println(it.key + ': ' + it.value) &#125;&#125; JavaScript1234567891011121314151617181920// 新建 &amp; 添加let map = &#123;'a': 1, 'b': 2&#125;;// 添加map['c'] = 3;// 移除delete map['c'];// 查询let first = map['a'];// 拼接let added = &#123;'m': 4, 'n': 5&#125;;map = &#123;...map, ...added&#125;;console.log(map);// 遍历for (let key in map) &#123; if (map.hasOwnProperty(key)) &#123; console.log(`$&#123;key&#125;: $&#123;map[key]&#125;`); &#125;&#125; Python1234567891011121314151617181920# coding=utf-8if __name__ == '__main__': # 新建 &amp; 添加 map = &#123;'a': 1, 'b': 2&#125; # 添加 map['c'] = 3 # 移除 del map['c'] # 查询 first = map['a'] # 拼接 added = &#123;'m': 4, 'n': 5&#125; map.update(added) print(map) # 遍历 for key, value in map.items(): print('%s: %s' % (key, value)) 文件Java1234567public class Client &#123; public static void main(String[] args) throws IOException &#123; File file = new File("/Users/puke/Desktop/TODO.md"); String content = Files.readFile(file); System.out.println(content); &#125;&#125; Groovy12345static void main(String[] args) &#123; def file = new File("/Users/puke/Desktop/TODO.md") def content = file.text println(content)&#125; Python1234if __name__ == '__main__': with open("/Users/puke/Desktop/TODO.md") as f: content = f.read() print(content) 网络Java12345678public class Client &#123; public static void main(String[] args) throws IOException &#123; String url = "https://www.baidu.com"; InputStream inputStream = new URL(url).openStream(); String content = Files.readFile(inputStream); System.out.println(content); &#125;&#125; Groovy12345static void main(String[] args) &#123; def url = "https://www.baidu.com" def content = new URL(url).openStream().text println(content)&#125; Python1234567import urllib2if __name__ == '__main__': url = "https://www.baidu.com" response = urllib2.urlopen(url) content = response.read() print(content)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>Groovy</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio之Debug（二）：自定义Debug变量视图]]></title>
    <url>%2F2018%2F06%2F06%2FAndroid-Studio-Debug-2%2F</url>
    <content type="text"><![CDATA[我们在使用IntelliJ的IDE进行Debug时，去查看一个未重写toString方法的对象需要展开当前的视图层级才能看到里面的属性，而通过自定义变量视图的方式可以直接查看，很大程度上提高Debug的效率。 引出问题我们在Debug查看变量时通常会遇到这种情况 此时我想查看Goods对象里面的具体属性值，需要点击左边的展开按钮才能查看里面具体的属性值，不能直接进行查看。更糟糕的是当Goods对象在List容器中时，我们如果想快速查找到当前List里元素的某一项（或几项）属性时，就会出现在下面的情况，我们只能逐一元素进行展开操作才能查看到元素对应的信息。 重写toString及其局限性上述问题的一般解决方式是重写该类的toString方法，然后重新运行Porject，再次Debug时便可以看到变量的视图会自动变为toString方法的返回值，如下 这样便能无需展开直接显示Goods类的成员变量了，但该方式有几个缺点 添加Goods的toString方法之后需要重新运行 如果Goods是被依赖的jar这种已经被编译的只读类，则无法更改 对于Goods中包含大量属性（比如20+个）的情况下，无法全部显示完，所以就无法根据自己的需求决定查看具体哪些属性值 自定义变量视图IDE提供给我们一种自定义变量视图的方式，专门用来解决上面的问题并弥补了toString方法的不足。这里会有个变量解析器的概念，它用来控制当前变量的显示值（即debug时显示在该变量后面的内容，下称”变量视图”）。 首先Debug状态下右击变量，选择Customize Data Views项 接下来在Customize Data Views弹窗的Tab中选择Java Type Renderers项，如下 点击+来添加一个自定义的变量解析器 自定义一个变量解析器，主要需要添加的是名称、解析类型和解析方式三部分。 名称：该解析器的标识名称 解析类型：表示当前的解析器只对哪种类型的类进行解析 解析方式：此处是核心部分，可以写一个Java表达式，也可以写一段代码，这里的返回值就是该变量视图 我们可以在IDE中添加多个变量解析器，通过控制它的开启、禁用、顺序、适用类等来控制当前变量的显示情况，下面进行一次完整的操作流程演示 通过自定义变量解析器的好处是不需要重新运行整个Project；而且还可以在Debug期间动态切换变量视图，比如 查看name属性时：&quot;name: &quot; + getName() 查看type属性时：&quot;type: &quot; + getType() 查看title属性时：&quot;title: &quot; + getTitle() …… 再进一步抽象看了官网的自定义Debug变量视图这部分介绍后，感觉着实对于Debug很实用，通过自实现的方式使得开发者能够动态化控制变量视图。 自定义变量解析器的方式已经能够解决开篇提到的问题，但我更希望能通过它来找到控制变量视图的通法，即写一个通用的变量解析器而不是每debug一种类型的变量就单独添加一个解析器。接下来要做的事情很清楚了，就是添加一个能够将对象实例序列化成字符串的方法即可。最先想到的是通过Json进行转化，但Json一般依赖三方包，而我们想让Debug功能能够跟IDE是统一基准线的，所以尽可能选择使用Jdk自带的api。 于是考虑到了反射，对于一般通用的变量视图，我们可以直接通过反射取到每个属性名，然后结合当前实例来获取属性值，直接在上面的解析类型中指定为java.lang.Object以支持所有类型变量的解析，解析方式中添加下面的代码 12345678910111213141516171819202122if (((Object) this) instanceof String || ((Object) this) instanceof Number || ((Object) this) instanceof Class) &#123; return ((Object) this);&#125;StringBuilder sb = new StringBuilder("&#123;");Class&lt;?&gt; cls = ((Object) this).getClass();java.lang.reflect.Field[] fields = cls.getDeclaredFields();if (fields != null) &#123; int size = fields.length; for (java.lang.reflect.Field field : fields) &#123; field.setAccessible(true); Object value = field.get((Object) this); sb.append(field.getName()) .append("=") .append(String.valueOf(value)); if (--size &gt; 0) &#123; sb.append(", "); &#125; &#125;&#125;return sb.append("&#125;").toString(); 添加完毕之后，会发现此时我们的IDE在Debug时异常强大，所有类型的变量视图均自动转化成key-value形式的字符串，再也不用为了Debug变量而重写toString方法。看下Debug的效果 这里的User和Goods类均没有重写toString方法，但都能通过上面添加的通用解析器来进行变量视图解析。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio之Debug（一）：运行期代码植入]]></title>
    <url>%2F2018%2F06%2F05%2FAndroid-Studio-Debug-1%2F</url>
    <content type="text"><![CDATA[我们开发中经常使用IDE的Debug功能，使用最频繁的就是断点查看变量内容，这篇文章主要是介绍在Debug时很常用的一些功能，如Debug变量更新、动态代码植入等。 背景看下面一段代码 1234567@Data@ToString@AllArgsConstructorpublic class User &#123; private String name; private String sex;&#125; 123456789101112public class Client &#123; private static final String[] NAMES = &#123;"美队", "浩克", "黑寡妇"&#125;; private static final List&lt;User&gt; USERS = Arrays.stream(NAMES) .map(name -&gt; new User(name, "男")) .collect(Collectors.toList()); public static void main(String[] args) &#123; for (User user : USERS) &#123; System.out.println(user); &#125; &#125;&#125; 我们直接运行这段代码，得到的输出如下 123Client.User(name=美队, sex=男)Client.User(name=浩克, sex=男)Client.User(name=黑寡妇, sex=男) 接下来都会围绕这段代码进行说明 普通断点开发过程中普通断点在Debug过程中使用的算是最频繁的，只要在代码处添加该类型的断点，在Debug模式下，一旦代码执行到改行，程序将进入挂起状态，此时我们能查看到当前的运行状态，如图 条件断点当添加断点的方法会被多次执行到，而我们只希望程序在特定的一些特定的地方（如只有在当前的user是黑寡妇时）断下来，此时我们可以借助条件断点，如下 注意看一下Condition部分，此处需要返回一个boolean类型的值，该值就是为了告诉程序当执行到该行代码时是否进行断点，true表示进行断点，false反之。上面只需要对黑寡妇进行断点，所以添加的Condition是&quot;黑寡妇&quot;.equals(user.getName())。 改变变量状态有时需要对断点时的变量赋值操作，已更改此时变量的值，这时可以使用Set Value方式，如下 除了Set Value，还可以通过估值器进行改变值状态，如下 条件断点 + 代码植入改变变量状态能够动态地设置变量值，条件断点可以控制断点是能在此处挂起，那将两者结合就能达到在程序不挂起的情况下进行动态代码植入的效果。 Condition里插入的代码如下 12345if ("黑寡妇".equals(user.getName())) &#123; user.setSex("女");&#125;// 此处返回false为了告诉IDE在该断点出不对程序执行挂起操作return false; 这就相当于提供了运行期代码的动态植入功能，而且可以通过Enable/Disable断点的状态来进行开启/关闭该部分动态代码是否执行。我们可以通过这种方式添加任何希望添加的代码，比如在每个user对象print之前添加自定一段print 应用场景Debug期间动态植入的应用场景其实有很多的，对应Android端，有时候只需要改变一个变量，添加一行代码就需要重新run整个Project，需要花费整个compile和install的时间才能看出改动之后的效果，如果当前这次更改无效的话，甚至需要再次修改再次运行，而通过debug方式，可以直接对其进行操作。对于后端每次改动之后的重新部署也一样（不考虑动态部署的情况）。 以Android场景为例，如下的代码，接收一个imageUrl参数并加载出来 123456789101112131415161718192021public class ImageActivity extends Activity &#123; private static final String KEY_CONTENT = "imageUrl"; public static void open(Context context, String content) &#123; Intent intent = new Intent(context, ImageActivity.class); intent.putExtra(KEY_CONTENT, content); context.startActivity(intent); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView imageView = findViewById(R.id.image); // 取出参数内容 String imageUrl = getIntent().getStringExtra(KEY_CONTENT); Glide.with(this).load(imageUrl).into(imageView); &#125;&#125; 未植入代码之前，跳转到当前页面是这样的 此时如果需要动态改变当前的imageUrl参数，可以进行Debug模式，并通过动态代码植入方式进行imageUrl变量的重赋值，如下 添加植入的复制代码之后，进入Debug模式，然后重新进入该页面，显示的图片便替换为修改后的了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras框架总结]]></title>
    <url>%2F2017%2F11%2F08%2FKeras-Doc-Summary%2F</url>
    <content type="text"><![CDATA[Keras是基于Tensorflow、Theano以及CNTK为后端的高层神经网络API，通过函数式编程风格进行封装，API面向开发者非常友好，能够把idea迅速转换为结果。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Keras</tag>
        <tag>Python</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RNN自动作诗源码剖析]]></title>
    <url>%2F2017%2F10%2F12%2FTensorflow-Poems-Source%2F</url>
    <content type="text"><![CDATA[Tensorflow Poems是一款基于RNN（循环神经网络）的 Github开源项目，它能通过学习大量古诗文和歌词然后能够自己来模仿创造诗文和歌词。 简介就项目本身，其意义不是很大，权当娱乐就行。这里的重点是解读如何从最原始的诗句，到数据的读取，到数据预处理，到模型的构建，再到最后的训练和使用流程。 数据源通过上面的github地址可以下载到项目源码，其中古诗文的数据集是dataset/data/poems.txt，打开可以看到如下的内容（篇幅限制，只显示了前两行诗句）。 123首春:寒随穷律变，春逐鸟声开。初风飘带柳，晚雪间花梅。碧林青旧竹，绿沼翠新苔。芝田初雁去，绮树巧莺来。初晴落景:晚霞聊自怡，初晴弥可喜。日晃百花色，风动千林翠。池鱼跃不同，园鸟声还异。寄言博通者，知予物外志。... 整体的格式还是蛮清晰的，每行就代表一首诗，每首诗由标题和内容两部分组成，中间以冒号分割。 预处理代码位于poems.py文件的process_peoms方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def process_poems(file_name): # 诗集 poems = [] with open(file_name, "r") as f: for line in f.readlines(): try: # 取出title和content title, content = line.strip().split(':') # 移除content中的所有空格 content = content.replace(' ', '') # 过滤掉包含特殊字符的诗 if '_' in content or '(' in content or '（' in content or '《' in content or '[' in content or \ start_token in content or end_token in content: continue # 过滤掉过长或过短的诗句 if len(content) &lt; 5 or len(content) &gt; 79: continue # 将内容加上前缀(G)和后缀(E) content = start_token + content + end_token # 处理后的添加到诗集中 poems.append(content) # 处理过程出错则跳过, 忽略掉 except ValueError as e: pass # 按诗的字数排序 poems = sorted(poems, key=lambda l: len(line)) # 统计每个字出现次数 all_words = [] for poem in poems: all_words += [word for word in poem] # 计算每个字对应的频率 counter = collections.Counter(all_words) # 按照文字频率进行倒序排列 count_pairs = sorted(counter.items(), key=lambda x: -x[1]) # 取出排列后的字集, 赋值给words words, _ = zip(*count_pairs) # 将words最后追加一位空格 words = words[:len(words)] + (' ',) # 每个字映射为一个数字ID word_int_map = dict(zip(words, range(len(words)))) # 将诗句中的每个word都注意映射为对应的数字ID poems_vector = [list(map(lambda word: word_int_map.get(word, len(words)), poem)) for poem in poems] # 依次返回数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 return poems_vector, word_int_map, words 模型代码位于model.py的rnn_model方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def rnn_model(model, input_data, output_data, vocab_size, rnn_size=128, num_layers=2, batch_size=64, learning_rate=0.01): """ 构造rnn的序列模型 :param model: model class :param input_data: 输入数据占位符 :param output_data: 输出数据占位符 :param vocab_size: words的总长度 :param rnn_size: rnn的units数 :param num_layers: rnn中cell的层数 :param batch_size: 每个batch的样本数量 :param learning_rate: 学习率 :return: 模型状态集 """ # 声明模型状态集, 由于模型需要返回多个相关值, 故以map集合的形式向外部返回 end_points = &#123;&#125; # 选择rnn的具体cell类型, 提供了rnn、gru、lstm三种 if model == 'rnn': cell_fun = tf.contrib.rnn.BasicRNNCell elif model == 'gru': cell_fun = tf.contrib.rnn.GRUCell elif model == 'lstm': cell_fun = tf.contrib.rnn.BasicLSTMCell # 构造具体的cell cell = cell_fun(rnn_size, state_is_tuple=True) # 将单层的cell变为更深的cell, 以表征更复杂的关联关系 cell = tf.contrib.rnn.MultiRNNCell([cell] * num_layers, state_is_tuple=True) # 初始化cell的状态 if output_data is not None: # 训练时batch容量为batch_size initial_state = cell.zero_state(batch_size, tf.float32) else: # 使用时batch容量为1 initial_state = cell.zero_state(1, tf.float32) # tensorflow对于lookup_embedding的操作只能再cpu上进行 with tf.device("/cpu:0"): # 构造(vocab_size + 1, run_size)的Tensor embedding = tf.get_variable('embedding', initializer=tf.random_uniform( [vocab_size + 1, rnn_size], -1.0, 1.0)) # embedding_lookup函数 # output = embedding_lookup(embedding, ids): 将ids里的element替换为embedding中对应element位的值 # 即: embedding: [[1, 2], [3, 4], [5, 6]] ids: [1, 2] 则outputs: [[3, 4], [5, 6]] # 类比one_hot, 只是这里是x_hot # embedding: (3, 2) ids: (10, ) outputs: (10, 2) # 处理之后的shape为(batch_size, n_steps, rnn_size) inputs = tf.nn.embedding_lookup(embedding, input_data) # (batch_size, n_steps, rnn_size) =&gt; (batch_size, n_steps, rnn_size) outputs, last_state = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state) # (batch_size, n_steps, rnn_size) =&gt; (batch_size x n_steps, rnn_size) output = tf.reshape(outputs, [-1, rnn_size]) # (batch_size x n_steps, rnn_size) =&gt; (batch_size x n_steps, vocab_size + 1) weights = tf.Variable(tf.truncated_normal([rnn_size, vocab_size + 1])) bias = tf.Variable(tf.zeros(shape=[vocab_size + 1])) logits = tf.nn.bias_add(tf.matmul(output, weights), bias=bias) # [?, vocab_size+1] if output_data is not None: # output_data must be one-hot encode labels = tf.one_hot(tf.reshape(output_data, [-1]), depth=vocab_size + 1) # should be [?, vocab_size+1] loss = tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits) # loss shape should be [?, vocab_size+1] total_loss = tf.reduce_mean(loss) train_op = tf.train.AdamOptimizer(learning_rate).minimize(total_loss) end_points['initial_state'] = initial_state end_points['output'] = output end_points['train_op'] = train_op end_points['total_loss'] = total_loss end_points['loss'] = loss end_points['last_state'] = last_state else: prediction = tf.nn.softmax(logits) end_points['initial_state'] = initial_state end_points['last_state'] = last_state end_points['prediction'] = prediction return end_points 训练获取数据batch的代码位于poem.py的generate_batch方法 123456789101112131415161718192021222324252627282930def generate_batch(batch_size, poems_vec, word_to_int): # 每次取batch_size首诗进行训练 n_chunk = len(poems_vec) // batch_size x_batches = [] y_batches = [] for i in range(n_chunk): # 求得每个batch中start和end的索引值 start_index = i * batch_size end_index = start_index + batch_size # 取出batch的数据 batches = poems_vec[start_index:end_index] # 找到这个batch的所有poem中最长的poem的长度 length = max(map(len, batches)) # 填充一个这么大小的空batch，空的地方放空格对应的index标号 x_data = np.full((batch_size, length), word_to_int[' '], np.int32) for row in range(batch_size): # 每一行就是一首诗，在原本的长度上把诗还原上去 x_data[row, :len(batches[row])] = batches[row] y_data = np.copy(x_data) # y的话就是x向左边也就是前面移动一个 y_data[:, :-1] = x_data[:, 1:] """ x_data y_data [6,2,4,6,9] [2,4,6,9,9] [1,4,2,8,5] [4,2,8,5,5] """ x_batches.append(x_data) y_batches.append(y_data) return x_batches, y_batches 训练代码位于tang_poems.py的run_training方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def run_training(): # 检测模型参数文件夹及父文件夹, 不存在则新建 if not os.path.exists(os.path.dirname(FLAGS.checkpoints_dir)): os.mkdir(os.path.dirname(FLAGS.checkpoints_dir)) if not os.path.exists(FLAGS.checkpoints_dir): os.mkdir(FLAGS.checkpoints_dir) # 读取诗集文件 # 依次得到数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 poems_vector, word_to_int, vocabularies = process_poems(FLAGS.file_path) # 按照batch读取输入和输出数据 batches_inputs, batches_outputs = generate_batch(FLAGS.batch_size, poems_vector, word_to_int) # 声明输入、输出的占位符 input_data = tf.placeholder(tf.int32, [FLAGS.batch_size, None]) output_targets = tf.placeholder(tf.int32, [FLAGS.batch_size, None]) # 通过rnn模型得到结果状态集 end_points = rnn_model(model='lstm', input_data=input_data, output_data=output_targets, vocab_size=len(vocabularies), rnn_size=128, num_layers=2, batch_size=64, learning_rate=FLAGS.learning_rate) # 初始化saver和session saver = tf.train.Saver(tf.global_variables()) init_op = tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()) with tf.Session() as sess: sess.run(init_op) start_epoch = 0 # 加载上次的模型参数(如果有) checkpoint = tf.train.latest_checkpoint(FLAGS.checkpoints_dir) if checkpoint: saver.restore(sess, checkpoint) print("[INFO] restore from the checkpoint &#123;0&#125;".format(checkpoint)) # 如果有模型参数, 则取出对应的epoch, 训练从该epoch开始训练 start_epoch += int(checkpoint.split('-')[-1]) # 开始训练 print('[INFO] start training...') try: for epoch in range(start_epoch, FLAGS.epochs): n = 0 # 计算一个epoch需要多少次batch训练完, 有余数则忽略掉末尾部分 n_chunk = len(poems_vector) // FLAGS.batch_size for batch in range(n_chunk): # 训练并计算loss # batches_inputs[n]: 第n个batch的输入数据 # batches_outputs[n]: 第n个batch的输出数据 loss, _, _ = sess.run([ end_points['total_loss'], end_points['last_state'], end_points['train_op'] ], feed_dict=&#123; input_data: batches_inputs[n], output_targets: batches_outputs[n] &#125;) n += 1 print('[INFO] Epoch: %d , batch: %d , training loss: %.6f' % (epoch, batch, loss)) # 每训练6个epoch进行一次模型保存 if epoch % 6 == 0: saver.save(sess, os.path.join(FLAGS.checkpoints_dir, FLAGS.model_prefix), global_step=epoch) except KeyboardInterrupt: # 用户手动退出时, 尝试保存模型参数 print('[INFO] Interrupt manually, try saving checkpoint for now...') saver.save(sess, os.path.join(FLAGS.checkpoints_dir, FLAGS.model_prefix), global_step=epoch) print('[INFO] Last epoch were saved, next time will start from epoch &#123;&#125;.'.format(epoch)) 使用取词代码位于tang_poems.py的to_word方法 12345678910111213def to_word(predict, vocabs): # 取词逻辑 # 将predict累加求和 t = np.cumsum(predict) # 求出预测可能性的总和 s = np.sum(predict) # 返回将0~s的随机值插值到t中的索引值 # 由于predict各维度对应的词向量是按照训练数据集的频率进行排序的 # 故P(x|predict[i]均等时) &gt; P(x + δ), 即达到了权衡优先取前者和高概率词向量的目的 sample = int(np.searchsorted(t, np.random.rand(1) * s)) if sample &gt;= len(vocabs): sample = len(vocabs) - 1 return vocabs[sample] 作诗代码位于tang_peoms.py的gen_poem方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def gen_poem(begin_word): # 根据首个汉字作诗 # 作诗时, batch_size设为1 batch_size = 1 print('[INFO] loading corpus from %s' % FLAGS.file_path) # 读取诗集文件 # 依次得到数字ID表示的诗句、汉字-ID的映射map、所有的汉字的列表 poems_vector, word_int_map, vocabularies = process_poems(FLAGS.file_path) # 声明输入的占位符 input_data = tf.placeholder(tf.int32, [batch_size, None]) # 通过rnn模型得到结果状态集 end_points = rnn_model(model='lstm', input_data=input_data, output_data=None, vocab_size=len(vocabularies), rnn_size=128, num_layers=2, batch_size=64, learning_rate=FLAGS.learning_rate) # 初始化saver和session saver = tf.train.Saver(tf.global_variables()) init_op = tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()) with tf.Session() as sess: sess.run(init_op) # 加载上次的模型参数 checkpoint = tf.train.latest_checkpoint(FLAGS.checkpoints_dir) # 注: 无模型参数时, 该步直接crash, 强制有训练好的模型参数 saver.restore(sess, checkpoint) # 取出诗文前缀(G)对应的索引值所谓初始输入 x = np.array([list(map(word_int_map.get, start_token))]) # 得出预测值和rnn的当前状态 [predict, last_state] = sess.run([end_points['prediction'], end_points['last_state']],feed_dict=&#123;input_data: x&#125;) if begin_word: # 用户输入值赋值给word word = begin_word else: # 若未输入, 则取初始预测值的词向量 word = to_word(predict, vocabularies) # 初始化作诗结果变量 poem = '' # 未到结束符时, 一直预测下一个词 while word != end_token: # 没预测一个则追加到结果上 poem += word # 初始化输入为[[0]] x = np.zeros((1, 1)) # 赋值为当前word对应的索引值 x[0, 0] = word_int_map[word] # 根据当前词和当前的上下文状态(last_state)进行预测 # 返回的结果是预测值和最新的上下文状态 [predict, last_state] = sess.run([end_points['prediction'], end_points['last_state']], feed_dict=&#123; input_data: x, end_points['initial_state']: last_state &#125;) # 根据预测值得出词向量 word = to_word(predict, vocabularies) return poem]]></content>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Tensorflow</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《西瓜书》]]></title>
    <url>%2F2017%2F09%2F02%2FWatermelon-Book%2F</url>
    <content type="text"><![CDATA[机器学习理论基础书，涵盖大部分机器学习的常用算法，相对于《机器学习实战》而言，这本书更偏向于理论推导，很多细节部分讲得更加详细。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>思维导图</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sklearn之线性回归]]></title>
    <url>%2F2017%2F09%2F01%2FSklearn-Linear-Regression%2F</url>
    <content type="text"><![CDATA[线性回归模型，主要用作对于连续数值型数据进行预测。为了展现线性回归技术在二维空间的几何表现，这个例子只使用了糖尿病数据集中的第一个特征。下图尝试找到一条使得数据集中各点到直线距离平方和最小的直线。 Source Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# coding=utf-8# Code source: Jaques Grobler# License: BSD 3 clauseimport matplotlib.pyplot as pltimport numpy as npfrom sklearn import datasets, linear_modelfrom sklearn.metrics import mean_squared_error, r2_score# 加载糖尿病数据集diabetes = datasets.load_diabetes()# 只选取一个特征diabetes_X = diabetes.data[:, np.newaxis, 2]# 将数据分割为训练集、测试集diabetes_X_train = diabetes_X[:-20]diabetes_X_test = diabetes_X[-20:]# 将目标标量分割为训练集、测试集diabetes_y_train = diabetes.target[:-20]diabetes_y_test = diabetes.target[-20:]# 创建线性回归对象regr = linear_model.LinearRegression()# 使用训练集训练模型regr.fit(diabetes_X_train, diabetes_y_train)# 使用测试集数据进行预测diabetes_y_pred = regr.predict(diabetes_X_test)# 回归系数print('Coefficients: \n', regr.coef_)# 均方误差print("Mean squared error: %.2f" % mean_squared_error(diabetes_y_test, diabetes_y_pred))# 方差分数: 1代表完美预测print('Variance score: %.2f' % r2_score(diabetes_y_test, diabetes_y_pred))# 将测试集数据及预测结果进行绘图输出plt.scatter(diabetes_X_test, diabetes_y_test, color='black')plt.plot(diabetes_X_test, diabetes_y_pred, color='blue', linewidth=3)plt.xticks(())plt.yticks(())plt.show() 输出结果:1234Coefficients: [ 938.23786125]Mean squared error: 2548.07Variance score: 0.47]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Titanic缺失数据处理]]></title>
    <url>%2F2017%2F08%2F03%2FTitanic-Fill-Data%2F</url>
    <content type="text"><![CDATA[Kaggle的比赛入门，通过机器学习模型对泰坦尼克号上幸存情况进行预测，这里主要针对预测前的特征工程处理，对缺失数据进行分析和补全。 加载数据加载csv文件数据 12345678def load_data(path): import csv as csv reader = csv.reader(open(path, 'rb')) header = reader.next() data = [] for line in reader: data.append(line) return header, np.array(data) 测试代码 12train_header, train_data = load_data(TRAIN_PATH)print train_header Output: 1['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked'] 检查缺失数据遍历每一行，记下空字符串元素所在的位置 12345678910def check_empty(header, data): empty = &#123;&#125; for row, line in enumerate(data): for column, value in enumerate(line): if value == '': feature = header[column] if not empty.__contains__(feature): empty[feature] = [] empty[feature].append(line[0]) return empty 测试代码 1234train_header, train_data = load_data(TRAIN_PATH)empty = check_empty(train_header, train_data)for key, value in empty.items(): print '%s: %d' % (key, len(value)) Output: 123Age: 177Cabin: 687Embarked: 2 可以看到训练数据中Age特征有177条缺失数据，另外两个以此类推。 上面是训练集中缺失数据的特征，而我们要得到还有测试集的缺失信息，所以写一个merge函数，将训练集和测试集合并起来（由于现在是缺失值分析阶段，所以不区分训练集和测试集，接下来会一直沿用合并后的数据），然后再检查缺失信息。 12345678910def merge_data(train_data, test_data): # 删除训练集中第二列的幸存信息，以保持数据格式统一 train_without_survive = np.delete(train_data, 1, axis=1) return np.vstack([train_without_survive, test_data])train_header, train_data = load_data(TRAIN_PATH)test_header, test_data = load_data(TEST_PATH)merged = merge_data(train_data, test_data)for key, value in check_empty(test_header, merged).items(): print '%s: %d' % (key, len(value)) Output： 1234Fare: 1Age: 263Cabin: 1014Embarked: 2 于是能够得到所有缺失的特征，分别是Fare、Age、Cabin、Embarked，接下来开始对缺失项一一进行分析、补全。 缺失数据分析Fare表明乘客的票价，有1个缺失值，我们首先看一下该数据的范围，均值，均方差这些信息 12345fare = merged[:, test_header.index('Fare')]fare_with_data = [float(f) for f in fare if f != '']print 'Range: %.2f - %.2f' % (min(fare_with_data), max(fare_with_data))print 'Mean: %.2f' % np.mean(fare_with_data)print 'Mean variance: %.2f' % np.sqrt(np.var(fare_with_data)) Output: 123Range: 0.00 - 512.33Mean: 33.30Mean variance: 51.74 通过这三项数据（以下简称RMM）我们能对票价信息有个大致的了解，范围在0 - 512.33波动，均值是33.3而均方差只有51.74，这表明大多数票价都是偏低的（也能从一定程度上分析出乘客的经济状况，这里就不继续延伸了）。 RMM信息获取很方便，但是不便于直观、确切的观察数据的分布情况，这时考虑通过matplot画出票价的密度分布图。 123import matplotlib.pyplot as pltplt.hist(fare_with_data, alpha=.7)plt.show() 分布图如下 从图中可以很直观的看出绝大部分数据都是部分在50以下的，鉴于这种情况，我们很直观的选择是把均值作为补全值。 1print np.mean(fare_with_data) Output: 133.2954792813 这时33.2954792813便做为Fare补全值了。 为了确保万一，我们要查出该条数据索引 12empty = check_empty(test_header, merged)print empty['Fare'] Output: 1['1044'] 接下来我们根据PassengerId找到该条数据 11044,3,"Storey, Mr. Thomas",male,60.5,0,0,3701,,,S 对比着特征名来分析数据 1PassengerId,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked 可以逐一分析，我们发现Pclass对应N等票，可能会影响到票价Fare特征，因此我们要取出所有跟该名乘客相同Pclass（从数据可以看出是3）的票价分布。 1234fare = merged[:, [test_header.index('Fare'), test_header.index('Pclass')]]fare_with_pclass_3 = [float(f) for f, pclass in fare if f != '' and pclass == '3']plt.hist(fare_with_pclass_3, alpha=.7)plt.show() 分布图如下 对比和上一张图的区别，我们能更加确切的了解到，三等票的票价没有高于70的，因此如果按照上面的结论直接把所有数据的票价均值作为补全值，在一定程度上会使得补全值的误差变大，取而代之的是用Pclass为3的乘客的票价均值作为补全值（这里还是有一定的优化空间，我们可以分析Pclass为3的乘客中的年龄、家属情况、船舱等对票价的影响，这里就不继续展开了）。 有了上面的分析，我们就可以重新计算补全值 1print np.mean(fare_with_pclass_3) Output: 113.3028887006 和上面输出的33.3还是有一定差距的 经过上面的一系列的分析，可以写出Fare特征的补全逻辑 12345678910111213141516def compute_fare_data(all_data, pclass, fare_index, pclass_index): fare_pclass = all_data[:, [fare_index, pclass_index]] fare_with_pclass = [float(f) for f, c in fare_pclass if f != '' and c == pclass] return np.mean(fare_with_pclass)def fill_data_fare(all_data, need_fill_data, header): fare_index = header.index('Fare') pclass_index = header.index('Pclass') fill_cache = &#123;&#125; for f in need_fill_data: if f[fare_index] == '': pclass = f[pclass_index] if not fill_cache.__contains__(pclass): fill_cache[pclass] = compute_fare_data(all_data, pclass, fare_index, pclass_index) f[fare_index] = fill_cache[pclass] 此时我们的主函数应该是这样子 12345train_header, train_data = load_data(TRAIN_PATH)test_header, test_data = load_data(TEST_PATH)merged = merge_data(train_data, test_data)fill_data_fare(merged, train_data, train_header)fill_data_fare(merged, test_data, test_header) Age表明乘客年龄，有263个缺失值，同上，我们先看一下该特征的RMM信息 12345age = merged[:, test_header.index('Age')]age_with_data = [float(f) for f in age if f != '']print 'Range: %.2f - %.2f' % (min(age_with_data), max(age_with_data))print 'Mean: %.2f' % np.mean(age_with_data)print 'Mean variance: %.2f' % np.sqrt(np.var(age_with_data)) Output: 123Range: 0.17 - 80.00Mean: 29.88Mean variance: 14.41 均值29.9，均方差14.4，可见整体年龄层都分布在青壮年阶段，接下来直接看看密度分布图 从该图中我们只能观察到老人（50岁以上）和小孩（16岁以下）占比较小，年龄大多集中在17-40左右，我们必须试图在数据中寻找更好的估值标准。 我们尝试寻找Age与Pclass的关系，先来画出分布图 1234567891011age_pclass = merged[:, [test_header.index('Age'), test_header.index('Pclass')]]# 过滤掉Age为空的数据age_pclass_with_data = [[int(float(a)), int(p)] for a, p in age_pclass if a != '']age_pclass_with_data = np.array(age_pclass_with_data)x = age_pclass_with_data[:, 0]y = age_pclass_with_data[:, 1]plt.scatter(x, y, alpha=.7)plt.xlabel('Age')plt.ylabel('Pclass')plt.title('Pclass &amp; Age')plt.show() 分布图如下 从上图上中可以知道很难直接根据Pclass估值出Age的值。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android上运行手写数字识别模型]]></title>
    <url>%2F2017%2F08%2F02%2FRun-Mnist-On-Android%2F</url>
    <content type="text"><![CDATA[Github源码请移步本文底部。 模型导出pb文件首先我们需要在我们的python代码中保存训练好的模型，save_path参数就传递**.pb，这里导出文件留给接下来使用 1234def save_model_and_params(session, save_path): out_graph_def = tf.graph_util.convert_variables_to_constants(session, session.graph_def, ["output"]) with tf.gfile.FastGFile(save_path, 'wb') as file: file.write(out_graph_def.SerializeToString()) Android中通过JNI调用Tensorflow与Android整合整合部分就直接按照Android端运行Tensorflow中的步骤来就行了。 封装输出数据解析逻辑在手写数字识别模型中的输出是一个size为10的列表，列表元素的索引值对应输出的结果，列表元素对应输出的概率，例如输出是[0.2, 0.7, 0.01……]，即表示有0.2的概率是0，0.7的概率是1，0.01的概率是2…… 因此我们需要在输出中对数据按照概率进行降序排列，以便让结果一目了然。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @author zijiao * @version 17/8/2 */public class MnistData &#123; private final List&lt;Item&gt; items = new ArrayList&lt;&gt;(10); public MnistData(float[] data) &#123; for (int i = 0; i &lt; data.length; i++) &#123; items.add(new Item(data[i], i)); &#125; Collections.sort(items); &#125; public String top(int topSize) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; topSize; i++) &#123; Item item = items.get(i); builder.append(item.index) .append(": ") .append(String.format("%.1f%%", item.value * 100)) .append("\n"); &#125; return builder.toString(); &#125; public String output() &#123; return String.valueOf(items.get(0).index); &#125; @Override public String toString() &#123; return output(); &#125; @SuppressWarnings("NullableProblems") private static class Item implements Comparable&lt;Item&gt; &#123; final float value; final float index; private Item(float value, float index) &#123; this.value = value; this.index = index; &#125; @Override public int compareTo(Item o) &#123; return value &lt; o.value ? 1 : -1; &#125; &#125;&#125; 这时我们就能通过MnistData类的top方法得到概率最大的几个结果分别是什么。 构建数字分类器这里通过TensorFlowInferenceInterface来调用模型，注释写得很清楚，值得注意的一点是，input和output的名称要和模型中的变量名称保持一致。 1234567891011121314151617181920212223242526272829303132/** * @author zijiao * @version 17/8/2 */public class MnistClassifier &#123; private final TensorFlowInferenceInterface inference; public MnistClassifier(AssetManager assetManager) &#123; inference = new TensorFlowInferenceInterface(); // 加载模型图 inference.initializeTensorFlow(assetManager, TF.MODEL); // 模型使用阶段, 不需要进行dropout处理, 所以keep_prob直接为1.0 inference.fillNodeFloat(TF.KEEP_PROB_NAME, new int[]&#123;1&#125;, new float[]&#123;1.0f&#125;); &#125; public MnistData inference(float[] input) &#123; if (input == null || input.length != 28 * 28) &#123; throw new RuntimeException("Input data is error."); &#125; // 填入Input数据 inference.fillNodeFloat(TF.INPUT_NAME, TF.INPUT_TYPE, input); // 运行结果, 类似Python中的sess.run([outputs]) inference.runInference(new String[]&#123;TF.OUTPUT_NAME&#125;); float[] output = new float[10]; // 取出结果集中我们需要的 inference.readNodeFloat(TF.OUTPUT_NAME, output); // 将输出结果交给MnistData处理 return new MnistData(output); &#125;&#125; 添加画板模型处理的逻辑已经写完了，接下来就是如何得到输入源了。由于是手写数字识别，所以接下来就要写画板类。这里只贴出关键代码部分（完整代码可以看本文底部的Github地址）。 手指滑动屏幕时画出手指滑动的轨迹 123456789101112131415161718192021@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(path, paint);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; float x = event.getX(); float y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: path.moveTo(x, y); break; case MotionEvent.ACTION_MOVE: path.lineTo(x, y); break; &#125; invalidate(); return true;&#125; 向外部提供读取画布数据的方法 1234567891011121314151617181920212223242526272829303132public float[] fetchData(int width, int height) &#123; float[] data = new float[height * width]; try &#123; setDrawingCacheEnabled(true); setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_LOW); Bitmap cache = getDrawingCache(); fillInputData(cache, data, width, height); &#125; finally &#123; setDrawingCacheEnabled(false); &#125; return data;&#125;private void fillInputData(Bitmap bm, float[] data, int newWidth, int newHeight) &#123; // 获得图片的宽高 int width = bm.getWidth(); int height = bm.getHeight(); // 计算缩放比例 float scaleWidth = ((float) newWidth) / width; float scaleHeight = ((float) newHeight) / height; // 取得想要缩放的matrix参数 Matrix matrix = new Matrix(); matrix.postScale(scaleWidth, scaleHeight); // 得到新的图片 Bitmap newbm = Bitmap.createBitmap(bm, 0, 0, width, height, matrix, true); for (int y = 0; y &lt; newHeight; y++) &#123; for (int x = 0; x &lt; newWidth; x++) &#123; int pixel = newbm.getPixel(x, y); data[newWidth * y + x] = pixel == 0xffffffff ? 0 : 1; &#125; &#125;&#125; 运行测试布局代码就直接省略了，我们只需要在点击识别的时候，调用下面这段的识别逻辑即可。 123456789// 识别public void onInference(View view) &#123; if (canvasView.isEmpty()) &#123; resultPanel.setText("画板为空"); return; &#125; MnistData result = classifier.inference(canvasView.fetchData(28, 28)); resultPanel.setText(result.top(3));&#125; 最后附上运行效果图 这里是该项目的Github源码]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Tensorflow</tag>
        <tag>Mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android端运行Tensorflow]]></title>
    <url>%2F2017%2F08%2F02%2FTensorflow-On-Android%2F</url>
    <content type="text"><![CDATA[将Tensorflow训练好的模型部署在Android端，网上找到的很多资料要么过于复杂，要么就根本不能运行，于是记录下具体的整合步骤。 New Projectlocal.propertities文件中指定ndk目录1ndk.dir=/Users/zijiao/Library/Android/sdk/ndk-bundle 向src/main/jniLibs/[cpu]目录添加对应的libtensorflow_demo.so文件其中[cpu]包含arm64-v8a、armeabi-v7a、x86、x86_64修改build.gradle文件android闭包中添加1aaptOptions &#123; noCompress 'pb' &#125; android-defaultConfig闭包下添加（可选）123456ndk&#123; //生成的so名字 moduleName "tensorflow_demo" //输出指定三种abi体系结构下的so库。目前可有可无。 abiFilters "arm64-v8a", "armeabi-v7a", "x86_64", "x86" &#125; 将TensorFlowInferenceInterface.java 拷到src/main/java/org.tensorflow.contrib.android目录下注意加载so文件 123static &#123; System.loadLibrary("tensorflow_demo");&#125; 将Model文件和Label文件拷到src/main/assets目录下测试是否成功123456TensorFlowInferenceInterface inference = new TensorFlowInferenceInterface();String modelPath = "file:///android_asset/[.pb文件名]";int code = inference.initializeTensorFlow(getAssets(), modelPath);if (code == 0) &#123; // 初始化成功&#125; ​]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Machine Learning</tag>
        <tag>Tensorflow</tag>
        <tag>移动AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《机器学习实战》]]></title>
    <url>%2F2017%2F08%2F01%2FMachine-Learning-Inaction%2F</url>
    <content type="text"><![CDATA[用了一个多月的时间看完了这本书，在这段时间里穿插了不少事情，公司的业务开发经历了两次班车迭代，还有一周多的时间用来研究图像语义分割。由于本职的Android开发还是占用很大一部分精力和时间，所以看书只能抽一些时间碎片进行。 谈谈自己对该书的整体感觉，这本书作为ML的入门、科普书籍当然是不错的，整体的章节设定看上去一目了然。书中列出了很多ML的经典算法，同时也有对应的代码实现，这里要点赞的一点是对于算法的封装性和拓展性而言，该书做的还是蛮不错的，很多实现代码基本上是可以拿过来直接使用的。还有就是书中整体的连贯性写的很到位，A算法已经很实用了，但在某某方面还存在缺陷，而B算法会在兼容A算法精华部分的基础上还解决了对应的缺陷，于是很平滑的过渡到B算法的讲解部分，这样给读者一种前因后果的感觉，而非凭空冒出个B算法。 同时也有些我认为美中不足的地方，关于一些算法公式方面，讲着讲着就突然莫名来了一个公式，有的公式甚至没什么说明，直接就用上了。其实能够理解作为一本ML的书籍不适合在算法公式的推导上花费太多的篇幅，但也不至于简短的描述都没有，一下子看到一坨公式的时候真是一脸茫然。还有一点是，看该书还是需要一定的线代基础的，在回归的讲解部分如果没有线代基础基本上就是走马观花了。 之前也看过不少技术书籍，时间越久淡忘的就越多，所以这次打算把看过的部分都记下来，一方面加深自己的印象，另一方面也为了提高日后复习的效率。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>思维导图</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI场景分类竞赛]]></title>
    <url>%2F2017%2F05%2F03%2FKeras-Scene-Competion%2F</url>
    <content type="text"><![CDATA[全球AI挑战赛中场景分类的比赛源码，比赛已经告一段落，这里对总结一下比赛期间遇到的问题，踩的坑等做个总结。和WinterFu一起参加了这次比赛，一路摸爬滚打到比赛结束，没少折腾。 快速接入 下载源码 下载数据集，有朋友反馈官方链接失效，我在百度云又存放一份：链接: https://pan.baidu.com/s/1cjR-xhsCq8BD5nH7yQeiIA 密码: xfcp 配置数据集路径 打开config.py，找到下面的位置，根据自己的电脑系统在对应的位置配置上数据集路径 12345678910111213141516# image pathif is_windows(): PATH_TRAIN_BASE = 'G:/Dataset/SceneClassify/ai_challenger_scene_train_20170904' PATH_VAL_BASE = 'G:/Dataset/SceneClassify/ai_challenger_scene_validation_20170908' PATH_TEST_B = 'G:/Dataset/SceneClassify/ai_challenger_scene_test_b_20170922/scene_test_b_images_20170922'elif is_mac(): PATH_TRAIN_BASE = '/Users/zijiao/Desktop/ai_challenger_scene_train_20170904' PATH_VAL_BASE = '/Users/zijiao/Desktop/ai_challenger_scene_validation_20170908' PATH_TEST_B = ''elif is_linux(): # 皮皮酱 PATH_TRAIN_BASE = '' PATH_VAL_BASE = '' PATH_TEST_B = ''else: raise Exception('No images configured on %s' % os_name) 分类数据 运行split_by_class.py 脚本，分别对train数据集合val数据集进行按照子文件夹分类 开始训练 找任一个classifier 开头的(classifier_base 除外)脚本进行运行，这里包含VGG16/19、Xception、Inception-V3、Inception-Resnet-V2等经典模型 要点概述 支持多个单模型进行集成，可选多种集成方式 支持多种集成方式间的任意组合和自动择优 支持间断训练时权重文件的择优选择 支持VGG16、VGG19、Resnet50、Inception-V3、Xception、Inception-Resnet-V3模型 imgaug 图片数据增强库替换Keras自带的图片预处理 支持多进程进行图片预处理 血训数据增强很重要！！！Keras自带的图片增强远远不够的，这里选择了imgaug这个图片数据增强库，直接上图，这种效果是目前的Keras望尘莫及的，尽可能最大限度利用当前有限的数据集。提高1~3个百分点 尽可能高效使用CPU！！！训练任务交给GPU去做，新添加的imgaug图片处理方式之后，一个Epoch在1050Ti上耗时90mins+，排查发现大部分时间都在进行图片数据增强处理，于是将该部分的处理替换为多进程方式。时间从90mins降到30mins左右 标准化很重要！！！先计算出整体训练集的mean和std，然后在训练阶段的输入数据以mean和std进行高斯化处理（参mean_var_fetcher.py）提高0.5~1.0个百分点 Fine-tune别绑太紧！！！这点尤为重要！Fine-tune时松太开，可能导致训练耗时，也可能导致机器带不动；绑太紧可能导致Fixed的权重参数扼制了模型的学习能力。建议是在机器能扛得住的基础下，尽可能松绑多一些。提高2~5个百分点 模型选择很重要！！！糟糕的模型训练几天几夜，可能赶不上优势模型训练几个epoch。VGG16=&gt;Xception提高5~8个百分点 Loss降不下去时尝试调低LR！！！降不下去就调小，调下的幅度一般是5倍、10倍左右。提高1~3个百分点 TensorbBoard监视训练状态！！！尽可能使用Tensorflow提供的Tensorboard可视化工具，方便从宏观把控训练过程。 适度过拟合是良性的！！！训练过程中一直没有过拟合，要从两方面考虑： 模型太简单，拟合能力不足，这时要考虑增强网络复杂度 数据增强程度太大，学不到某些特征 模型集成！！！单模型没有什么提升空间时，要尝试将多个单模型进行集成。集成的方式可以选择投票法、均值法、按照模型Acc加权法等等。提高0.5~1.5个百分点 预测数据增强！！！为了确保预测结果的准确性，可以将待预测结果进行水平翻转（或随机裁取patch等）处理，将这多张孪生图片进行预测，最终结果取多个结果的均值。提高0.25~1.0个百分点 找个小伙伴一起搞！！！想法x2，时间/2，还能互相讨论学习！提高0~50个百分点]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Keras</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio代码块打标]]></title>
    <url>%2F2017%2F03%2F21%2FAndroid-Studio-Code-Block-Mark%2F</url>
    <content type="text"><![CDATA[Android Studio代码块打标，让我们迅速定位到代码逻辑块。当我们开发中写的某些类的代码量相对比较庞大时，就会遇到维护这个类变得困难的问题，抛开对于该类的设计层面的因素，只从代码量的角度来看这个问题。基于IntelliJ的IDE给我们提供了一种能够给我们的代码块进行归纳的标签（以下称为代码块打标），如下 123// &lt;editor-fold defaultstate="collapsed" desc="[A]"&gt;[B]// &lt;/editor-fold&gt; 其中，[A] 对应打标的描述语言，[B] 对应待打标代码块。 根据上述规则我们来对MainActivity进行打标操作，代码如下 123456789101112131415161718192021222324252627282930313233343536373839/** * @author zijiao * @version 17/3/21 */public class MainActivity extends Activity &#123; // &lt;editor-fold defaultstate="collapsed" desc="成员变量"&gt; private Button button; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="onCreate逻辑"&gt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initListener(); &#125; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="findView逻辑"&gt; private void initView() &#123; button = (Button) findViewById(R.id.button); &#125; // &lt;/editor-fold&gt; // &lt;editor-fold defaultstate="collapsed" desc="点击事件处理逻辑"&gt; private void initListener() &#123; button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "Click button", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; // &lt;/editor-fold&gt;&#125; 可以看到我们将各个代码块按照逻辑进行分类并添加对应的描述标签，当我们下次再打开该类时，查看或修改某部分代码就会一目了然（当代码庞大时，其优点将会尤为明显），参见下图 可以看到代码块打标是很方便，但是有一点不好，就是当我们需要给某一个代码块打标时我们总是要在代码块之前添加 1// &lt;editor-fold defaultstate="collapsed" desc="[A]"&gt; 然后在代码块之后添加 1// &lt;/editor-fold&gt; 这个步骤很繁琐，但好消息是我们可以结合AS提供给我们的LiveTempalte，将这个过程封装成一个打标模板，来看看具体操作 打开Android Studio，进入Preferences — Editor — Live Templates ，新建一个Live Template Abbreviation处填写Mark Code Block，Template text处填写 123// &lt;editor-fold defaultstate="collapsed" desc="$description$"&gt;$SELECTION$// &lt;/editor-fold&gt; 点击Define，勾选Java复选框 点击Apply 这个时候你的界面应该是这样，可以核对下 到这里，打标模板已经完成了，你可以随便找一个类进行测试，选中一个代码块，按下快捷键Command + Option + J（Windows系统可以在Preferences — Keymap 中搜索Surround with Live Template...对应的快捷键）来选择Mark Code Block模板，此时我们就可以快速进行代码块打标操作了，如下图]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Template]]></title>
    <url>%2F2017%2F03%2F10%2FAndroid-Studio-Template%2F</url>
    <content type="text"><![CDATA[本文为图片展示篇，展示业界对Android Studio Template的评价。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TemplateBuilder]]></title>
    <url>%2F2017%2F03%2F06%2FTemplateBuilder%2F</url>
    <content type="text"><![CDATA[中文版 Integrate the development process of the Android Studio Template into the Android Studio Plugin, only one-click will be able to make the current file as a Template. Statement Android Studio templates include the following three, here is the third Multi Template. Before reading this article, Acquiescence you know the template, know why to use it, if it is not clear what it is, you can check the relevant information online, of course, you can also click here to see the peer to its evaluation Live Template：Code snippet level File Template：Single file level Multi Template：Multiple file levels (hereinafter referred to as Android Studio Template) WHATTemplateBuilder is an AS plug-in that can help us to quickly generate Android Studio Template, through a file to configure the template to improve the way through the plug-in to achieve, for simple template production, only one button can be generated. HOWInstallOpen Android Studio, Preferences – Plugins – Brown Repositories, search TemplateBuilder and download, then restart the IDE and try. InstructionsGif effectFirst directly show the Gif presentation effect, respectively, corresponding to the template export and import Export: Select the file or folder to be exported, press ALT + T, in the pop-up interface to change the template name (MVP Test) and description, then click Finish, and then restart the IDE; Import: Select a package, press the Command + N key, enter the template category name (the default is the computer user name), select the MVP Test template to import. Detailed explanationHere we take an example of the extraction of an MVP template, first select the need to create a template for the template file (if you need to select a package below all the files, you can directly select the package), and then press the shortcut ALT + T to start the plug, you can see the following interface Here to explain the corresponding content of the interface Template Category Corresponding to the template classification, corresponding to select the template template when the import, where the default is the computer’s user name. Template Name Corresponding to the template name, corresponding to the template name when selecting the import template, the default is the current Project name. Template Description Corresponding to the template description information, corresponding to the template when the import interface pop-up description of the text, the default is empty. Template Folder Corresponding to the location generated by the template, if the Mac operating system is the default / Applications / Android Studio.app/Contents/plugins/android/lib/templates, Windows OS, because the difference is relatively large, the default is empty, you can Configure the [Android Studio installation directory] / plugins / android / lib / templates(here only need to configure once, the plugin will automatically save the location). Input data area If you want to enhance the compatibility of the template will use it, it corresponds to the AS template Template.xml tag, that is, each of the following configuration items. The whole UI interface is clear, if you just want to simply extract the template you write, you only need to enter the Template Name and Template Description can, of course, if you do not want to enter this can also be omitted. Then click Finish, you can see the bottom of the IDE pop-up as shown below the prompt, then you have been successful, restart the IDE to use the template. Here, if you understand the Android Studio Template production process, you may feel that compared to their own manual to do this is simple, but the flexibility to reduce a lot. For example, when there is a group dependency in the template, you need to add the corresponding dependencies in build.gradle.ftl. After importing the template, you will need to edit recipe.xml.ftl when you want to open a file automatically. In which version, you need to edit template.xml and so on. If you have this need, you can click Next to replace the Finish, click on the following you will be able to see the following interface, where you need to focus on all the configuration file editing, editing directly click OK to start automatically generated. WHYIf you try to make your own Android Studio Template, I believe you will be for the template configuration, change the file name, add the parameters can be complicated, and so cumbersome operation and worry, because even a very simple template extraction need to put this A series of processes all go again, change several configuration files. Say my personal feelings, when I found Android Studio Template I suddenly felt there are too many can be extracted out of the template for future rapid use, but when I first started to extract a few templates when it has been deep Disgusted, because this process is very tedious. Remember to also write groovy script to assist in the configuration of these templates, but still need to add some template to the script file entry information, still very troublesome. Later, I decided to make this process as much as possible through the automation to complete, then consider the Gradle plug-in, Java GUI, AS Plugin and other ways to complete the template production, the final choice of a quick and convenient AS Plugin, plug-in name is mentioned above To the TemplateBuilder.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TemplateBuilder(中文版)]]></title>
    <url>%2F2017%2F03%2F06%2FTemplateBuilder%5BChinese%5D%2F</url>
    <content type="text"><![CDATA[将Android Studio Template的开发过程集成于Android Studio Plugin中，只需要一键就能将当前文件制作为Template。 Android Studio的模板包括以下三种，这里讲的是第三种Multi Template。在阅读本文之前，默认你是了解该模板的，知道为什么要使用它，如果不清楚它是什么，可以在网上查阅相关资料，当然也可以直接点击这里查看一下同行们对它的评价 Live Template：代码片段级别 File Template：单文件级别 Multi Template：多个文件级别（以下称 Android Studio Template） WHATTemplateBuilder是一款能够帮助我们快速生成Android Studio Template的AS插件，将通过逐个文件去配置模板的方式改进为通过插件来实现，对于简单的模板制作，只需要一键即可生成。 HOW安装打开Android Studio，Preferences – Plugins – Brown Repositories, 搜索TemplateBuilder 并下载，下载之后重启IDE即可使用。 使用动态图展示先直接贴上Gif的演示效果，分别对应模板的导出与导入 导出： 选择待导出的文件或文件夹，按下ALT + T，在弹出界面中更改模板名称（MVP Test）和描述后直接Finish，然后重启IDE； 导入： 选择一个包，按下Command + N键，输入模板分类名（默认为电脑用户名），选择MVP Test模板进行导入。 快速制作这里我们拿对一个MVP模板的抽取来举例，首先选中需要制作为模板的类文件（如果需要选中某个文件夹里的全部文件，可以直接选中该文件夹），然后按下启动改插件的快捷键ALT + T，便能看到如下界面 下面来说明一下该界面对应的内容 Template Category 对应模板的分类，对应选择导入模板时的模板分类，这里默认值是电脑的用户名。 Template Name 对应模板名称，对应选择导入模板时的模板名称，默认值是当前的Project名称。 Template Description 对应模板描述信息，对应导入模板时弹出的导入界面的文字描述，默认为空。 Template Folder 对应生成模板所存放的位置，如果是Mac操作系统则默认为/Applications/Android Studio.app/Contents/plugins/android/lib/templates， Windows系统的话由于差异比较大，就默认为空了，可以自行配置[Android Studio安装目录]/plugins/android/lib/templates（这里只需要配置一次即可，插件将自动保存该位置）。 Input data区域 （见下：配置模板变量） 如果你只是想简单抽取你写的这个模板，你只需要输入下Template Name和Template Description即可，当然如果你不想输入的话这也可以省略掉。接下来直接点击Finish，就能在IDE底部看到弹出如下图所示的提示，此时你已经制作成功，重启IDE即可使用该模板。 到这里，如果你了解Android Studio Template制作流程的话，你可能觉得相对于完全自己手动去做这样固然简单，但是灵活性上降低了不少。例如模板中有组价依赖关系的时候，你需要在build.gradle.ftl中去添加对应的依赖；导入模板之后你想自动打开某个文件时，你需要编辑recipe.xml.ftl；选择模板适用于哪个版本时，你需要编辑template.xml等等。如果你有这方面的需求，可以点击Next来代替Finish，点击之后你就能看到如下界面，在这里提供了所有你需要关注的配置文件的编辑，编辑完成直接点击OK开始自动生成。 配置模板变量在上面的界面中可以看到Input data区域，它对应着导入模板时的变量输入，如果你想增强模板的可配性将会用到它，它就对应着AS模板中template.xml的&lt;parameter /&gt;标签，也就是下面的每一个配置项。 关于Input data的使用，先解释下每个属性对应的含义 id 变量名，必须和模板中使用的变量名对应，必填 name 变量简介，必填 type 变量类型，string和boolean两种，通过下拉框选择，必填 default 变量对应的默认值，选填 help 添加该变量时的提示信息，选填 下面我举个例子，假设待导出的模板文件是UserActivity类，代码如下： 123456789101112public class UserActivity extends Activity &#123; private TextView mUserName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user); mUserName = (TextView) findViewById(R.id.user_name); &#125; &#125; 代码很简单，假设我们想让引入模板时mUserName属性名是可配的，并且在Activity中是否调用setContentView方法也是可配的，那我们就需要这样改写该类： 12345678910111213public class UserActivity extends Activity &#123; private TextView $&#123;textViewName&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &lt;#if setContentView&gt; setContentView(R.layout.activity_user); $&#123;textViewName&#125; = (TextView) findViewById(R.id.user_name); &lt;/#if&gt; &#125;&#125; 我们用到了textViewName和setContentView两个变量，所以当我们按下ALT + T时就要在对应的Input data区域点击Add来添加两个对应的变量。 Input data textViewName setContentView id textViewName setContentView type string boolean name TextView属性名 是否设置布局 default mUserName false help 输入TextView对应的属性名 勾选则设置布局文件，反之不设置 添加完模板变量后导出，重启IDE选择导入该模板，此时便能看到刚才配置的两个变量，你可以输入不同的值来验证模板的正确性。 添加模板依赖模板中需要添加gradle依赖时，点击Next在第二个页面中build.gradle.ftl添加如下所示对应的仓库和依赖即可。 123456789repositories &#123; // 如果仓库是jcenter()，则可省略 jcenter()&#125;dependencies &#123; compile 'io.reactivex.rxjava2:rxjava:2.0.6' compile 'io.reactivex.rxjava2:rxandroid:2.0.1'&#125; WHY如果你尝试过自己去制作一个Android Studio Template的话，相信你一定会为模板配置、更改文件名、添加可配参数等等繁琐的操作而烦恼，因为哪怕一个很简单的模板抽取都需要把这一系列流程全都走一遍，更改好几个配置文件。 说下我的个人感受，当我发现Android Studio Template时我顿时感觉有太多太多可以抽取出来的模板以供日后快速使用，但当我刚开始抽取几个模板的时候就已经被深深的恶心到了，因为这个过程真心很繁琐。记得当时还专门写groovy脚本来辅助进行这些模板的配置，但也还是需要向脚本里添加一些模板文件的入参信息，依然很麻烦。后来我决定将这个制作过程尽可能通过自动化来完成，当时考虑Gradle插件、Java GUI、AS Plugin等多种方式来完成模板制作，最终选择了快而方便的AS Plugin，插件的名称就是上面所提到的TemplateBuilder。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件组]]></title>
    <url>%2F2016%2F10%2F16%2FAndroid-Studio-Template-For-File-Group%2F</url>
    <content type="text"><![CDATA[文件组模板是基于FreeMarker模板语言的一个功能很强大的Android开发模板，可以这样说，代码片段模板和文件模板是一种提高编码效率的工具，而文件组模板可以算是一种模板引擎。 效果图展示一图胜千言，先上图 已有工程中使用模板效果图 创建工程时使用模板 示例场景在进行Android开发时，我们经常会创建一个Demo工程，目的可能有很多种，可能是为了验证一个问题，可能是为了学习一个框架的使用，可能为了测试自己写的一个lib库等等。这个时候我们可能会创建一个Activity，然后再在xml写一些按钮，再在Activity里写该按钮的事件监听逻辑，也就是说为了执行一段代码我们要做这么多操作。为了简化这段重复操作，我这边写了一个DebugActivity类，然后支持我们只需要写个子类来继承它，然后像下面这样写几个方法即可，运行的时候会根据方法动态创建按钮，并在点击按钮时执行该方法的代码逻辑。 123public void _test() &#123; T("弹出Toast");&#125; 由于本文主要介绍模板相关的，所以该场景相关的具体代码技术细节就不多说了，有兴趣的可以看下，DebugActivity的代码，这里提出来只是为模板开发简单的做个铺垫。 模板位置Android Studio Template中有系统预设的一些模板，我们可以直接修改，也可以另行添加新的模板。打开Android Studio安装目录/Contents/plugins/android/lib/templates这个文件夹我们能看到下面的目录结构，这里便是AS中模板存放的位置。 我们接下来的工作也就在这里，保险起见我们在这里新建一个目录，我们自己写的模板都放在自己新建的目录里，例如我这里就创建了一个叫pk的目录。 模板规范在上面的基础上，我们可以直接打开/activies/EmptyActivity目录，如下图 我们可以看到上面红色区域便是Template的文件结构，大致说下各个文件（夹）的含义 globals.xml.ftl 模板中参数配置的地方（可选） recipe.xml.ftl 模板行为执行处，引入这个模板之后，接下来要做什么事情，就是它说的算（可选，但是不选就没有意义了，因为模板引入是要要行为驱动的） root 存放模板文件及引入资源的目录，模板文件可以是.xml、.java、.gradle等任何一个文本格式的文件，资源一般是我们引入的.png资源文件（可选，不选同上） template_blank_activity.png 引入模板时的引导图（可选） template.xml 面向模板引擎的配置文件（必选） 我们可以看到，真正核心的部分就是root、recipe.xml.ftl和template.xml，接下来这重点说明这三部分。 我们可以打开root目录，能够看到里面的文件除了图片资源文件都是以.ftl结尾的，而.ftl是标准的FreeMarker的文件。FreeMarker是类似于Velocity的一种模板框架，据说对于多文件处理时它具有更好的性能，大概也是Android Studio选择Velocity作为单文件模板，选择FreeMarker作为文件组模板的原因吧。有兴趣的可以去FreeMarker官网学习一下，它的自定义标签功能还是很强大的，个人感觉比Velocity的更加接地气。 接下来我们看一下recipe.xml.ftl 的内容，打开如下 1234567891011121314&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;#include "../common/recipe_manifest.xml.ftl" /&gt;&lt;#if generateLayout&gt; &lt;#include "../common/recipe_simple.xml.ftl" /&gt; &lt;open file="$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml" /&gt;&lt;/#if&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt;&lt;/recipe&gt; 这里以&lt;#开头的都是FreeMarker的语法，基本上比葫芦画瓢就能看明白，就不多说了。其实对于这个文件最重要的部分是下面四个标签 copy 就是简单的copy，把模板root目录下的某个文件copy到目标工程的某个目录下 instantiate 跟copy很类似，唯一多的一点功能就是并不只简单的走IO流进行copy，而是通过FreeMarker框架按照模板中的FreeMarker能识别的逻辑判断和数据引入来生成最终的目标文件 merge 目标项目中有了某文件，而我们还要想该文件合并一些我们的模板的部分时，就选用merge，例如我们添加一个Activity时需要mergeAndroidManifest.xml的配置。目前支持的merge格式有.xml和.gradle，但是对.gradle支持的不怎么好，不过不影响该模板的开发，对于这套模板引擎的开发者来说，这可能是最麻烦的部分了，但是对于我们使用者就不用考那么多了，直接使用吧 open 这个很简单，就是指定模板引入之后要IDE打开的文件 然后看下template.xml内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Empty Activity" minApi="7" minBuildApi="14" description="Creates a new empty activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity Name" type="string" constraints="class|unique|nonempty" suggest="$&#123;layoutToActivity(layoutName)&#125;" default="MainActivity" help="The name of the activity class to create" /&gt; &lt;parameter id="generateLayout" name="Generate Layout File" type="boolean" default="true" help="If true, a layout file will be generated" /&gt; &lt;parameter id="layoutName" name="Layout Name" type="string" constraints="layout|unique|nonempty" suggest="$&#123;activityToLayout(activityClass)&#125;" default="activity_main" visibility="generateLayout" help="The name of the layout to create for the activity" /&gt; &lt;parameter id="isLauncher" name="Launcher Activity" type="boolean" default="false" help="If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher" /&gt; &lt;parameter id="packageName" name="Package name" type="string" constraints="package" default="com.mycompany.myapp" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; 当我们进行模板引入时，AS会弹出一个如下图的UI界面，要我们来填入或选择一些数据，例如输入Activity的的名称，选择SDK的版本之类的。而这个界面就是根据由该文件而来的。 内容比较多，为减少篇幅我挑些重要的说 template标签 name 引入模板时的模板名称，就死根据他选择哪个模板的 description 弹出Dialog的标题，对应上去的区域1 category 表示该模板属于哪种分类，在引入的时候会有个分类的选择 parameter 每个该标签就对应Dialog界面的一个输入项 id 该参数的唯一标识符，也是我们在.ftl中引入的值，例如定义的id为username，引用时就是$username name 对应Dialog上面该输入项的名称 type 对应该参数的类型，Dialog就是根据这个来决定对应输入是选择框、输入框还是下拉框等等 constraints 对应该参数的约束，如果有多个要用|分割开 suggest 建议值，这个输入部分是由级联效应的，可能你改了A参数，B参数也会跟着改变，就是根据这个参数决定的 default 参数的默认值 visibility 可见性，要配置一个boolean类型的参数，一般指向另一个输入源 help 当焦点在某个输入源上面时，上图的区域3的就限制这儿的内容 操刀实战了解了模板规范之后，我们编写模板时就不会那么被动了，下面我们来自己动手编写文章开始部分展示的模板。 首先在刚才提到的自定义的模板下创建如下图所示的目录结构 DebugActivity root src app_package DebugActivity.java.ftl JumpActivity.java.ftl SimpleActivity.java.ftl AndroidManifest.xml.ftl globals.xml.ftl recipe.xml.ftl template.xml template_debug_activity.png 然后将下面的代码对应贴进去（图片部分随便找一张代替好了…） globals.xml.ftl 123456&lt;?xml version="1.0"?&gt;&lt;globals&gt; &lt;global id="resOut" value="$&#123;resDir&#125;" /&gt; &lt;global id="srcOut" value="$&#123;srcDir&#125;/$&#123;slashedPackageName(packageName)&#125;" /&gt; &lt;global id="relativePackage" value="&lt;#if relativePackage?has_content&gt;$&#123;relativePackage&#125;&lt;#else&gt;$&#123;packageName&#125;&lt;/#if&gt;" /&gt;&lt;/globals&gt; recipe.xml.ftl 123456789101112131415161718192021&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;instantiate from="root/src/app_package/DebugActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt; &lt;instantiate from="root/src/app_package/SimpleActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;#if addJumpActivity&gt; &lt;instantiate from="root/src/app_package/JumpActivity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/JumpActivity.java" /&gt; &lt;/#if&gt; &lt;merge from="root/AndroidManifest.xml.ftl" to="$&#123;escapeXmlAttribute(manifestOut)&#125;/AndroidManifest.xml" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/DebugActivity.java" /&gt;&lt;/recipe&gt; template.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0"?&gt;&lt;template format="5" revision="5" name="Debug Activity" minApi="7" minBuildApi="14" description="创建一个Debug的Activity"&gt; &lt;category value="Activity" /&gt; &lt;formfactor value="Mobile" /&gt; &lt;parameter id="activityClass" name="Activity名称" type="string" constraints="class|unique|nonempty" default="SetupActivity" help="创建Activity的名称" /&gt; &lt;parameter id="addExample" name="是否添加按钮使用示例" type="boolean" default="false" help="选择时会自动生成测试按钮；否则不生成" /&gt; &lt;parameter id="addJumpActivity" name="是否添加跳转Activity示例" type="boolean" default="false" help="选择时会自动生成跳转Activity相关逻辑；否则不生成" /&gt; &lt;parameter id="isLauncher" name="设为启动页面" type="boolean" default="true" help="选择时设置该页面为启动页面；否则不设" /&gt; &lt;parameter id="packageName" name="包名" type="string" constraints="package" default="com.mycompany.myapp" help="输入Application包名" /&gt; &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_debug_activity.png&lt;/thumb&gt; &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt; AndroidManifest.xml.ftl 123456789101112131415161718&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;application&gt; &lt;#if addJumpActivity&gt; &lt;activity android:name="$&#123;relativePackage&#125;.JumpActivity"/&gt; &lt;/#if&gt; &lt;activity android:name="$&#123;relativePackage&#125;.SetupActivity"&gt; &lt;#if !(isLibraryProject!false) &amp;&amp; isLauncher&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/#if&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; DebugActivity.java.ftl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package $&#123;packageName&#125;;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * Debug测试类,快速调试Demo工程&lt;hr /&gt; * 使用姿势:&lt;br /&gt; * 1. 新建一个子类继承该类&lt;br /&gt; * 2. 跳转Activity: 在子类配置&#123;@link Jump&#125;注解, 然后在注解中配置跳转Activity的类型&lt;br /&gt; * 3. 点击按钮触发方法: 在子类声明一个名称以"_"开头的方法(支持任意修饰符),最终生成按钮的文字便是改方法截去"_"&lt;br /&gt; * 4. 方法参数支持缺省参数和单个参数&lt;br /&gt; * 5. 如果是单个参数,参数类型必须是Button或Button的父类类型,当方法执行时,该参数会被赋值为该Buttom对象&lt;br /&gt; * https://github.com/puke3615/DebugActivity&lt;br /&gt; * &lt;p&gt; * * @author zijiao * @version 16/10/16 */public abstract class DebugActivity extends Activity &#123; protected static final String FIXED_PREFIX = "_"; private final String TAG = getClass().getName(); private final List&lt;ButtonItem&gt; buttonItems = new ArrayList&lt;&gt;(); protected LinearLayout linearLayout; protected Context context; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Jump &#123; Class&lt;? extends Activity&gt;[] value() default &#123;&#125;; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.context = this; ScrollView scrollView = new ScrollView(this); setContentView(scrollView); this.linearLayout = new LinearLayout(this); this.linearLayout.setOrientation(LinearLayout.VERTICAL); scrollView.addView(linearLayout); try &#123; resolveConfig(); createButton(); &#125; catch (Throwable e) &#123; error(e.getMessage()); &#125; &#125; private void createButton() &#123; for (ButtonItem buttonItem : buttonItems) &#123; linearLayout.addView(buildButton(buttonItem)); &#125; &#125; protected View buildButton(final ButtonItem buttonItem) &#123; final Button button = new Button(this); button.setText(buttonItem.name); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (buttonItem.target != null) &#123; to(buttonItem.target); &#125; else &#123; Method method = buttonItem.method; method.setAccessible(true); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); int paramSize = parameterTypes.length; switch (paramSize) &#123; case 0: try &#123; method.invoke(DebugActivity.this); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; case 1: if (parameterTypes[0].isAssignableFrom(Button.class)) &#123; try &#123; method.invoke(DebugActivity.this, button); &#125; catch (Throwable e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; break; &#125; default: error(method.getName() + "方法参数配置错误."); break; &#125; &#125; &#125; &#125;); return button; &#125; private void resolveConfig() &#123; Class&lt;?&gt; cls = getClass(); //读取跳转配置 if (cls.isAnnotationPresent(Jump.class)) &#123; Jump annotation = cls.getAnnotation(Jump.class); for (Class&lt;? extends Activity&gt; activityClass : annotation.value()) &#123; buttonItems.add(buildJumpActivityItem(activityClass)); &#125; &#125; //读取方法 for (Method method : cls.getDeclaredMethods()) &#123; handleMethod(method); &#125; &#125; protected void handleMethod(Method method) &#123; String methodName = method.getName(); if (methodName.startsWith(FIXED_PREFIX)) &#123; methodName = methodName.replaceFirst(FIXED_PREFIX, ""); ButtonItem buttonItem = new ButtonItem(); buttonItem.method = method; buttonItem.name = methodName; buttonItems.add(buttonItem); &#125; &#125; protected ButtonItem buildJumpActivityItem(Class&lt;? extends Activity&gt; activityClass) &#123; ButtonItem buttonItem = new ButtonItem(); buttonItem.name = "跳转到" + activityClass.getSimpleName(); buttonItem.target = activityClass; return buttonItem; &#125; public void L(Object s) &#123; Log.i(TAG, s + ""); &#125; public void error(String errorMessage) &#123; T("[错误信息]\n" + errorMessage); &#125; public void T(Object message) &#123; Toast.makeText(context, String.valueOf(message), Toast.LENGTH_SHORT).show(); &#125; public void to(Class&lt;? extends Activity&gt; target) &#123; try &#123; startActivity(new Intent(this, target)); &#125; catch (Exception e) &#123; e.printStackTrace(); error(e.getMessage()); &#125; &#125; public void T(String format, Object... values) &#123; T(String.format(format, values)); &#125; protected static class ButtonItem &#123; public String name; public Method method; public Class&lt;? extends Activity&gt; target; &#125;&#125; JumpActivity.java.ftl 1234567891011121314151617181920package $&#123;packageName&#125;;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;/** * @author zijiao * @version 16/10/16 */public class JumpActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView text = new TextView(this); text.setText("跳转Activity成功"); setContentView(text); &#125;&#125; SimpleActivity.java.ftl 12345678910111213141516171819202122232425262728293031323334353637383940package $&#123;packageName&#125;;@DebugActivity.Jump(&#123;&lt;#if addJumpActivity&gt; JumpActivity.class,&lt;#else&gt;&lt;/#if&gt;&#125;)public class $&#123;activityClass&#125; extends DebugActivity &#123;&lt;#if addExample&gt; private int number = 0; public void _无参方法调用() &#123; T("无参方法调用"); &#125; public void _有参方法调用(Button button) &#123; button.setText("number is " + number++); &#125; //代码执行不到,直接弹出toast提示报错 public void _错误参数调用(String msg) &#123; T("test"); &#125; //方法名没有以"_"开头,按钮无法创建成功 public void 无效调用() &#123; T("test"); &#125; //crash会被会被catch住,以toast方式弹出 public void _Crash测试() &#123; int a = 1 / 0; &#125;&lt;/#if&gt;&#125; ok，到此对于该模板的编写过程就结束了，接下来重启下Android Studio，然后New Project一路next下去，直到这个界面，这里就是我们自定义的DebugActivity模板了 下面是该模板的Github源码 https://github.com/puke3615/DebugActivity.git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之文件]]></title>
    <url>%2F2016%2F10%2F15%2FAndroid-Studio-Template-For-File%2F</url>
    <content type="text"><![CDATA[文件模板是指以一个文件为基础的模板，这种形式的模板比代码片段级别的模板要复杂一些，模板中设计到VTL(Velocity Template Language)语法。文件级别比代码级别能够存储更多的代码内容，而且能够通过VTL很大程度上提高模板的灵活度，让模板不再是一个不变的文本字符串。 我们开发的过程中可能会遇到有些类在不同的工程下都需要使用，单独抽成jar包可能又有点小题大做了，而且还得在下次使用的时候去依赖它，这个时候我们AS中的FileTemplate便派上用场了。 我们开发中可能经常去写一个继承BaseAdapter的子Adapter，而且里面有一大串无脑代码，于是我写了这个DataAdapter的模板。 Android Studio给我提供了创建模板的快捷方式，我们可以打开任意一个类，然后选择顶部的Tools—Save File As Template便可以快速创建一个当前类的模板文件 或者直接通过Preferences — Editor — File and Code Templates右边的加号创建 然后IDE会自动打开这个界面 大致说下这几个区域 区域1：模板的名称，唯一标识一个文件模板 区域2：模板的后缀名，填写当前属于哪种文件的模板 区域3：模板编辑区 区域4：一些可选配置 区域5：官方对FileTemplate的简单描述，往下滑我们可以看到系统的预设变量（类似于上一章中的预设变量），这里的内容不是很多但营养价值很高，建议看一下 接下来我们编辑模板，把这段模板内容直接粘贴到编辑区，然后给模板命名为User即保存关闭该弹窗 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] name = &#123;&#125;;&#125; 现在我们来引入刚写的模板，右键选择待添加模板的包 — New — User 也可以New一个Java Class然后在弹窗中通过上下方向键或者下拉列表来选择找到创建的User模板 还可以直接在New下面选择 创建模板之后的引入方式有很多，我们可以使用自己比较喜欢的方式去引入。最终输入文件名点确定，代码直接生成出来。 上面说的是最基本的文件模板需求，当我们的文件需要多个参数时，例如User这个模板的name属性名可能是多边的，只有引入模板时才能确定下来，这时我们可以用自定义变量来表示，如下 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end/** * @author $&#123;USER&#125; * @version $&#123;DATE&#125; */public class $&#123;NAME&#125; &#123; public String[] $&#123;fieldName&#125; = &#123;&#125;;&#125; 这个时候我们再引入模板时，IDE会扫描有没有自定义变量，如果有的并且没有被初始化赋值的话就在弹出的对话框中多一个可编辑的区域，如下图 这便支持自定义参数的场景，到这一步为止，一般的文件模板需求我们都可以自己满足了。下面介绍一些相对深一点的使用方式，有兴趣的可以看看。 Android Studio的FileTemplate使用Velocity Template Language（简称VTL）进行逻辑判断和流程控制，有兴趣的可以直接看下Velocity的官方文档。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模板之代码片段]]></title>
    <url>%2F2016%2F10%2F14%2FAndroid-Studio-Template-For-Part%2F</url>
    <content type="text"><![CDATA[代码片段是Template上的最小单位，因此它也具有最大的灵活性，支持多参数配置、TAB切换、代码块包装等多种特性（IDEA同样适用）。 创建一个单例类 写一个将InputStream转化为String的方法 生成main方法并打印数字 用try catch来包装代码块 上面的这些有的是IDE自带的，有的是自定义的。具体位置我们可以进入IDE，Preserences，Editor，Live Templates，我们可以在右边栏看到一些列IDE预设的template，如下图 这里我们展开Android，可以看到下图 这里面所有的我们都可以使用，括号后面的内容是为了描述该模板的，你也可以取消前面的勾选来取消该模板。 其实系统预设的有很多都是很实用的，有兴趣的可以去试一试，不多说。这里主要看一下如何自定义模板，把一些常用的代码片段DIY到自己的模板库中，当下次再需要同样代码的时候只需要一个标识符就能迅速自动生成。 我们点击右上角的加号，我们可以看到两个选项一个是Live Template，这个表示一个模板，另一个是Template Group，这个表示一个模板所属的分组，就像上面看到的Android，它就属于一个分组。 接下来我们先创建一个自己的Template Group，名称随便取，不要与已有的分组重名就行，这里就取为Custom。然后我们选中新建的这个Custom分组再创建Live Template，会看到如下界面 我对这个界面做了数字标志，大致说下每个区域代表的含义 区域1：表示模板的缩写，也是我们最终使用时在编辑区输入的指令 区域2：表示模板的提示，当输入对应缩写时，就会弹出这个提示 区域3：这里就是最关键的模板区了，模板区包含两部分，一个是模板内容，它可以是任意字符串，另一个是模板变量，它有自己特殊的含义并且格式固定，首尾都是”$”符。模板变量又包含预设变量和自定义变量，比如”$END$”就是一个预设变量，它指定了模板导入结束后鼠标光标最终要停留的位置，而自定义变量则表示模板中一些动态性的部分，比如类名，它在不同的类中引入的结果是不同的。在多个自定义变量的情况下引入模板时，默认按TAB键切换至下个自定义变量位置。 区域4：自定义变量的配置入口，可以给我们的自定义变量添加一些约束条件 区域5：指定该模板的作用域，例如指定用于Java还是groovy等等 区域6：提供一些引入模板的可选操作 这里我们来写一个生成单例的模板，我们按照下图定义好缩写，描述与模板内容 模板内容的代码如下 12345678910111213141516private static final byte[] sInstanceLock = new byte[0];private static $className$ sInstance;private $className$() &#123;&#125;public static $className$ instance() &#123; if (sInstance == null) &#123; synchronized (sInstanceLock) &#123; if (sInstance == null) &#123; sInstance = new $className$(); &#125; &#125; &#125; return sInstance;&#125; 然后我们选择区域4来编辑我们的自定义变量，我们进去后可以看到如下弹窗 Name为自定义的变量名称 Expression表示系统提供的一些方法 Default value为改变量的默认值 Skip if define勾选后，如果该变量被赋值则跳过，相当于引入过程中一次手动的TAB 接着我们在Expression中选择className()，并勾选Skip if define，并点击确定 最后我们点击区域5来选择模板的作用域，我们选择Java—Declaration 然后保存，我们的单例模板便生成成功了。测试下，在IDE中新建个Java类，在类的内部输入single便出现最上面的那个UserManager的效果。 当然除此之外还有使用”$SELECTION$”来包装代码块的模板，这个使用场景相对较少这里就不举例了，主要使用的就是这种直接的模板模式。感觉一些常用的，特别是工具类中静态方法相关的，我们都可以抽取成模板，提高开发效率。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>高效开发</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CallbackProxy模式]]></title>
    <url>%2F2016%2F09%2F04%2FCallbackProxy%2F</url>
    <content type="text"><![CDATA[对于一个核心类或者框架来说，通常会在运行时向外部回调多种操作以便于使用方做出一些主流程上面的AOP或者Intercept操作。而很多操作可能是预留不足以提供的，当我们逐渐去拓展我们的Callback时，使用方的代码将会大量增加，于是引入CallbackProxy的模式解决这个问题。 Callback问题背景1234567891011121314151617181920212223242526public class Manager &#123; public void operate() &#123; a(); b(); c(); d(); e(); &#125; private void a() &#123; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 这是一个简单的Manager类，模拟的是一个底层框架向上层提供的管理类，这里先假设我们这个类的使用方有10个(在这里我们就编号C1~C10)，而他们最终的运行环境都是一致的，只是开发期的环境不一致。我想过直接把一些真实场景中的代码拿出来举例，但是偏向业务的代码往往比较复杂且冗余，所以这里我们就简单粗暴地写了几个空方法模拟。其中operate()方法是提供给外部调用的方法，operate()方法中会调用到内部的a~e的一系列方法。 需求叠加本来是一个简单的业务逻辑，但是突然有个业务方C1说他们需要在Manager的operate()方法的a()方法中添加一个回调，给业务方去处理。于是便有了我们的Callback接口： 123public interface Callback &#123; void callA();&#125; 并且我们还要改造我们的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private Callback mCallback; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; private void b() &#123; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们在Manger类中添加一个Callback变量，并向业务方提供了setCakkback(CallbackA callback)方法为了方便外部把自己想在a()方法中做的操作set进来，这样处理既能让我们的业务方C1能够在a()方法中做他们定制化的处理，也不会影响到其他业务方的正常使用。 下面便是业务方C1的代码实现部分： 1234567891011121314public class ClientA &#123; public static void main(String[] args) &#123; Manager manager = new Manager(); manager.setCallbackA(new Callback() &#123; @Override public void callA() &#123; //do something &#125; &#125;); manager.operate(); &#125; &#125; 需求再叠加由于业务是多变的，业务会随着许多主观以及客观的情况不断发生改变，某一天我们的业务方C2突然跟我们说，他们需要在b()方法中添加一个回调以处理他们内部的业务逻辑。于是我们开始考虑，上次C1提到要在a()方法中添加回调的时候，我们有创建了一个Callback的接口，并且有在Manager类中提供了setCallback()方法，那我们能不能为了代码的复用性而直接在Callback接口中添加一个回调方法callB()呢。但答案是否认的，因为如果你这样做了，业务方C1会莫名躺枪的…… 既然我们不能添加Callback中的方法，又不想想我们对业务方C2支持的同时又去影响到C1，那我们只能新建一个接口CallbackB了： 123public interface CallbackB &#123; void callB(); &#125; 于是，我们的Manager又得这样改变： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Manager &#123; private Callback mCallback; private CallbackB mCallbackB; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; private void a() &#123; if (mCallback != null) &#123; mCallback.callA(); &#125; &#125; public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB; &#125; private void b() &#123; if (mCallbackB != null) &#123; mCallbackB.callB(); &#125; &#125; private void c() &#123; &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们开始看一下我们对Manager类的改动，我们这次的代码增量是： 123456789101112//1. 新增的CallbackB属性private CallbackB mCallbackB;//2. 新增的CallbackB的set方法public void setCallbackB(CallbackB callbackB) &#123; this.mCallbackB = callbackB;&#125;//3. 新增的回调逻辑的调用时机if (mCallbackB != null) &#123; mCallbackB.callB();&#125; 我这里将增量部分切分为1、2、3三个部分。我们来仔细分析一下这三个部分，其中1和2其实是一种“无脑操作”，就是新增加一个回调接口，并提供回调接口的set方法而已，更甚至来说，3中的非空判断也都是冗余的。 仅仅为了满足C2的回调处理其实是简单的，只是既然今天C2会过来说是需要b()方法的回调，那接下来谁也不敢保证C3、C4、C5会不会再过来提出要在c()方法，d()方法，e()方法中添加对应的回调，甚至C3要abc的回调，C4要ace的回调。业务简单的时候，代码不一定是简单的，但是业务复杂的时候，代码一定是复杂的。 而且，站在职责单一的角度来看，对于我们的Manager类是不应该去维护这样一系列繁琐的Callback，并且还要在每个回调时机时进行非空判断的。 CallbackProxy模式CallbackProxy的引入这里我们引入CallbackProxy模式，我们先定义一个空接口： 12public interface Callback &#123;&#125; 这个接口就是对于Manager类的一个统一协定，协定所有Manager向外的回调都必须继承该接口。 接下来便有我们的一系列Callback： 123public interface CallbackA &#123; void callA();&#125; 123public interface CallbackB &#123; void callB();&#125; 123public interface CallbackC &#123; void callC();&#125; 然后有一个类来实现所有的Manager需要向外回调的Callback，然后都是一些空实现。 12345678910111213141516public class SimpleCallback implements CallbackA, CallbackB, CallbackC &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125;&#125; 然后便有我们的重头戏CallbackProxy，它继承于SimpleCallback，然后内部存储一个真实的Callback，并向外提供一个setCallback()方法: 1234567891011121314151617181920212223242526272829public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125;&#125; 接下来我们来看一下我们的引入CallbackProxy之后的Manager类： 1234567891011121314151617181920212223242526272829303132333435public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; &#125; private void e() &#123; &#125;&#125; 我们可以看到，现在的Manager类不需要再声明一系列的Callback，再提供一系列的setCallback方法，再来一堆的非空判断，这些都让我们的CallbackProxy来做了。而我们的Manger类只需要专注于他自己的业务逻辑处理和选择合适的时机进行回调即可。 拓展性上面的引入Callback的例子中我们写了a~c的回调，现在假如某个业务方还需要我们提供d()方法的回调，接下来我们只需要在新建一个CallbackD类，并在SimpleCallback和CallbackProxy做出对应的改变，然后在我们的真正做回调处理的Manager类中直接在d()方法中调用mCallback的callD()方法即可，代码如下： 123public interface CallbackD &#123; void callD();&#125; 123456789101112131415161718192021public class SimpleCallback implements CallbackA, CallbackB, CallbackC, CallbackD &#123; @Override public void callA() &#123; &#125; @Override public void callB() &#123; &#125; @Override public void callC() &#123; &#125; @Override public void callD() &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class CallbackProxy extends SimpleCallback &#123; private Callback mCallback; public void setCallback(Callback callback) &#123; this.mCallback = callback; &#125; @Override public void callA() &#123; if (mCallback instanceof CallbackA) &#123; ((CallbackA) mCallback).callA(); &#125; &#125; @Override public void callB() &#123; if (mCallback instanceof CallbackB) &#123; ((CallbackB) mCallback).callB(); &#125; &#125; @Override public void callC() &#123; if (mCallback instanceof CallbackC) &#123; ((CallbackC) mCallback).callC(); &#125; &#125; @Override public void callD() &#123; if (mCallback instanceof CallbackD) &#123; ((CallbackD) mCallback).callD(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Manager &#123; private CallbackProxy mCallbackProxy; public void operate() &#123; a(); b(); c(); d(); e(); &#125; public void setCallback(Callback callback) &#123; mCallbackProxy.setCallback(callback); &#125; private void a() &#123; mCallbackProxy.callA(); &#125; private void b() &#123; mCallbackProxy.callB(); &#125; private void c() &#123; mCallbackProxy.callC(); &#125; private void d() &#123; mCallbackProxy.callD(); &#125; private void e() &#123; &#125;&#125; 我们会发现我们的逻辑变得很清晰，类虽然多点，但是各司其职、有条不紊。 更高效开发其实到了上面，CallbackProxy的介绍已经是完成了，但有一点需要说明，就是关于对Callback拓展的时候。我们发现其实我们真正做的回调操作仅仅是定义CallbackD和在Manager的d()方法中添加callB()的回调这两个地方。其他的在SimpleCallback和CallbackProxy的处理都是绝对无脑的，于是我们应用APT技术来简化我们的SimpleCallback和CallbackkProxy的处理(由于该篇不是为了介绍APT的，这里只把简单的使用效果贴出来)。 12345678@ProxyGenerator( rootClass = Callback.class)public interface Api extends Base, CallbackHolder.Callback1, CallbackHolder.Callback2, CallbackHolder.Callback3, CallbackHolder.Callback4 &#123; String login(String username);&#125; 这里我们只需要写一个接口继承我们所有需要添加的Callback，然后加上一些注解配置，即可自动生成对应的SimpleCallback和CallbackProxy类： 123456789101112131415161718192021222324252627282930313233public abstract class SimpleApi implements Api &#123; @Override public String login(String username) &#123; return null; &#125; @Override public void base() &#123; &#125; @Override public int commonOperation() &#123; return 0; &#125; @Override public void call1() &#123; &#125; @Override public void call2(String name, int age) &#123; &#125; @Override public int call3(String name) &#123; return 0; &#125; @Override public String call4(int age) &#123; return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public final class ApiProxy implements Api &#123; private Callback mCallback; @Override public String login(String username) &#123; if (mCallback instanceof Api) &#123; return ((Api) mCallback).login(username); &#125; return null; &#125; @Override public void base() &#123; if (mCallback instanceof Base) &#123; ((Base) mCallback).base(); &#125; &#125; @Override public int commonOperation() &#123; if (mCallback instanceof Base) &#123; return ((Base) mCallback).commonOperation(); &#125; return 0; &#125; @Override public void call1() &#123; if (mCallback instanceof CallbackHolder.Callback1) &#123; ((CallbackHolder.Callback1) mCallback).call1(); &#125; &#125; @Override public void call2(String name, int age) &#123; if (mCallback instanceof CallbackHolder.Callback2) &#123; ((CallbackHolder.Callback2) mCallback).call2(name, age); &#125; &#125; @Override public int call3(String name) &#123; if (mCallback instanceof CallbackHolder.Callback3) &#123; return ((CallbackHolder.Callback3) mCallback).call3(name); &#125; return 0; &#125; @Override public String call4(int age) &#123; if (mCallback instanceof CallbackHolder.Callback4) &#123; return ((CallbackHolder.Callback4) mCallback).call4(age); &#125; return null; &#125; public final void setCallback(Callback mCallback) &#123; this.mCallback = mCallback; &#125;&#125; 也就是说当我们需要拓展一个新的Callback时，只需要让Api这个接口多继承一个新的Callback并generate，然后 就可以在Manager类中添加对应的回调就ok了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FCodeGenerator%2F</url>
    <content type="text"><![CDATA[Android Studio Plugin的一些拓展插件使用，简化我们的日常开发。 单例生成 Copy生成 FindView生成 MainMethod生成 Activity添加到AndroidManifest.xml]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>Android Studio Plugin - 高效开发 - Generaotr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BuilderGenerator]]></title>
    <url>%2F2016%2F08%2F29%2FBuilderGenerator%2F</url>
    <content type="text"><![CDATA[日常开发中，我们经常会使用到Builder模式，我们一般都是直接手动地去写一个Builder类来使用。这里我们采用APT的方式进行配置生成Builder类。 快速接入配置apt依赖外层gradle添加 1classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4' 内层build.gradle添加 1apply plugin: 'com.neenbedankt.android-apt' 配置该框架依赖内层build.gradle添加 12compile 'com.puke:buildergenerator-api:1.0.0'apt 'com.puke:buildergenerator-compiler:1.0.0' 到这里，配置部分就结束了，接下来就是使用过程。 使用姿势这里我们模拟一个需要使用Builder模式的类Dog 123456789101112131415public class Dog &#123; private String name; private int age; private String sex; private Color color; @Builder("configure") Dog(@Item("customName") String name, @Item int age, @Item String sex, Color color) &#123; this.name = name; this.age = age; this.sex = sex; this.color = color; &#125;&#125; 然后只需要build一下Project就ok了 我们可以在该Module的“build/generated/source/apt”目录下找到对应的DogBuilder类，如下 1234567891011121314151617181920212223242526272829// this is a generated file.package com.puke.buildergeneator;public final class DogBuilder &#123; private String customName; private int age; private String sex; public final DogBuilder configureCustomName(String customName) &#123; this.customName = customName; return this; &#125; public final DogBuilder configureAge(int age) &#123; this.age = age; return this; &#125; public final DogBuilder configureSex(String sex) &#123; this.sex = sex; return this; &#125; public final Dog build() &#123; return new Dog(customName, age, sex, null); &#125;&#125; 几点说明整体比较轻巧，使用起来也比较简单，我们可以重点看一下该类的构造方法，接下来几点说明： 构造方法上面加了@Builder注解 表示该类是要生成Builder类 @Builder中注入了“configure” 表示生成注解类的组装子Item的方法前面全部都要加上”configure“关键字，当然这个是可选的，如果不加的话就会直接就直接取方法名 构造方法中加入了@Item注解 加入了@Item注解的参数表示Builder类中可以加入的参数，未加则不能通过Builder加入 @Item中注入“customName” 表示在Builder类中给对应的属性设置的别名，不设时默认去参数名 项目源码https://github.com/puke3615/BuilderGeneator.git]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>APT</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android注解]]></title>
    <url>%2F2016%2F08%2F29%2FAndroid-Annotation%2F</url>
    <content type="text"><![CDATA[在Java中经常会用到注解，通过注解的方式可以实现很多灵活性的东西。很多优秀的框架都支持注解的方式，如Spring的中对Bean的注解，Hibernate中对POJO类的注解，Mybatis中对Mapper的注解，ButterKnife中对View的注解，Dagger中对各个Component的注解， Retrofit对Api的注解。一言以蔽之，使用注解可以让整个代码风格看起来清爽明了。 传统的代码风格activity_main.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/username" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入用户名.." /&gt; &lt;Button android:id="@+id/submit" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="提交" /&gt;&lt;/LinearLayout&gt; 很简单的一个界面，只有一个EditText和一个Button，就不过多解释了。 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends Activity &#123; private EditText mUsername; private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); initListener(); &#125; private void findView() &#123; mUsername = (EditText) findViewById(R.id.username); mSubmit = (Button) findViewById(R.id.submit); &#125; private void initListener() &#123; mSubmit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 我们这里要做到是用户点击提交的时候，Toast弹出EditText输入的内容，比较简单，略过~ 传统的风格是这样的，这样看来也许觉得没什么问题，但是实际的开发当中我们一个页面当中包含的View，以及对应的View的一些事件回调要远远比这个繁琐。我相信一个Activity中要处理十几二十几个View也不算是什么稀奇的事情，那这样会造成什么结果呢。。。 你的属性声明会是这样的 12345678private Button mButton1;private Button mButton2;private Button mButton3;private Button mButton4;private Button mButton5;private Button mButton6;private Button mButton7;private Button mButton8; 你的findView会是这样的 12345678mButton1 = (Button) findViewById(R.id.button1);mButton2 = (Button) findViewById(R.id.button2);mButton3 = (Button) findViewById(R.id.button3);mButton4 = (Button) findViewById(R.id.button4);mButton5 = (Button) findViewById(R.id.button5);mButton6 = (Button) findViewById(R.id.button6);mButton7 = (Button) findViewById(R.id.button7);mButton8 = (Button) findViewById(R.id.button8); 你的事件监听会是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mButton1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);mButton8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 例子举得不怎么恰当，但是足以说明随着业务代码的不断扩大，这些看上去的”无脑操作“也会让我们广大coder变得愈加的不耐烦，而且会使得我们的类变得庞大而臃肿。 那么，接下来我们就通过注解的方式来搞一发~ 注解的编码风格我们打算使用注解的方式实现 xml的配置 View的注入 点击事件的绑定 接下来就是具体实现逻辑 首先我们先定义一个Bind注解 12345678910111213141516package com.puke.annotationdemo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/18 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)public @interface Bind &#123; int value() default 0;&#125; 然后写Bind注解对应的注解处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.puke.annotationdemo;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author zijiao * @version 16/8/18 */public class BindHandler &#123; /** * 处理对Activity的注解 * * @param activity 目标Activity */ public static void handleBind(Activity activity) &#123; Class cls = activity.getClass(); handleSetContentView(activity); handleFindView(cls.getDeclaredFields(), activity); handleClickEvent(cls.getDeclaredMethods(), activity); &#125; //绑定xml布局 private static void handleSetContentView(Activity activity) &#123; Class&lt;?&gt; cls = activity.getClass(); if (cls.isAnnotationPresent(Bind.class)) &#123; //Activity中加入Bind注解时取出注解配置 Bind bind = cls.getAnnotation(Bind.class); int layout = bind.value(); if (layout != 0) &#123; activity.setContentView(layout); &#125; &#125; &#125; //View的注入 private static void handleFindView(Field[] declaredFields, Activity activity) &#123; if (declaredFields == null || declaredFields.length == 0) &#123; return; &#125; for (Field field : declaredFields) &#123; //找到被Bind注解且是View的所有属性 if (field.isAnnotationPresent(Bind.class) &amp;&amp; View.class.isAssignableFrom(field.getType())) &#123; Bind bind = field.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; View view = activity.findViewById(id); field.setAccessible(true); try &#123; //直接通过反射set进去 field.set(activity, view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //点击事件的绑定 private static void handleClickEvent(Method[] declaredMethods, final Activity activity) &#123; if (declaredMethods == null || declaredMethods.length == 0) &#123; return; &#125; for (final Method method : declaredMethods) &#123; //找到被Bind注解且无参的所有方法（注意这里限制无参是为了与下面调用method.invoke(activity)的无参保持一致） if (method.isAnnotationPresent(Bind.class) &amp;&amp; method.getParameterTypes().length == 0) &#123; Bind bind = method.getAnnotation(Bind.class); int id = bind.value(); if (id != 0) &#123; activity.findViewById(id).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; method.invoke(activity); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125;&#125; 好了，到了这一步，我们的注解工作算是结束了，代码相对有点多，但这个是一劳永逸的。 接下来就是对注解的使用了 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bind(R.layout.activity_main)public class MainActivity extends Activity &#123; @Bind(R.id.username) private EditText mUsername; @Bind(R.id.submit) private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind(R.id.submit) public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; Run一下，完美运行~ 我们这里可以看到，使用注解之后 setContentView方法没了 findViewById方法没了 setOnClickListener方法没了 MainActivity整个类减肥了 所有的所有，都让注解处理器一手承包了。而我们要做的是什么，要做的是真正应该由coder做的事情，在对应的地方加上对应的注解配置就ok了。 然后我们可以回过头看一下Bind这个注解，细心的同学可能发现注解声明value()的时候理论上来讲不应该有一个default为0的默认值。原因很简单啊，因为就目前的使用场景来看，无论注入一个layout还是一个id都不会为0，那这里干嘛还要再写一个default 0呢，直接不要default可以限制业务方的使用，强约束业务方一旦使用注解就必须要在注解里面set一个值进来。这里我要说明一下，我们写注解就是为了方便使用，快速开发，既然要懒，我们就懒到家，干脆就让我们的注解处理器能在业务方没有在Bind中注入值的时候也能生效。 就是要实现下面这种效果: 123456789101112131415161718192021222324252627282930package com.puke.annotationdemo;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;@Bindpublic class MainActivity extends Activity &#123; @Bind private EditText mUsername; @Bind private Button mSubmit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); BindHandler.handleBind(this); &#125; @Bind public void submit() &#123; String username = mUsername.getText().toString().trim(); Toast.makeText(MainActivity.this, username, Toast.LENGTH_SHORT).show(); &#125;&#125; 这样一来，只需要几个全裸的注解一顿狂注之后，就完事了。后面这种的实现方式我这里就不写了，大致说一下思路，注解处理器要制定类名—layout，属性名—id，方法名—id，这样一套转换标准出来，然后注解处理器的处理逻辑是先看业务方有没有手动注入，没有手动注入的情况（也就是前面提到的default 0）下，注解处理器再按照这套标准利用反射来取出对应的R类的对应资源值，只要找到对应的资源值，就和手动注入处理结果的完全一样。 一些问题每当一种事物出现时，只要不是太极端，总会有人拥护，也有人异议。单单站在coder的角度，这种注解的方式给我带来的好处是显而易见的，算是治愈代码密集恐惧症的偏方了。 但是值得深思的是，这里大量使用了反射，在Java中反射的性能问题总是尴尬的不要不要的。虽然jdk每次升级时基本上都在对反射进行优化，但是毕竟是反射，纯理论上讲，它确实没有直接的方法调用高效。 当然针对这个问题，我也有见过这样一种说法，假如我们对所谓”高效“的时间容忍度是1000t(t为一个时间粒度单位)，直接方法调用耗时是1t，反射是50 - 200t。也就是说，反射是耗性能，是不效率，但是这个也只是相对与直接方法调用而言的，而还远远没达到我们对性能指标的容忍值。 我曾经也在高效开发和反射性能消耗之间纠结很久，在这里就不去过多评价，仁者见仁，智者见智了~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>高效开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2016%2F08%2F29%2FJava-Reflection%2F</url>
    <content type="text"><![CDATA[Java是门面向对象的语言，其中的每一个对象都有与之对应的的Class。只要一提到Class，自然就想到Java的反射机制，可见反射在Java中的重要性。 Class的获取类名.class1Class cls = User.class; 对象.getClass()1Class cls = user.getClass(); Class.forName()12//注意这里的参数是类的全限定名(即含有包名)Class cls = Class.forName("com.reflect.User"); ClassLoader1Class cls = classLoader.findClass("com.reflect.User"); 创建对象通过Class创建公有的无参构造方法12Class&lt;User&gt; cls = User.class;User user = cls.newInstance(); 通过Constructor创建公有的无参构造方法123Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getConstructor();User user = constructor.newInstance(); 通过Constructor创建私有的无参构造方法12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor();//注意，此处使用暴力反射，反射中该方法经常被使用constructor.setAccessible(true);User user = constructor.newInstance(); 通过Constructor创建私有的含参构造方法12345Class&lt;User&gt; cls = User.class;Constructor&lt;User&gt; constructor = cls.getDeclaredConstructor(String.class, int.class);constructor.setAccessible(true);//注意，此处传递的参数类型和上面的String.class和int.class保持一致User user = constructor.newInstance("小莫", 3); 读写对象属性12345public class User &#123; public static int age; public String name; private String sex;&#125; 静态属性123456Class&lt;User&gt; cls = User.class;Field ageField = cls.getField("age");//读取静态属性int age = (int) ageField.get(null);//设置静态属性ageField.set(null, 10); 成员属性123456Class&lt;User&gt; cls = User.class;Field nameField = cls.getField("name");//读取成员属性String name = (String) nameField.get(user);//设置成员属性nameField.set(user, "大白"); 私有成员属性123456Field sexField = cls.getDeclaredField("sex");sexField.setAccessible(true);//读取私有成员属性String sex = (String) sexField.get(user);//设置私有成员属性sexField.set(user, "大白"); 调用对象方法12345678public class User &#123; public static void say(String name) &#123; System.out.println("My name is " + name); &#125; public int plus(int a, int b) &#123; return a + b; &#125;&#125; 静态方法123456Class&lt;User&gt; cls = User.class;//注意，这里第一个参数是指方法名，后面的参数是可变长参数，是目标方法的对应参数类型//若目标方法是无参的，则不填Method sayMethod = cls.getMethod("say", String.class);//静态方法不依赖对象实例，所以第一个参数是nullsayMethod.invoke(null, "胡巴"); 12后台输出: My name is 胡巴 成员方法1234567User user = new User();Class&lt;User&gt; cls = User.class;Method plusMethod = cls.getMethod("plus", int.class, int.class);//如果该方法是非public的，则要在invoke之前调用 plusMethod.setAccessible(true);//注意，由于该方法是成员方法，它的执行依赖于一个User实例，所以第一个参数是userint result = (int) plusMethod.invoke(user, 2, 7);System.out.println(result); 12后台输出：9 反射的简单应用123456789101112131415161718 上面我们对于反射中一些常用的Api进行了基本的认识，接下来我们进入一个简单的实战练习，案例驱动，以加深对反射的认识。 场景：我们正在使用一个第三方的jar包，包含两个类User和Dog(见下)，而我们现在需求是，要调用一个User实例中dog的happy方法。public class User &#123; private Dog dog = new Dog();&#125;class Dog &#123; public void sleep() &#123; System.out.println(&quot;the dog went to bed.&quot;); &#125;&#125; 有以下难点： 1. 这两个类都是在jar包里面的，不能直接修改 2. 我们要有Dog类的权限，但是Dog这个类是package的 3. 我们要拿到User实例中的dog引用，但是dog属性是private的 4. 我们最终要调用的sleep的方法也是private的没有反射的话，估计我们只能想到两种办法了，要么基于class字节码进行修改，要么直接找需求方互相伤害去~废话不多说，接下来我们来看通过使用反射的方式，来KO这个需求 12345678910111213141516171819202122//1. 获取user对象对应的ClassClass&lt;User&gt; userCls = User.class;//2. 获取到改对象的dog属性Field dogField = userCls.getDeclaredField("dog");//3. 通过dogField属性获取user实例中对应的dog实例//注意,由于Dog类是package级别的,所以这里无法直接声明Dog,只能使用Object代替dogField.setAccessible(true);Object dog = dogField.get(user);//4. 获取dog对象对象的Class对象Class&lt;?&gt; dogCls = dog.getClass();//这里也可以使用这种方式//Class dogCls = Class.forName("com.groovy.reflect.Dog");//5. 获取到Dog的sleep方法Method sleepMethod = dogCls.getDeclaredMethod("sleep");//6. 调用sleep方法sleepMethod.setAccessible(true);sleepMethod.invoke(dog); 12后台输出：the dog went to bed.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2016%2F08%2F29%2FDynamic-Proxy%2F</url>
    <content type="text"><![CDATA[Java的动态代理极大程度提高了我们开发的灵活度，使用动态代理我们能达到强解耦的目的。动态代理能够给我们带来很多开发便捷，这里就介绍下在Android网络请求时的应用。 动态代理实现方式Java中的动态代理给我们提供一种动态生成类的方式，有很好的灵活性，这种技术一般会出现在一些第三方框架中，来降低接入方的使用成本。以下为常用的实现动态代理的几种方式： JDK自带的Proxy方式优点：JDK亲儿子；无依赖；使用简单 缺点：代理类必须继承至少一个接口；无法继承已有父类 asm方式，基于class字节码的操作优点：很底层的操作，性能高，对性能要求苛刻的建议使用 缺点：使用成本高，要熟悉JVM汇编指令 javassist方式，基于class字节码的操作优点：Api简单，通熟易懂，使用成本低 缺点：性能相对偏低 cglib方式，这个是基于ASM的​优点：Api简单；高性能；高灵活性；支持继承父类；可以不用实现接口 缺点：这个真的很强大，个人感觉比JDK自带的要强大很多，一定要说的话只能说使用这个需要加jar包依赖 业务开发的尴尬开门见山，我们直接来看一个业务场景： 1234567891011121314151617181920212223package com.puke.net;/** * @author zijiao * @version 16/8/19 */public class User &#123; public String username; public String uId; public String sex; public String address; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", uId='" + uId + '\'' + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 这里就是一个用户信息的Entity类，不解释了。 123456789101112131415161718192021222324252627282930package com.puke.net;import com.google.gson.Gson;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class VirtualHelper &#123; private static final Gson sGson = new Gson(); public static String request(String url, Map&lt;String, Object&gt; params) &#123; if (params != null) &#123; if ("123".equals(params.get("username")) &amp;&amp; "456".equals(params.get("password"))) &#123; User user = new User(); user.address = "杭州"; user.sex = "男"; user.uId = "Id"; user.username = "啊啊"; return sGson.toJson(user); &#125; &#125; return null; &#125;&#125; 这里我们模拟一个简单的网络请求。 当我们业务场景需要调用网络请求执行登录操作的时候，会这样写： 1234567891011121314151617181920212223242526package com.puke.net;import com.google.gson.Gson;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 那么，有什么问题呢。其实如果只是一个单单的login方法很难直观的反馈出来问题所在，很多时候我们为了去验证一个事物的合理性我们不妨去开始极端遐想一下这种情况：现在UserApi中又多了register方法，query方法，getToken方法，validate方法……甚至接下来一个UserApi已经满足不了我们了，我们开始有GoodsApi，OrderApi，MessageApi等等等等，试想一下N个Api的类，每个Api类都有N个类似于上面login的这种方法，而实际情况下我们request的入参还远远不止username，password两个这么简单。当我们业务场景扩大的时候，这些都是我们势必要面对的。这是一个问题，那能不能去以一种更优雅的方式去解决从而简化业务方的代码量并且降低使用成本呢。这里便引入了我们的动态代理~ 动态代理的方式去解决我们的目标状态是这样的：让业务方写写接口，加加注解配置，就可以直接使用 先定义两个支持配置的注解123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface URL &#123; String value();&#125; 123456789101112131415161718package com.puke.net.proxy;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author zijiao * @version 16/8/19 */@Inherited@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@interface Param &#123; String value();&#125; 这里不过多说明，就是两个可配字符串的注解。 定义一套接口这一步，其实不是必需的。我们完全可以在动态代理中直接显式的调用VirtualHelper类，但既然抽象出来网络Api这块，那就干脆定义一套接口出来来解耦具体实现。 1234567891011121314151617package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public interface IRequest &#123; String url(); Map&lt;String, Object&gt; params(); Class&lt;?&gt; responseCls();&#125; 123456789101112131415161718192021222324252627282930313233343536package com.puke.net.proxy;import java.util.Map;/** * @author zijiao * @version 16/8/19 */public class Request implements IRequest &#123; String url; Map&lt;String, Object&gt; params; Class&lt;?&gt; responseCls; public Request(String url, Map&lt;String, Object&gt; params, Class&lt;?&gt; responseCls) &#123; this.url = url; this.params = params; this.responseCls = responseCls; &#125; @Override public String url() &#123; return url; &#125; @Override public Map&lt;String, Object&gt; params() &#123; return params; &#125; @Override public Class&lt;?&gt; responseCls() &#123; return responseCls; &#125;&#125; 这是请求接口和实现类，粗略写下，比较简单 1234567891011package com.puke.net.proxy;/** * @author zijiao * @version 16/8/19 */public interface INetExecutor &#123; &lt;T&gt; T execute(IRequest request);&#125; 123456789101112131415161718192021package com.puke.net.proxy;import com.google.gson.Gson;import com.puke.net.VirtualHelper;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class DefaultNetExecutor implements INetExecutor &#123; private static final Gson sGson = new Gson(); @Override public &lt;T&gt; T execute(IRequest request) &#123; String response = VirtualHelper.request(request.url(), request.params()); return (T) sGson.fromJson(response, request.responseCls()); &#125;&#125; 这个是网络执行器已经默认的实现方式（使用上面的VirtualHelper），主要是抽象出接口可以让业务方自主定制真正的执行操作。 动态代理器这个就直接上代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.puke.net.proxy;import android.text.TextUtils;import java.lang.annotation.Annotation;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * @author zijiao * @version 16/8/19 */@SuppressWarnings("unchecked")public class ApiGenerator &#123; private static final Map&lt;Class, Object&gt; sApiCache = new HashMap&lt;&gt;(); private static INetExecutor sNetExecutor; private static class Handler&lt;T&gt; implements InvocationHandler &#123; private Class&lt;T&gt; apiInterface; public Handler(Class&lt;T&gt; apiInterface) &#123; this.apiInterface = apiInterface; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; IRequest request = resolveRequest(method, args, apiInterface); if (sNetExecutor == null) &#123; sNetExecutor = defaultNetExecutor(); &#125; return sNetExecutor.execute(request); &#125; &#125; private static &lt;T&gt; IRequest resolveRequest(Method method, Object[] args, Class&lt;T&gt; apiInterface) &#123; StringBuilder urlBuilder = new StringBuilder(); Map&lt;String, Object&gt; params = null; if (apiInterface.isAnnotationPresent(URL.class)) &#123; String baseUrl = apiInterface.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(baseUrl)) &#123; urlBuilder.append(baseUrl); &#125; &#125; if (method.isAnnotationPresent(URL.class)) &#123; String subUrl = method.getAnnotation(URL.class).value(); if (!TextUtils.isEmpty(subUrl)) &#123; urlBuilder.append(subUrl); &#125; &#125; int index = 0; for (Annotation[] annotations : method.getParameterAnnotations()) &#123; for (Annotation annotation : annotations) &#123; if (annotation instanceof Param) &#123; String key = ((Param) annotation).value(); if (!TextUtils.isEmpty(key)) &#123; if (params == null) &#123; params = new HashMap&lt;&gt;(); &#125; params.put(key, args[index]); &#125; break; &#125; &#125; index++; &#125; return new Request(urlBuilder.toString(), params, method.getReturnType()); &#125; private static INetExecutor defaultNetExecutor() &#123; return new DefaultNetExecutor(); &#125; public static &lt;T&gt; T generateApi(Class&lt;T&gt; apiInterface) &#123; if (apiInterface == null || !apiInterface.isInterface()) &#123; throw new RuntimeException("the apiInterface is null or isn`t interface."); &#125; synchronized (ApiGenerator.class) &#123; Object api = sApiCache.get(apiInterface); if (api == null) &#123; api = Proxy.newProxyInstance(apiInterface.getClassLoader(), new Class[]&#123;apiInterface&#125;, new Handler(apiInterface)); sApiCache.put(apiInterface, api); &#125; return (T) api; &#125; &#125; /** * 外部提供自定义执行器 * * @param netExecutor 网络执行器 */ public static void setNetExecutor(INetExecutor netExecutor) &#123; sNetExecutor = netExecutor; &#125;&#125; 到此，我们的动态代理的编码部分就结束了。我们可以看一下ApiGenerator这个类有个sApiCache的静态变量，他缓存了动态代理生成的对象，这里这样做还是很有必要的，防止重复创建Api的代理类造成额外的性能消耗。 使用姿势业务方只需要按照我们约束的一套标准来写一个interface即可 1234567891011121314151617package com.puke.dynamicproxy;import com.puke.net.User;import com.puke.net.proxy.Param;import com.puke.net.proxy.URL;/** * @author zijiao * @version 16/8/19 */@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是业务方要写的接口，以及对应的一些注解配置。 接下来就可以直接使用LoginApi生成的具体实例了 1234567891011121314151617181920212223242526package com.puke.dynamicproxy;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.widget.Toast;import com.puke.net.User;import com.puke.net.proxy.ApiGenerator;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.login).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LoginApi loginApi = ApiGenerator.generateApi(LoginApi.class); User user = loginApi.login("123", "456"); Toast.makeText(MainActivity.this, user.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 由于此处模拟的网络请求，就不考虑主线程的进行这个操作了。 使用对比这里我再贴一下使用前后的代码对比 123456789101112131415public class UserApi &#123; private static final String API_LOGIN = "http://***.***.***"; private static final Gson sGson = new Gson(); public static User login(String username, String password) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("username", username); params.put("password", password); String response = VirtualHelper.request(API_LOGIN, params); //注，这里只是为了举例说明一下，就假设此时的数据结构就是跟User一致的 return sGson.fromJson(response, User.class); &#125;&#125; 这个是传统的Api方式下业务方要写的代码 12345@URL("http://***.***.***")public interface LoginApi &#123; User login(@Param("username") String username, @Param("password") String password);&#125; 这个是使用了动态代理之后业务方要写的代码 对比一下，明显能感觉到我们的代码精简了一大圈，看上去清晰明了~ 这里我们再回归到最近开始提到的问题，当业务逐渐扩大的时候，这两种模式下，无论是开发效率上还是代码精简度上根本不具有可比性。 一些想法其实，基于动态代理我们还可以做很多事情，当某一类事物有一些共性，我们一直重复去写一堆“孪生”代码，不仅降低了我们的开发效率，还容易让我们产生一种思维定式，按照一个固有的模式去重复做一类事太容易固化我们的思维。不仅仅是动态代理，还有很多很多，开发本该是件轻松的事。工欲善其事，必先利其器。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>高效开发</tag>
        <tag>动态代理</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
